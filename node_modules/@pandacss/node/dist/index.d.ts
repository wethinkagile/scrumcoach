import * as _pandacss_types from '@pandacss/types';
import { LoadConfigResult, Artifact, Runtime, PandaHooks, WatchOptions, WatcherEventType, ParserResultInterface, ArtifactId, Config, CssArtifactType } from '@pandacss/types';
import { StyleEncoder, Stylesheet } from '@pandacss/core';
import { Generator } from '@pandacss/generator';
import * as _pandacss_parser from '@pandacss/parser';
import { Project, ParserResult } from '@pandacss/parser';
import { Root, Message } from 'postcss';

declare class DiffEngine {
    private ctx;
    private prevConfig;
    constructor(ctx: Generator);
    /**
     * Reload config from disk and refresh the context
     */
    reloadConfigAndRefreshContext(fn?: (conf: LoadConfigResult) => void): Promise<_pandacss_types.DiffConfigResult>;
    /**
     * Update the context from the refreshed config
     * then persist the changes on each affected engines
     * Returns the list of affected artifacts/engines
     */
    refresh(conf: LoadConfigResult, fn?: (conf: LoadConfigResult) => void): _pandacss_types.DiffConfigResult;
}

interface OutputEngineOptions extends Generator {
    runtime: Runtime;
    hooks: Partial<PandaHooks>;
}
declare class OutputEngine {
    private paths;
    private fs;
    private path;
    constructor(options: OutputEngineOptions);
    empty: () => void;
    ensure: (file: string, cwd: string) => string;
    write: (output: Artifact | undefined) => Promise<PromiseSettledResult<void>[]> | undefined;
}

declare class PandaContext extends Generator {
    runtime: Runtime;
    project: Project;
    output: OutputEngine;
    diff: DiffEngine;
    explicitDeps: string[];
    constructor(conf: LoadConfigResult);
    private getExplicitDependencies;
    getFiles: () => string[];
    parseFile: (filePath: string, styleEncoder?: StyleEncoder) => ParserResult | undefined;
    parseFiles: (styleEncoder?: StyleEncoder) => {
        filesWithCss: string[];
        files: string[];
        results: ParserResult[];
    };
    writeCss: (sheet?: Stylesheet) => Promise<PromiseSettledResult<void>[]> | undefined;
    watchConfig: (cb: (file: string) => void | Promise<void>, opts?: Omit<WatchOptions, 'include'>) => void;
    watchFiles: (cb: (event: WatcherEventType, file: string) => void | Promise<void>, opts?: Omit<WatchOptions, 'include' | 'exclude' | 'poll' | 'cwd' | 'logger'>) => void;
}

interface Options {
    onResult?: (file: string, result: ParserResultInterface) => void;
}
declare function analyzeTokens(ctx: PandaContext, options?: Options): {
    duration: {
        extractTimeByFiles: {
            [k: string]: number;
        };
        extractTotal: number;
        classify: number;
    };
    fileSizes: {
        lineCount: number;
        normal: string;
        minified: string;
        gzip: {
            normal: string;
            minified: string;
        };
    };
} & {
    counts: {
        filesWithTokens: number;
        propNameUsed: number;
        tokenUsed: number;
        shorthandUsed: number;
        propertyPathUsed: number;
        typeUsed: number;
        instanceNameUsed: number;
        kindUsed: number;
        instanceOfKindUsed: number;
        colorsUsed: number;
    };
    stats: {
        filesWithMostInstance: {
            [k: string]: number;
        };
        filesWithMostPropValueCombinations: {
            [k: string]: number;
        };
        mostUseds: {
            propNames: {
                key: string;
                count: number;
            }[];
            tokens: {
                key: string;
                count: number;
            }[];
            shorthands: {
                key: string;
                count: number;
            }[];
            conditions: {
                key: string;
                count: number;
            }[];
            propertyPaths: {
                key: string;
                count: number;
            }[];
            categories: {
                key: string;
                count: number;
            }[];
            types: {
                key: string;
                count: number;
            }[];
            instanceNames: {
                key: string;
                count: number;
            }[];
            fromKinds: {
                key: string;
                count: number;
            }[];
            instanceOfKinds: {
                key: string;
                count: number;
            }[];
            colors: {
                key: string;
                count: number;
            }[];
        };
    };
    details: {
        byId: Map<number, _pandacss_types.ReportItem>;
        byInstanceId: Map<number, _pandacss_types.ReportInstanceItem>;
        byFilepath: Map<string, Set<number>>;
        byInstanceInFilepath: Map<string, Set<number>>;
        globalMaps: {
            byInstanceOfKind: Map<"function" | "component", Set<number>>;
            byPropertyName: Map<string, Set<number>>;
            byCategory: Map<string, Set<number>>;
            byConditionName: Map<string, Set<number>>;
            byShorthand: Map<string, Set<number>>;
            byTokenName: Map<string, Set<number>>;
            byPropertyPath: Map<string, Set<number>>;
            fromKind: Map<"function" | "component", Set<number>>;
            byType: Map<string, Set<number>>;
            byInstanceName: Map<string, Set<number>>;
            colorsUsed: Map<string, Set<number>>;
        };
        byFilePathMaps: Map<string, {
            byInstanceOfKind: Map<"function" | "component", Set<number>>;
            byPropertyName: Map<string, Set<number>>;
            byCategory: Map<string, Set<number>>;
            byConditionName: Map<string, Set<number>>;
            byShorthand: Map<string, Set<number>>;
            byTokenName: Map<string, Set<number>>;
            byPropertyPath: Map<string, Set<number>>;
            fromKind: Map<"function" | "component", Set<number>>;
            byType: Map<string, Set<number>>;
            byInstanceName: Map<string, Set<number>>;
            colorsUsed: Map<string, Set<number>>;
        }>;
    };
};
declare const writeAnalyzeJSON: (filePath: string, result: ReturnType<typeof analyzeTokens>, ctx: PandaContext) => Promise<void>;

declare function buildInfo(ctx: PandaContext, outfile: string): Promise<void>;

declare class Builder {
    /**
     * The current panda context
     */
    context: PandaContext | undefined;
    private hasEmitted;
    private filesMeta;
    private explicitDepsMeta;
    private affecteds;
    private configDependencies;
    setConfigDependencies(options: SetupContextOptions): void;
    setup: (options?: {
        configPath?: string;
        cwd?: string;
    }) => Promise<PandaContext | undefined>;
    emit(): Promise<void>;
    setupContext: (options: SetupContextOptions) => Promise<PandaContext>;
    getContextOrThrow: () => PandaContext;
    getFileMeta: (file: string) => {
        mtime: number;
        isUnchanged: boolean;
    };
    checkFilesChanged(files: string[]): {
        changes: Map<string, FileMeta>;
        hasFilesChanged: boolean;
    };
    extractFile: (ctx: PandaContext, file: string) => _pandacss_parser.ParserResult | undefined;
    extract: () => void;
    isValidRoot: (root: Root) => boolean;
    write: (root: Root) => void;
    registerDependency: (fn: (dep: Message) => void) => void;
}
interface FileMeta {
    mtime: number;
    isUnchanged: boolean;
}
interface SetupContextOptions {
    configPath: string;
    cwd?: string;
}

declare function codegen(ctx: PandaContext, ids?: ArtifactId[]): Promise<{
    box: string;
    msg: string;
}>;

declare function loadConfigAndCreateContext(options?: {
    cwd?: string;
    config?: Config;
    configPath?: string;
}): Promise<PandaContext>;

declare const startProfiling: (cwd: string, prefix: string, isWatching?: boolean) => Promise<(cb?: () => void) => void>;

interface CssGenOptions {
    cwd: string;
    outfile?: string;
    type?: CssArtifactType;
    minimal?: boolean;
}
declare const cssgen: (ctx: PandaContext, options: CssGenOptions) => Promise<void>;

interface DebugOptions {
    outdir: string;
    dry: boolean;
    onlyConfig?: boolean;
}
declare function debug(ctx: PandaContext, options: DebugOptions): Promise<void>;

declare function generate(config: Config, configPath?: string): Promise<void>;

declare function setupGitIgnore(ctx: PandaContext): void;

interface LogstreamOptions {
    cwd?: string;
    logfile?: string;
}
declare const setLogStream: (options: LogstreamOptions) => {
    end(): void;
    [Symbol.dispose]: () => void;
};

declare function parseDependency(fileOrGlob: string): Message | null;

type SetupOptions = Partial<Config> & {
    force?: boolean;
};
declare function setupConfig(cwd: string, opts?: SetupOptions): Promise<void>;
declare function setupPostcss(cwd: string): Promise<void>;

export { Builder, type CssGenOptions, PandaContext, analyzeTokens, buildInfo, codegen, cssgen, debug, generate, loadConfigAndCreateContext, parseDependency, setLogStream, setupConfig, setupGitIgnore, setupPostcss, startProfiling, writeAnalyzeJSON };
