import { W as WalkObjectStopFn, M as MappedObject, C as CreateCssContext } from './shared-5yRolXii.mjs';
export { x as WalkObjectOptions, f as compact, d as createCss, e as createMergeCss, h as filterBaseConditions, q as getPatternStyles, s as getSlotCompoundVariant, r as getSlotRecipes, j as hypenateProperty, g as isBaseCondition, a as isBoolean, b as isFunction, k as isImportant, c as isObject, i as isString, z as mapObject, m as markImportant, n as memo, o as mergeProps, p as patternFns, u as splitProps, t as toHash, v as uniq, y as walkObject, w as withoutImportant, l as withoutSpace } from './shared-5yRolXii.mjs';
export { astish } from './astish.mjs';

declare const getArbitraryValue: (_value: string) => string;

declare function assign(target: any, ...sources: any[]): any;

type Operand = string | number | {
    ref: string;
};
declare const calc: {
    negate(x: Operand): string;
};

declare const camelCaseProperty: (property: string) => string;

declare const capitalize: (s: string) => string;
declare const dashCase: (s: string) => string;
declare const uncapitalize: (s: string) => string;

interface CssVar {
    var: `--${string}`;
    ref: string;
}
interface CssVarOptions {
    fallback?: string;
    prefix?: string;
    hash?: boolean;
}
declare function cssVar(name: string, options?: CssVarOptions): CssVar;

type Dict = Record<string, any>;
declare const deepSet: <T extends Dict>(target: T, path: string[], value: Dict | string) => T;

declare function fromEntries<A extends symbol | string | number, B>(entries: [A, B][]): {
    [key in A]: B;
};
declare function entries<A extends symbol | string | number, B>(obj: {
    [key in A]: B;
}): [A, B][];
declare function mapEntries<A, B, K extends string | number | symbol>(obj: {
    [key in K]: A;
}, f: (key: K, val: A) => [K, B]): {
    [key in K]: B;
};

type PandaErrorCode = 'CONFIG_NOT_FOUND' | 'CONFIG_ERROR' | 'NOT_FOUND' | 'CONDITION' | 'MISSING_STUDIO' | 'INVALID_LAYER' | 'UNKNOWN_RECIPE' | 'INVALID_RECIPE' | 'UNKNOWN_TYPE' | 'MISSING_PARAMS' | 'NO_CONTEXT' | 'INVALID_TOKEN';
declare class PandaError extends Error {
    readonly code: string;
    readonly hint?: string;
    constructor(code: PandaErrorCode, message: string, opts?: {
        hint?: string;
    });
}

declare const esc: (sel: string) => string;

declare function flatten(values: Record<string, Record<string, any>>, stop?: WalkObjectStopFn): Record<string, any>;

declare function getOrCreateSet<TKey, TValue>(map: Map<TKey, Set<TValue>>, key: TKey): Set<TValue>;

declare const isCssFunction: (v: unknown) => boolean;

declare const isCssUnit: (v: unknown) => boolean;

declare const isCssVar: (v: unknown) => boolean;

declare function mergeWith(target: any, ...sources: any[]): any;

type NormalizeContext = Pick<CreateCssContext, 'utility' | 'conditions'>;
declare function toResponsiveObject(values: string[], breakpoints: string[]): Record<string, string>;
declare function normalizeStyleObject(styles: Record<string, any>, context: NormalizeContext, shorthand?: boolean): MappedObject<Record<string, any>, any>;

declare const omit: <T, K extends (string & {}) | keyof T>(obj: T, paths: K[]) => Omit<T, K>;

declare const createRegex: (item: Array<string | RegExp>) => RegExp;

declare const stringifyJson: (config: Record<string, any>) => string;
declare const parseJson: (config: string) => any;

/**
 * Get the property priority: the higher the priority, the higher the resulting
 * specificity of the atom. For example, if we had:
 *
 * ```tsx
 * import { css } from '@pandacss/dev';
 *
 * css({
 *   backgroundColor: 'blue',
 *   background: 'red',
 * })
 *
 * ```
 *
 * and so the more specific selector would win
 *
 * Taken from
 * @see https://github.com/callstack/linaria/blob/049a4ccb77e29f3628353352db21bd446fa04a2e/packages/atomic/src/processors/helpers/propertyPriority.ts
 */
declare function getPropertyPriority(property: string): 0 | 1 | 2;

declare function splitBy(value: string, separator?: string): any[];
declare function splitDotPath(path: string): string[];
declare function getNegativePath(path: string[]): string[];
declare function getDotPath(obj: any, path: string, fallback?: any): any;

type MapToRecord<K extends Map<string, any>> = {
    [P in keyof K]: K[P] extends Map<string, infer V> ? Record<string, V> : never;
};
declare function mapToJson<T extends Map<string, any>>(map: T): MapToRecord<T>;

type CallbackFn = (args: CallbackItem) => void;
interface CallbackItem {
    value: any;
    path: string;
    paths: string[];
    depth: number;
    parent: any[] | Record<string, unknown>;
    key: string;
}
declare const isObjectOrArray: (obj: unknown) => boolean;
interface TraverseOptions {
    separator?: string;
    maxDepth?: number;
    stop?: (args: CallbackItem) => boolean;
}
declare function traverse(obj: any, callback: CallbackFn, options?: TraverseOptions): void;

declare function unionType(values: IterableIterator<string> | string[] | readonly string[] | Set<string>): string;

declare function getUnit(value?: string): string | undefined;
declare function toPx(value?: string | number): string | undefined;
declare function toEm(value?: string, fontSize?: number): string | undefined;
declare function toRem(value?: string): string | undefined;

export { CreateCssContext, type CssVar, type CssVarOptions, type MapToRecord, MappedObject, PandaError, type PandaErrorCode, WalkObjectStopFn, assign, calc, camelCaseProperty, capitalize, createRegex, cssVar, dashCase, deepSet, entries, esc, flatten, fromEntries, getArbitraryValue, getDotPath, getNegativePath, getOrCreateSet, getPropertyPriority, getUnit, isCssFunction, isCssUnit, isCssVar, isObjectOrArray, mapEntries, mapToJson, mergeWith, normalizeStyleObject, omit, parseJson, splitBy, splitDotPath, stringifyJson, toEm, toPx, toRem, toResponsiveObject, traverse, uncapitalize, unionType };
