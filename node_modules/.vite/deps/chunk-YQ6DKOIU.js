import {
  AsyncDisposableStack,
  CDPSessionEvent,
  Deferred,
  DisposableStack,
  EMPTY,
  EventEmitter,
  NETWORK_IDLE_TIME,
  ProtocolError,
  PuppeteerURL,
  ReplaySubject,
  TargetCloseError,
  TimeoutError,
  UnsupportedOperation,
  assert,
  asyncDisposeSymbol,
  catchError,
  concat,
  debugError,
  defaultIfEmpty,
  defer,
  disposeSymbol,
  filter,
  filterAsync,
  first,
  firstValueFrom,
  from,
  fromEmitterEvent,
  fromEvent,
  getReadableAsBuffer,
  getReadableFromProtocolStream,
  guarded,
  identity,
  ignoreElements,
  importFSPromises,
  invokeAtMostOnceForArguments,
  isString,
  map,
  merge,
  mergeMap,
  mergeScan,
  moveable,
  noop,
  of,
  pipe,
  race,
  raceWith,
  retry,
  startWith,
  switchMap,
  take,
  takeUntil,
  tap,
  throwIfDisposed,
  throwIfEmpty,
  timeout,
  timer,
  withSourcePuppeteerURLIfNone
} from "./chunk-7JKSSJMR.js";
import {
  __privateAdd,
  __privateGet,
  __privateIn,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField
} from "./chunk-5EEVNGTZ.js";

// node_modules/puppeteer-core/lib/esm/puppeteer/api/Browser.js
var WEB_PERMISSION_TO_PROTOCOL_PERMISSION = /* @__PURE__ */ new Map([
  ["geolocation", "geolocation"],
  ["midi", "midi"],
  ["notifications", "notifications"],
  // TODO: push isn't a valid type?
  // ['push', 'push'],
  ["camera", "videoCapture"],
  ["microphone", "audioCapture"],
  ["background-sync", "backgroundSync"],
  ["ambient-light-sensor", "sensors"],
  ["accelerometer", "sensors"],
  ["gyroscope", "sensors"],
  ["magnetometer", "sensors"],
  ["accessibility-events", "accessibilityEvents"],
  ["clipboard-read", "clipboardReadWrite"],
  ["clipboard-write", "clipboardReadWrite"],
  ["clipboard-sanitized-write", "clipboardSanitizedWrite"],
  ["payment-handler", "paymentHandler"],
  ["persistent-storage", "durableStorage"],
  ["idle-detection", "idleDetection"],
  // chrome-specific permissions we have.
  ["midi-sysex", "midiSysex"]
]);
var Browser = class extends EventEmitter {
  /**
   * @internal
   */
  constructor() {
    super();
  }
  /**
   * Waits until a {@link Target | target} matching the given `predicate`
   * appears and returns it.
   *
   * This will look all open {@link BrowserContext | browser contexts}.
   *
   * @example Finding a target for a page opened via `window.open`:
   *
   * ```ts
   * await page.evaluate(() => window.open('https://www.example.com/'));
   * const newWindowTarget = await browser.waitForTarget(
   *   target => target.url() === 'https://www.example.com/'
   * );
   * ```
   */
  async waitForTarget(predicate, options = {}) {
    const { timeout: ms = 3e4 } = options;
    return await firstValueFrom(merge(fromEmitterEvent(
      this,
      "targetcreated"
      /* BrowserEvent.TargetCreated */
    ), fromEmitterEvent(
      this,
      "targetchanged"
      /* BrowserEvent.TargetChanged */
    ), from(this.targets())).pipe(filterAsync(predicate), raceWith(timeout(ms))));
  }
  /**
   * Gets a list of all open {@link Page | pages} inside this {@link Browser}.
   *
   * If there ar multiple {@link BrowserContext | browser contexts}, this
   * returns all {@link Page | pages} in all
   * {@link BrowserContext | browser contexts}.
   *
   * @remarks Non-visible {@link Page | pages}, such as `"background_page"`,
   * will not be listed here. You can find them using {@link Target.page}.
   */
  async pages() {
    const contextPages = await Promise.all(this.browserContexts().map((context) => {
      return context.pages();
    }));
    return contextPages.reduce((acc, x) => {
      return acc.concat(x);
    }, []);
  }
  /**
   * Whether Puppeteer is connected to this {@link Browser | browser}.
   *
   * @deprecated Use {@link Browser | Browser.connected}.
   */
  isConnected() {
    return this.connected;
  }
  /** @internal */
  [disposeSymbol]() {
    if (this.process()) {
      return void this.close().catch(debugError);
    }
    return void this.disconnect().catch(debugError);
  }
  /** @internal */
  [asyncDisposeSymbol]() {
    if (this.process()) {
      return this.close();
    }
    return this.disconnect();
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/api/BrowserContext.js
var BrowserContext = class extends EventEmitter {
  /**
   * @internal
   */
  constructor() {
    super();
  }
  /**
   * Waits until a {@link Target | target} matching the given `predicate`
   * appears and returns it.
   *
   * This will look all open {@link BrowserContext | browser contexts}.
   *
   * @example Finding a target for a page opened via `window.open`:
   *
   * ```ts
   * await page.evaluate(() => window.open('https://www.example.com/'));
   * const newWindowTarget = await browserContext.waitForTarget(
   *   target => target.url() === 'https://www.example.com/'
   * );
   * ```
   */
  async waitForTarget(predicate, options = {}) {
    const { timeout: ms = 3e4 } = options;
    return await firstValueFrom(merge(fromEmitterEvent(
      this,
      "targetcreated"
      /* BrowserContextEvent.TargetCreated */
    ), fromEmitterEvent(
      this,
      "targetchanged"
      /* BrowserContextEvent.TargetChanged */
    ), from(this.targets())).pipe(filterAsync(predicate), raceWith(timeout(ms))));
  }
  /**
   * Whether this {@link BrowserContext | browser context} is closed.
   */
  get closed() {
    return !this.browser().browserContexts().includes(this);
  }
  /**
   * Identifier for this {@link BrowserContext | browser context}.
   */
  get id() {
    return void 0;
  }
  /** @internal */
  [disposeSymbol]() {
    return void this.close().catch(debugError);
  }
  /** @internal */
  [asyncDisposeSymbol]() {
    return this.close();
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/api/Dialog.js
var _type, _message, _defaultValue, _handled;
var Dialog = class {
  /**
   * @internal
   */
  constructor(type, message, defaultValue = "") {
    __privateAdd(this, _type, void 0);
    __privateAdd(this, _message, void 0);
    __privateAdd(this, _defaultValue, void 0);
    __privateAdd(this, _handled, false);
    __privateSet(this, _type, type);
    __privateSet(this, _message, message);
    __privateSet(this, _defaultValue, defaultValue);
  }
  /**
   * The type of the dialog.
   */
  type() {
    return __privateGet(this, _type);
  }
  /**
   * The message displayed in the dialog.
   */
  message() {
    return __privateGet(this, _message);
  }
  /**
   * The default value of the prompt, or an empty string if the dialog
   * is not a `prompt`.
   */
  defaultValue() {
    return __privateGet(this, _defaultValue);
  }
  /**
   * A promise that resolves when the dialog has been accepted.
   *
   * @param promptText - optional text that will be entered in the dialog
   * prompt. Has no effect if the dialog's type is not `prompt`.
   *
   */
  async accept(promptText) {
    assert(!__privateGet(this, _handled), "Cannot accept dialog which is already handled!");
    __privateSet(this, _handled, true);
    await this.handle({
      accept: true,
      text: promptText
    });
  }
  /**
   * A promise which will resolve once the dialog has been dismissed
   */
  async dismiss() {
    assert(!__privateGet(this, _handled), "Cannot dismiss dialog which is already handled!");
    __privateSet(this, _handled, true);
    await this.handle({
      accept: false
    });
  }
};
_type = new WeakMap();
_message = new WeakMap();
_defaultValue = new WeakMap();
_handled = new WeakMap();

// node_modules/puppeteer-core/lib/esm/puppeteer/util/ErrorLike.js
function isErrorLike(obj) {
  return typeof obj === "object" && obj !== null && "name" in obj && "message" in obj;
}
function isErrnoException(obj) {
  return isErrorLike(obj) && ("errno" in obj || "code" in obj || "path" in obj || "syscall" in obj);
}
function rewriteError(error, message, originalMessage) {
  error.message = message;
  error.originalMessage = originalMessage ?? error.originalMessage;
  return error;
}
function createProtocolErrorMessage(object) {
  let message = object.error.message;
  if (object.error && typeof object.error === "object" && "data" in object.error) {
    message += ` ${object.error.data}`;
  }
  return message;
}

// node_modules/puppeteer-core/lib/esm/puppeteer/common/HandleIterator.js
var __addDisposableResource = function(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources = /* @__PURE__ */ function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    function next() {
      while (env.stack.length) {
        var rec = env.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
        } catch (e) {
          fail(e);
        }
      }
      if (env.hasError)
        throw env.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var DEFAULT_BATCH_SIZE = 20;
async function* fastTransposeIteratorHandle(iterator, size) {
  const env_1 = { stack: [], error: void 0, hasError: false };
  try {
    const array = __addDisposableResource(env_1, await iterator.evaluateHandle(async (iterator2, size2) => {
      const results = [];
      while (results.length < size2) {
        const result = await iterator2.next();
        if (result.done) {
          break;
        }
        results.push(result.value);
      }
      return results;
    }, size), false);
    const properties = await array.getProperties();
    const handles = properties.values();
    const stack = __addDisposableResource(env_1, new DisposableStack(), false);
    stack.defer(() => {
      for (const handle_1 of handles) {
        const env_2 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource(env_2, handle_1, false);
          handle[disposeSymbol]();
        } catch (e_2) {
          env_2.error = e_2;
          env_2.hasError = true;
        } finally {
          __disposeResources(env_2);
        }
      }
    });
    yield* handles;
    return properties.size === 0;
  } catch (e_1) {
    env_1.error = e_1;
    env_1.hasError = true;
  } finally {
    __disposeResources(env_1);
  }
}
async function* transposeIteratorHandle(iterator) {
  let size = DEFAULT_BATCH_SIZE;
  while (!(yield* fastTransposeIteratorHandle(iterator, size))) {
    size <<= 1;
  }
}
async function* transposeIterableHandle(handle) {
  const env_3 = { stack: [], error: void 0, hasError: false };
  try {
    const generatorHandle = __addDisposableResource(env_3, await handle.evaluateHandle((iterable) => {
      return async function* () {
        yield* iterable;
      }();
    }), false);
    yield* transposeIteratorHandle(generatorHandle);
  } catch (e_3) {
    env_3.error = e_3;
    env_3.hasError = true;
  } finally {
    __disposeResources(env_3);
  }
}

// node_modules/puppeteer-core/lib/esm/puppeteer/common/LazyArg.js
var _get;
var _LazyArg = class _LazyArg {
  constructor(get) {
    __privateAdd(this, _get, void 0);
    __privateSet(this, _get, get);
  }
  async get(context) {
    return await __privateGet(this, _get).call(this, context);
  }
};
_get = new WeakMap();
__publicField(_LazyArg, "create", (get) => {
  return new _LazyArg(get);
});
var LazyArg = _LazyArg;

// node_modules/puppeteer-core/lib/esm/puppeteer/api/ElementHandleSymbol.js
var _isElementHandle = Symbol("_isElementHandle");

// node_modules/puppeteer-core/lib/esm/puppeteer/util/Function.js
var createdFunctions = /* @__PURE__ */ new Map();
var createFunction = (functionValue) => {
  let fn = createdFunctions.get(functionValue);
  if (fn) {
    return fn;
  }
  fn = new Function(`return ${functionValue}`)();
  createdFunctions.set(functionValue, fn);
  return fn;
};
function stringifyFunction(fn) {
  let value = fn.toString();
  try {
    new Function(`(${value})`);
  } catch (err) {
    if (err.message.includes(`Refused to evaluate a string as JavaScript because 'unsafe-eval' is not an allowed source of script in the following Content Security Policy directive`)) {
      return value;
    }
    let prefix = "function ";
    if (value.startsWith("async ")) {
      prefix = `async ${prefix}`;
      value = value.substring("async ".length);
    }
    value = `${prefix}${value}`;
    try {
      new Function(`(${value})`);
    } catch {
      throw new Error("Passed function cannot be serialized!");
    }
  }
  return value;
}
var interpolateFunction = (fn, replacements) => {
  let value = stringifyFunction(fn);
  for (const [name, jsValue] of Object.entries(replacements)) {
    value = value.replace(
      new RegExp(`PLACEHOLDER\\(\\s*(?:'${name}'|"${name}")\\s*\\)`, "g"),
      // Wrapping this ensures tersers that accidentally inline PLACEHOLDER calls
      // are still valid. Without, we may get calls like ()=>{...}() which is
      // not valid.
      `(${jsValue})`
    );
  }
  return createFunction(value);
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/QueryHandler.js
var __addDisposableResource2 = function(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources2 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    function next() {
      while (env.stack.length) {
        var rec = env.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
        } catch (e) {
          fail(e);
        }
      }
      if (env.hasError)
        throw env.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var QueryHandler = class {
  static get _querySelector() {
    if (this.querySelector) {
      return this.querySelector;
    }
    if (!this.querySelectorAll) {
      throw new Error("Cannot create default `querySelector`.");
    }
    return this.querySelector = interpolateFunction(async (node, selector, PuppeteerUtil) => {
      const querySelectorAll = PLACEHOLDER("querySelectorAll");
      const results = querySelectorAll(node, selector, PuppeteerUtil);
      for await (const result of results) {
        return result;
      }
      return null;
    }, {
      querySelectorAll: stringifyFunction(this.querySelectorAll)
    });
  }
  static get _querySelectorAll() {
    if (this.querySelectorAll) {
      return this.querySelectorAll;
    }
    if (!this.querySelector) {
      throw new Error("Cannot create default `querySelectorAll`.");
    }
    return this.querySelectorAll = interpolateFunction(async function* (node, selector, PuppeteerUtil) {
      const querySelector = PLACEHOLDER("querySelector");
      const result = await querySelector(node, selector, PuppeteerUtil);
      if (result) {
        yield result;
      }
    }, {
      querySelector: stringifyFunction(this.querySelector)
    });
  }
  /**
   * Queries for multiple nodes given a selector and {@link ElementHandle}.
   *
   * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll | Document.querySelectorAll()}.
   */
  static async *queryAll(element, selector) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      const handle = __addDisposableResource2(env_1, await element.evaluateHandle(this._querySelectorAll, selector, LazyArg.create((context) => {
        return context.puppeteerUtil;
      })), false);
      yield* transposeIterableHandle(handle);
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources2(env_1);
    }
  }
  /**
   * Queries for a single node given a selector and {@link ElementHandle}.
   *
   * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector}.
   */
  static async queryOne(element, selector) {
    const env_2 = { stack: [], error: void 0, hasError: false };
    try {
      const result = __addDisposableResource2(env_2, await element.evaluateHandle(this._querySelector, selector, LazyArg.create((context) => {
        return context.puppeteerUtil;
      })), false);
      if (!(_isElementHandle in result)) {
        return null;
      }
      return result.move();
    } catch (e_2) {
      env_2.error = e_2;
      env_2.hasError = true;
    } finally {
      __disposeResources2(env_2);
    }
  }
  /**
   * Waits until a single node appears for a given selector and
   * {@link ElementHandle}.
   *
   * This will always query the handle in the Puppeteer world and migrate the
   * result to the main world.
   */
  static async waitFor(elementOrFrame, selector, options) {
    const env_3 = { stack: [], error: void 0, hasError: false };
    try {
      let frame;
      const element = __addDisposableResource2(env_3, await (async () => {
        if (!(_isElementHandle in elementOrFrame)) {
          frame = elementOrFrame;
          return;
        }
        frame = elementOrFrame.frame;
        return await frame.isolatedRealm().adoptHandle(elementOrFrame);
      })(), false);
      const { visible = false, hidden = false, timeout: timeout2, signal } = options;
      try {
        const env_4 = { stack: [], error: void 0, hasError: false };
        try {
          signal == null ? void 0 : signal.throwIfAborted();
          const handle = __addDisposableResource2(env_4, await frame.isolatedRealm().waitForFunction(async (PuppeteerUtil, query, selector2, root, visible2) => {
            const querySelector = PuppeteerUtil.createFunction(query);
            const node = await querySelector(root ?? document, selector2, PuppeteerUtil);
            return PuppeteerUtil.checkVisibility(node, visible2);
          }, {
            polling: visible || hidden ? "raf" : "mutation",
            root: element,
            timeout: timeout2,
            signal
          }, LazyArg.create((context) => {
            return context.puppeteerUtil;
          }), stringifyFunction(this._querySelector), selector, element, visible ? true : hidden ? false : void 0), false);
          if (signal == null ? void 0 : signal.aborted) {
            throw signal.reason;
          }
          if (!(_isElementHandle in handle)) {
            return null;
          }
          return await frame.mainRealm().transferHandle(handle);
        } catch (e_3) {
          env_4.error = e_3;
          env_4.hasError = true;
        } finally {
          __disposeResources2(env_4);
        }
      } catch (error) {
        if (!isErrorLike(error)) {
          throw error;
        }
        if (error.name === "AbortError") {
          throw error;
        }
        error.message = `Waiting for selector \`${selector}\` failed: ${error.message}`;
        throw error;
      }
    } catch (e_4) {
      env_3.error = e_4;
      env_3.hasError = true;
    } finally {
      __disposeResources2(env_3);
    }
  }
};
// Either one of these may be implemented, but at least one must be.
__publicField(QueryHandler, "querySelectorAll");
__publicField(QueryHandler, "querySelector");

// node_modules/puppeteer-core/lib/esm/puppeteer/util/AsyncIterableUtil.js
var AsyncIterableUtil = class {
  static async *map(iterable, map2) {
    for await (const value of iterable) {
      yield await map2(value);
    }
  }
  static async *flatMap(iterable, map2) {
    for await (const value of iterable) {
      yield* map2(value);
    }
  }
  static async collect(iterable) {
    const result = [];
    for await (const value of iterable) {
      result.push(value);
    }
    return result;
  }
  static async first(iterable) {
    for await (const value of iterable) {
      return value;
    }
    return;
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/AriaQueryHandler.js
var isKnownAttribute = (attribute) => {
  return ["name", "role"].includes(attribute);
};
var normalizeValue = (value) => {
  return value.replace(/ +/g, " ").trim();
};
var ATTRIBUTE_REGEXP = /\[\s*(?<attribute>\w+)\s*=\s*(?<quote>"|')(?<value>\\.|.*?(?=\k<quote>))\k<quote>\s*\]/g;
var parseARIASelector = (selector) => {
  const queryOptions = {};
  const defaultName = selector.replace(ATTRIBUTE_REGEXP, (_, attribute, __, value) => {
    attribute = attribute.trim();
    assert(isKnownAttribute(attribute), `Unknown aria attribute "${attribute}" in selector`);
    queryOptions[attribute] = normalizeValue(value);
    return "";
  });
  if (defaultName && !queryOptions.name) {
    queryOptions.name = normalizeValue(defaultName);
  }
  return queryOptions;
};
var _ARIAQueryHandler = class _ARIAQueryHandler extends QueryHandler {
  static async *queryAll(element, selector) {
    const { name, role } = parseARIASelector(selector);
    yield* element.queryAXTree(name, role);
  }
};
__publicField(_ARIAQueryHandler, "querySelector", async (node, selector, { ariaQuerySelector }) => {
  return await ariaQuerySelector(node, selector);
});
__publicField(_ARIAQueryHandler, "queryOne", async (element, selector) => {
  return await AsyncIterableUtil.first(_ARIAQueryHandler.queryAll(element, selector)) ?? null;
});
var ARIAQueryHandler = _ARIAQueryHandler;

// node_modules/puppeteer-core/lib/esm/puppeteer/generated/injected.js
var source = '"use strict";var A=Object.defineProperty;var re=Object.getOwnPropertyDescriptor;var ne=Object.getOwnPropertyNames;var oe=Object.prototype.hasOwnProperty;var u=(t,e)=>{for(var n in e)A(t,n,{get:e[n],enumerable:!0})},se=(t,e,n,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of ne(e))!oe.call(t,o)&&o!==n&&A(t,o,{get:()=>e[o],enumerable:!(r=re(e,o))||r.enumerable});return t};var ie=t=>se(A({},"__esModule",{value:!0}),t);var Re={};u(Re,{default:()=>ke});module.exports=ie(Re);var C=class extends Error{constructor(e,n){super(e,n),this.name=this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}},b=class extends C{};var f=class t{static create(e){return new t(e)}static async race(e){let n=new Set;try{let r=e.map(o=>o instanceof t?(o.#s&&n.add(o),o.valueOrThrow()):o);return await Promise.race(r)}finally{for(let r of n)r.reject(new Error("Timeout cleared"))}}#e=!1;#r=!1;#n;#t;#o=new Promise(e=>{this.#t=e});#s;#l;constructor(e){e&&e.timeout>0&&(this.#l=new b(e.message),this.#s=setTimeout(()=>{this.reject(this.#l)},e.timeout))}#a(e){clearTimeout(this.#s),this.#n=e,this.#t()}resolve(e){this.#r||this.#e||(this.#e=!0,this.#a(e))}reject(e){this.#r||this.#e||(this.#r=!0,this.#a(e))}resolved(){return this.#e}finished(){return this.#e||this.#r}value(){return this.#n}#i;valueOrThrow(){return this.#i||(this.#i=(async()=>{if(await this.#o,this.#r)throw this.#n;return this.#n})()),this.#i}};var X=new Map,z=t=>{let e=X.get(t);return e||(e=new Function(`return ${t}`)(),X.set(t,e),e)};var k={};u(k,{ariaQuerySelector:()=>le,ariaQuerySelectorAll:()=>I});var le=(t,e)=>globalThis.__ariaQuerySelector(t,e),I=async function*(t,e){yield*await globalThis.__ariaQuerySelectorAll(t,e)};var M={};u(M,{customQuerySelectors:()=>O});var R=class{#e=new Map;register(e,n){if(!n.queryOne&&n.queryAll){let r=n.queryAll;n.queryOne=(o,i)=>{for(let s of r(o,i))return s;return null}}else if(n.queryOne&&!n.queryAll){let r=n.queryOne;n.queryAll=(o,i)=>{let s=r(o,i);return s?[s]:[]}}else if(!n.queryOne||!n.queryAll)throw new Error("At least one query method must be defined.");this.#e.set(e,{querySelector:n.queryOne,querySelectorAll:n.queryAll})}unregister(e){this.#e.delete(e)}get(e){return this.#e.get(e)}clear(){this.#e.clear()}},O=new R;var q={};u(q,{pierceQuerySelector:()=>ae,pierceQuerySelectorAll:()=>ce});var ae=(t,e)=>{let n=null,r=o=>{let i=document.createTreeWalker(o,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&r(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==o&&!n&&s.matches(e)&&(n=s)}while(!n&&i.nextNode())};return t instanceof Document&&(t=t.documentElement),r(t),n},ce=(t,e)=>{let n=[],r=o=>{let i=document.createTreeWalker(o,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&r(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==o&&s.matches(e)&&n.push(s)}while(i.nextNode())};return t instanceof Document&&(t=t.documentElement),r(t),n};var m=(t,e)=>{if(!t)throw new Error(e)};var T=class{#e;#r;#n;#t;constructor(e,n){this.#e=e,this.#r=n}async start(){let e=this.#t=f.create(),n=await this.#e();if(n){e.resolve(n);return}this.#n=new MutationObserver(async()=>{let r=await this.#e();r&&(e.resolve(r),await this.stop())}),this.#n.observe(this.#r,{childList:!0,subtree:!0,attributes:!0})}async stop(){m(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped")),this.#n&&(this.#n.disconnect(),this.#n=void 0)}result(){return m(this.#t,"Polling never started."),this.#t.valueOrThrow()}},E=class{#e;#r;constructor(e){this.#e=e}async start(){let e=this.#r=f.create(),n=await this.#e();if(n){e.resolve(n);return}let r=async()=>{if(e.finished())return;let o=await this.#e();if(!o){window.requestAnimationFrame(r);return}e.resolve(o),await this.stop()};window.requestAnimationFrame(r)}async stop(){m(this.#r,"Polling never started."),this.#r.finished()||this.#r.reject(new Error("Polling stopped"))}result(){return m(this.#r,"Polling never started."),this.#r.valueOrThrow()}},P=class{#e;#r;#n;#t;constructor(e,n){this.#e=e,this.#r=n}async start(){let e=this.#t=f.create(),n=await this.#e();if(n){e.resolve(n);return}this.#n=setInterval(async()=>{let r=await this.#e();r&&(e.resolve(r),await this.stop())},this.#r)}async stop(){m(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped")),this.#n&&(clearInterval(this.#n),this.#n=void 0)}result(){return m(this.#t,"Polling never started."),this.#t.valueOrThrow()}};var F={};u(F,{pQuerySelector:()=>Ce,pQuerySelectorAll:()=>te});var c=class{static async*map(e,n){for await(let r of e)yield await n(r)}static async*flatMap(e,n){for await(let r of e)yield*n(r)}static async collect(e){let n=[];for await(let r of e)n.push(r);return n}static async first(e){for await(let n of e)return n}};var p={attribute:/\\[\\s*(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?(?<name>[-\\w\\P{ASCII}]+)\\s*(?:(?<operator>\\W?=)\\s*(?<value>.+?)\\s*(\\s(?<caseSensitive>[iIsS]))?\\s*)?\\]/gu,id:/#(?<name>[-\\w\\P{ASCII}]+)/gu,class:/\\.(?<name>[-\\w\\P{ASCII}]+)/gu,comma:/\\s*,\\s*/g,combinator:/\\s*[\\s>+~]\\s*/g,"pseudo-element":/::(?<name>[-\\w\\P{ASCII}]+)(?:\\((?<argument>¶*)\\))?/gu,"pseudo-class":/:(?<name>[-\\w\\P{ASCII}]+)(?:\\((?<argument>¶*)\\))?/gu,universal:/(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?\\*/gu,type:/(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?(?<name>[-\\w\\P{ASCII}]+)/gu},ue=new Set(["combinator","comma"]);var fe=t=>{switch(t){case"pseudo-element":case"pseudo-class":return new RegExp(p[t].source.replace("(?<argument>\\xB6*)","(?<argument>.*)"),"gu");default:return p[t]}};function de(t,e){let n=0,r="";for(;e<t.length;e++){let o=t[e];switch(o){case"(":++n;break;case")":--n;break}if(r+=o,n===0)return r}return r}function me(t,e=p){if(!t)return[];let n=[t];for(let[o,i]of Object.entries(e))for(let s=0;s<n.length;s++){let l=n[s];if(typeof l!="string")continue;i.lastIndex=0;let a=i.exec(l);if(!a)continue;let h=a.index-1,d=[],V=a[0],H=l.slice(0,h+1);H&&d.push(H),d.push({...a.groups,type:o,content:V});let B=l.slice(h+V.length+1);B&&d.push(B),n.splice(s,1,...d)}let r=0;for(let o of n)switch(typeof o){case"string":throw new Error(`Unexpected sequence ${o} found at index ${r}`);case"object":r+=o.content.length,o.pos=[r-o.content.length,r],ue.has(o.type)&&(o.content=o.content.trim()||" ");break}return n}var he=/([\'"])([^\\\\\\n]+?)\\1/g,pe=/\\\\./g;function G(t,e=p){if(t=t.trim(),t==="")return[];let n=[];t=t.replace(pe,(i,s)=>(n.push({value:i,offset:s}),"\\uE000".repeat(i.length))),t=t.replace(he,(i,s,l,a)=>(n.push({value:i,offset:a}),`${s}${"\\uE001".repeat(l.length)}${s}`));{let i=0,s;for(;(s=t.indexOf("(",i))>-1;){let l=de(t,s);n.push({value:l,offset:s}),t=`${t.substring(0,s)}(${"\\xB6".repeat(l.length-2)})${t.substring(s+l.length)}`,i=s+l.length}}let r=me(t,e),o=new Set;for(let i of n.reverse())for(let s of r){let{offset:l,value:a}=i;if(!(s.pos[0]<=l&&l+a.length<=s.pos[1]))continue;let{content:h}=s,d=l-s.pos[0];s.content=h.slice(0,d)+a+h.slice(d+a.length),s.content!==h&&o.add(s)}for(let i of o){let s=fe(i.type);if(!s)throw new Error(`Unknown token type: ${i.type}`);s.lastIndex=0;let l=s.exec(i.content);if(!l)throw new Error(`Unable to parse content for ${i.type}: ${i.content}`);Object.assign(i,l.groups)}return r}function*x(t,e){switch(t.type){case"list":for(let n of t.list)yield*x(n,t);break;case"complex":yield*x(t.left,t),yield*x(t.right,t);break;case"compound":yield*t.list.map(n=>[n,t]);break;default:yield[t,e]}}function y(t){let e;return Array.isArray(t)?e=t:e=[...x(t)].map(([n])=>n),e.map(n=>n.content).join("")}p.combinator=/\\s*(>>>>?|[\\s>+~])\\s*/g;var ye=/\\\\[\\s\\S]/g,ge=t=>t.length<=1?t:((t[0]===\'"\'||t[0]==="\'")&&t.endsWith(t[0])&&(t=t.slice(1,-1)),t.replace(ye,e=>e[1]));function K(t){let e=!0,n=G(t);if(n.length===0)return[[],e];let r=[],o=[r],i=[o],s=[];for(let l of n){switch(l.type){case"combinator":switch(l.content){case">>>":e=!1,s.length&&(r.push(y(s)),s.splice(0)),r=[],o.push(">>>"),o.push(r);continue;case">>>>":e=!1,s.length&&(r.push(y(s)),s.splice(0)),r=[],o.push(">>>>"),o.push(r);continue}break;case"pseudo-element":if(!l.name.startsWith("-p-"))break;e=!1,s.length&&(r.push(y(s)),s.splice(0)),r.push({name:l.name.slice(3),value:ge(l.argument??"")});continue;case"comma":s.length&&(r.push(y(s)),s.splice(0)),r=[],o=[r],i.push(o);continue}s.push(l)}return s.length&&r.push(y(s)),[i,e]}var _={};u(_,{textQuerySelectorAll:()=>S});var we=new Set(["checkbox","image","radio"]),Se=t=>t instanceof HTMLSelectElement||t instanceof HTMLTextAreaElement||t instanceof HTMLInputElement&&!we.has(t.type),be=new Set(["SCRIPT","STYLE"]),w=t=>!be.has(t.nodeName)&&!document.head?.contains(t),D=new WeakMap,J=t=>{for(;t;)D.delete(t),t instanceof ShadowRoot?t=t.host:t=t.parentNode},Y=new WeakSet,Te=new MutationObserver(t=>{for(let e of t)J(e.target)}),g=t=>{let e=D.get(t);if(e||(e={full:"",immediate:[]},!w(t)))return e;let n="";if(Se(t))e.full=t.value,e.immediate.push(t.value),t.addEventListener("input",r=>{J(r.target)},{once:!0,capture:!0});else{for(let r=t.firstChild;r;r=r.nextSibling){if(r.nodeType===Node.TEXT_NODE){e.full+=r.nodeValue??"",n+=r.nodeValue??"";continue}n&&e.immediate.push(n),n="",r.nodeType===Node.ELEMENT_NODE&&(e.full+=g(r).full)}n&&e.immediate.push(n),t instanceof Element&&t.shadowRoot&&(e.full+=g(t.shadowRoot).full),Y.has(t)||(Te.observe(t,{childList:!0,characterData:!0,subtree:!0}),Y.add(t))}return D.set(t,e),e};var S=function*(t,e){let n=!1;for(let r of t.childNodes)if(r instanceof Element&&w(r)){let o;r.shadowRoot?o=S(r.shadowRoot,e):o=S(r,e);for(let i of o)yield i,n=!0}n||t instanceof Element&&w(t)&&g(t).full.includes(e)&&(yield t)};var L={};u(L,{checkVisibility:()=>Pe,pierce:()=>N,pierceAll:()=>Q});var Ee=["hidden","collapse"],Pe=(t,e)=>{if(!t)return e===!1;if(e===void 0)return t;let n=t.nodeType===Node.TEXT_NODE?t.parentElement:t,r=window.getComputedStyle(n),o=r&&!Ee.includes(r.visibility)&&!xe(n);return e===o?t:!1};function xe(t){let e=t.getBoundingClientRect();return e.width===0||e.height===0}var Ne=t=>"shadowRoot"in t&&t.shadowRoot instanceof ShadowRoot;function*N(t){Ne(t)?yield t.shadowRoot:yield t}function*Q(t){t=N(t).next().value,yield t;let e=[document.createTreeWalker(t,NodeFilter.SHOW_ELEMENT)];for(let n of e){let r;for(;r=n.nextNode();)r.shadowRoot&&(yield r.shadowRoot,e.push(document.createTreeWalker(r.shadowRoot,NodeFilter.SHOW_ELEMENT)))}}var j={};u(j,{xpathQuerySelectorAll:()=>$});var $=function*(t,e,n=-1){let o=(t.ownerDocument||document).evaluate(e,t,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE),i=[],s;for(;(s=o.iterateNext())&&(i.push(s),!(n&&i.length===n)););for(let l=0;l<i.length;l++)s=i[l],yield s,delete i[l]};var ve=/[-\\w\\P{ASCII}*]/,Z=t=>"querySelectorAll"in t,v=class extends Error{constructor(e,n){super(`${e} is not a valid selector: ${n}`)}},U=class{#e;#r;#n=[];#t=void 0;elements;constructor(e,n,r){this.elements=[e],this.#e=n,this.#r=r,this.#o()}async run(){if(typeof this.#t=="string")switch(this.#t.trimStart()){case":scope":this.#o();break}for(;this.#t!==void 0;this.#o()){let e=this.#t,n=this.#e;typeof e=="string"?e[0]&&ve.test(e[0])?this.elements=c.flatMap(this.elements,async function*(r){Z(r)&&(yield*r.querySelectorAll(e))}):this.elements=c.flatMap(this.elements,async function*(r){if(!r.parentElement){if(!Z(r))return;yield*r.querySelectorAll(e);return}let o=0;for(let i of r.parentElement.children)if(++o,i===r)break;yield*r.parentElement.querySelectorAll(`:scope>:nth-child(${o})${e}`)}):this.elements=c.flatMap(this.elements,async function*(r){switch(e.name){case"text":yield*S(r,e.value);break;case"xpath":yield*$(r,e.value);break;case"aria":yield*I(r,e.value);break;default:let o=O.get(e.name);if(!o)throw new v(n,`Unknown selector type: ${e.name}`);yield*o.querySelectorAll(r,e.value)}})}}#o(){if(this.#n.length!==0){this.#t=this.#n.shift();return}if(this.#r.length===0){this.#t=void 0;return}let e=this.#r.shift();switch(e){case">>>>":{this.elements=c.flatMap(this.elements,N),this.#o();break}case">>>":{this.elements=c.flatMap(this.elements,Q),this.#o();break}default:this.#n=e,this.#o();break}}},W=class{#e=new WeakMap;calculate(e,n=[]){if(e===null)return n;e instanceof ShadowRoot&&(e=e.host);let r=this.#e.get(e);if(r)return[...r,...n];let o=0;for(let s=e.previousSibling;s;s=s.previousSibling)++o;let i=this.calculate(e.parentNode,[o]);return this.#e.set(e,i),[...i,...n]}},ee=(t,e)=>{if(t.length+e.length===0)return 0;let[n=-1,...r]=t,[o=-1,...i]=e;return n===o?ee(r,i):n<o?-1:1},Ae=async function*(t){let e=new Set;for await(let r of t)e.add(r);let n=new W;yield*[...e.values()].map(r=>[r,n.calculate(r)]).sort(([,r],[,o])=>ee(r,o)).map(([r])=>r)},te=function(t,e){let n,r;try{[n,r]=K(e)}catch{return t.querySelectorAll(e)}if(r)return t.querySelectorAll(e);if(n.some(o=>{let i=0;return o.some(s=>(typeof s=="string"?++i:i=0,i>1))}))throw new v(e,"Multiple deep combinators found in sequence.");return Ae(c.flatMap(n,o=>{let i=new U(t,e,o);return i.run(),i.elements}))},Ce=async function(t,e){for await(let n of te(t,e))return n;return null};var Ie=Object.freeze({...k,...M,...q,...F,..._,...L,...j,Deferred:f,createFunction:z,createTextContent:g,IntervalPoller:P,isSuitableNodeForTextMatching:w,MutationPoller:T,RAFPoller:E}),ke=Ie;\n/**\n * @license\n * Copyright 2018 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @license\n * Copyright 2024 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @license\n * Copyright 2022 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @license\n * Copyright 2020 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n';

// node_modules/puppeteer-core/lib/esm/puppeteer/common/ScriptInjector.js
var _updated, _amendments, _update, update_fn, _get2, get_fn;
var ScriptInjector = class {
  constructor() {
    __privateAdd(this, _update);
    __privateAdd(this, _get2);
    __privateAdd(this, _updated, false);
    __privateAdd(this, _amendments, /* @__PURE__ */ new Set());
  }
  // Appends a statement of the form `(PuppeteerUtil) => {...}`.
  append(statement) {
    __privateMethod(this, _update, update_fn).call(this, () => {
      __privateGet(this, _amendments).add(statement);
    });
  }
  pop(statement) {
    __privateMethod(this, _update, update_fn).call(this, () => {
      __privateGet(this, _amendments).delete(statement);
    });
  }
  inject(inject, force = false) {
    if (__privateGet(this, _updated) || force) {
      inject(__privateMethod(this, _get2, get_fn).call(this));
    }
    __privateSet(this, _updated, false);
  }
};
_updated = new WeakMap();
_amendments = new WeakMap();
_update = new WeakSet();
update_fn = function(callback) {
  callback();
  __privateSet(this, _updated, true);
};
_get2 = new WeakSet();
get_fn = function() {
  return `(() => {
      const module = {};
      ${source}
      ${[...__privateGet(this, _amendments)].map((statement) => {
    return `(${statement})(module.exports.default);`;
  }).join("")}
      return module.exports.default;
    })()`;
};
var scriptInjector = new ScriptInjector();

// node_modules/puppeteer-core/lib/esm/puppeteer/common/CustomQueryHandler.js
var _handlers;
var CustomQueryHandlerRegistry = class {
  constructor() {
    __privateAdd(this, _handlers, /* @__PURE__ */ new Map());
  }
  get(name) {
    const handler = __privateGet(this, _handlers).get(name);
    return handler ? handler[1] : void 0;
  }
  /**
   * Registers a {@link CustomQueryHandler | custom query handler}.
   *
   * @remarks
   * After registration, the handler can be used everywhere where a selector is
   * expected by prepending the selection string with `<name>/`. The name is
   * only allowed to consist of lower- and upper case latin letters.
   *
   * @example
   *
   * ```ts
   * Puppeteer.customQueryHandlers.register('lit', { … });
   * const aHandle = await page.$('lit/…');
   * ```
   *
   * @param name - Name to register under.
   * @param queryHandler - {@link CustomQueryHandler | Custom query handler} to
   * register.
   */
  register(name, handler) {
    var _a;
    assert(!__privateGet(this, _handlers).has(name), `Cannot register over existing handler: ${name}`);
    assert(/^[a-zA-Z]+$/.test(name), `Custom query handler names may only contain [a-zA-Z]`);
    assert(handler.queryAll || handler.queryOne, `At least one query method must be implemented.`);
    const Handler = (_a = class extends QueryHandler {
    }, __publicField(_a, "querySelectorAll", interpolateFunction((node, selector, PuppeteerUtil) => {
      return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER("name")).querySelectorAll(node, selector);
    }, { name: JSON.stringify(name) })), __publicField(_a, "querySelector", interpolateFunction((node, selector, PuppeteerUtil) => {
      return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER("name")).querySelector(node, selector);
    }, { name: JSON.stringify(name) })), _a);
    const registerScript = interpolateFunction((PuppeteerUtil) => {
      PuppeteerUtil.customQuerySelectors.register(PLACEHOLDER("name"), {
        queryAll: PLACEHOLDER("queryAll"),
        queryOne: PLACEHOLDER("queryOne")
      });
    }, {
      name: JSON.stringify(name),
      queryAll: handler.queryAll ? stringifyFunction(handler.queryAll) : String(void 0),
      queryOne: handler.queryOne ? stringifyFunction(handler.queryOne) : String(void 0)
    }).toString();
    __privateGet(this, _handlers).set(name, [registerScript, Handler]);
    scriptInjector.append(registerScript);
  }
  /**
   * Unregisters the {@link CustomQueryHandler | custom query handler} for the
   * given name.
   *
   * @throws `Error` if there is no handler under the given name.
   */
  unregister(name) {
    const handler = __privateGet(this, _handlers).get(name);
    if (!handler) {
      throw new Error(`Cannot unregister unknown handler: ${name}`);
    }
    scriptInjector.pop(handler[0]);
    __privateGet(this, _handlers).delete(name);
  }
  /**
   * Gets the names of all {@link CustomQueryHandler | custom query handlers}.
   */
  names() {
    return [...__privateGet(this, _handlers).keys()];
  }
  /**
   * Unregisters all custom query handlers.
   */
  clear() {
    for (const [registerScript] of __privateGet(this, _handlers)) {
      scriptInjector.pop(registerScript);
    }
    __privateGet(this, _handlers).clear();
  }
};
_handlers = new WeakMap();
var customQueryHandlers = new CustomQueryHandlerRegistry();
function registerCustomQueryHandler(name, handler) {
  customQueryHandlers.register(name, handler);
}
function unregisterCustomQueryHandler(name) {
  customQueryHandlers.unregister(name);
}
function customQueryHandlerNames() {
  return customQueryHandlers.names();
}
function clearCustomQueryHandlers() {
  customQueryHandlers.clear();
}

// node_modules/puppeteer-core/lib/esm/puppeteer/common/PierceQueryHandler.js
var PierceQueryHandler = class extends QueryHandler {
};
__publicField(PierceQueryHandler, "querySelector", (element, selector, { pierceQuerySelector }) => {
  return pierceQuerySelector(element, selector);
});
__publicField(PierceQueryHandler, "querySelectorAll", (element, selector, { pierceQuerySelectorAll }) => {
  return pierceQuerySelectorAll(element, selector);
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/PQueryHandler.js
var PQueryHandler = class extends QueryHandler {
};
__publicField(PQueryHandler, "querySelectorAll", (element, selector, { pQuerySelectorAll }) => {
  return pQuerySelectorAll(element, selector);
});
__publicField(PQueryHandler, "querySelector", (element, selector, { pQuerySelector }) => {
  return pQuerySelector(element, selector);
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/TextQueryHandler.js
var TextQueryHandler = class extends QueryHandler {
};
__publicField(TextQueryHandler, "querySelectorAll", (element, selector, { textQuerySelectorAll }) => {
  return textQuerySelectorAll(element, selector);
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/XPathQueryHandler.js
var XPathQueryHandler = class extends QueryHandler {
};
__publicField(XPathQueryHandler, "querySelectorAll", (element, selector, { xpathQuerySelectorAll }) => {
  return xpathQuerySelectorAll(element, selector);
});
__publicField(XPathQueryHandler, "querySelector", (element, selector, { xpathQuerySelectorAll }) => {
  for (const result of xpathQuerySelectorAll(element, selector, 1)) {
    return result;
  }
  return null;
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/GetQueryHandler.js
var BUILTIN_QUERY_HANDLERS = {
  aria: ARIAQueryHandler,
  pierce: PierceQueryHandler,
  xpath: XPathQueryHandler,
  text: TextQueryHandler
};
var QUERY_SEPARATORS = ["=", "/"];
function getQueryHandlerAndSelector(selector) {
  for (const handlerMap of [
    customQueryHandlers.names().map((name) => {
      return [name, customQueryHandlers.get(name)];
    }),
    Object.entries(BUILTIN_QUERY_HANDLERS)
  ]) {
    for (const [name, QueryHandler2] of handlerMap) {
      for (const separator of QUERY_SEPARATORS) {
        const prefix = `${name}${separator}`;
        if (selector.startsWith(prefix)) {
          selector = selector.slice(prefix.length);
          return { updatedSelector: selector, QueryHandler: QueryHandler2 };
        }
      }
    }
  }
  return { updatedSelector: selector, QueryHandler: PQueryHandler };
}

// node_modules/puppeteer-core/lib/esm/puppeteer/api/JSHandle.js
var __runInitializers = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn)
      context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access)
      context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.unshift(_);
      else
        descriptor[key] = _;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __addDisposableResource3 = function(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources3 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    function next() {
      while (env.stack.length) {
        var rec = env.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
        } catch (e) {
          fail(e);
        }
      }
      if (env.hasError)
        throw env.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var JSHandle = (() => {
  var _a;
  let _classDecorators = [moveable];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _instanceExtraInitializers = [];
  let _getProperty_decorators;
  let _getProperties_decorators;
  var JSHandle2 = (_a = class {
    /**
     * @internal
     */
    constructor() {
      __runInitializers(this, _instanceExtraInitializers);
    }
    /**
     * Evaluates the given function with the current handle as its first argument.
     */
    async evaluate(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
      return await this.realm.evaluate(pageFunction, this, ...args);
    }
    /**
     * Evaluates the given function with the current handle as its first argument.
     *
     */
    async evaluateHandle(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
      return await this.realm.evaluateHandle(pageFunction, this, ...args);
    }
    /**
     * @internal
     */
    async getProperty(propertyName) {
      return await this.evaluateHandle((object, propertyName2) => {
        return object[propertyName2];
      }, propertyName);
    }
    /**
     * Gets a map of handles representing the properties of the current handle.
     *
     * @example
     *
     * ```ts
     * const listHandle = await page.evaluateHandle(() => document.body.children);
     * const properties = await listHandle.getProperties();
     * const children = [];
     * for (const property of properties.values()) {
     *   const element = property.asElement();
     *   if (element) {
     *     children.push(element);
     *   }
     * }
     * children; // holds elementHandles to all children of document.body
     * ```
     */
    async getProperties() {
      const propertyNames = await this.evaluate((object) => {
        var _a2;
        const enumerableProperties = [];
        const descriptors = Object.getOwnPropertyDescriptors(object);
        for (const propertyName in descriptors) {
          if ((_a2 = descriptors[propertyName]) == null ? void 0 : _a2.enumerable) {
            enumerableProperties.push(propertyName);
          }
        }
        return enumerableProperties;
      });
      const map2 = /* @__PURE__ */ new Map();
      const results = await Promise.all(propertyNames.map((key) => {
        return this.getProperty(key);
      }));
      for (const [key, value] of Object.entries(propertyNames)) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource3(env_1, results[key], false);
          if (handle) {
            map2.set(value, handle.move());
          }
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          __disposeResources3(env_1);
        }
      }
      return map2;
    }
    /** @internal */
    [(_getProperty_decorators = [throwIfDisposed()], _getProperties_decorators = [throwIfDisposed()], disposeSymbol)]() {
      return void this.dispose().catch(debugError);
    }
    /** @internal */
    [asyncDisposeSymbol]() {
      return this.dispose();
    }
  }, _classThis = _a, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
    __esDecorate(_a, null, _getProperty_decorators, { kind: "method", name: "getProperty", static: false, private: false, access: { has: (obj) => "getProperty" in obj, get: (obj) => obj.getProperty }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _getProperties_decorators, { kind: "method", name: "getProperties", static: false, private: false, access: { has: (obj) => "getProperties" in obj, get: (obj) => obj.getProperties }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    JSHandle2 = _classThis = _classDescriptor.value;
    if (_metadata)
      Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    __runInitializers(_classThis, _classExtraInitializers);
  })(), _a);
  return JSHandle2 = _classThis;
})();

// node_modules/puppeteer-core/lib/esm/puppeteer/api/ElementHandle.js
var __runInitializers2 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate2 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn)
      context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access)
      context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.unshift(_);
      else
        descriptor[key] = _;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __addDisposableResource4 = function(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources4 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    function next() {
      while (env.stack.length) {
        var rec = env.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
        } catch (e) {
          fail(e);
        }
      }
      if (env.hasError)
        throw env.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var ElementHandle = (() => {
  var _checkVisibility, checkVisibility_fn, _clickableBox, clickableBox_fn, _intersectBoundingBoxesWithFrame, intersectBoundingBoxesWithFrame_fn, _getTopLeftCornerOfFrame, getTopLeftCornerOfFrame_fn, _nonEmptyVisibleBoundingBox, nonEmptyVisibleBoundingBox_fn, _asSVGElementHandle, asSVGElementHandle_fn, _getOwnerSVGElement, getOwnerSVGElement_fn, _a2;
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;
  let _classSuper = JSHandle;
  let _instanceExtraInitializers = [];
  let _getProperty_decorators;
  let _getProperties_decorators;
  let _jsonValue_decorators;
  let _$_decorators;
  let _$$_decorators;
  let _waitForSelector_decorators;
  let _isVisible_decorators;
  let _isHidden_decorators;
  let _toElement_decorators;
  let _clickablePoint_decorators;
  let _hover_decorators;
  let _click_decorators;
  let _drag_decorators;
  let _dragEnter_decorators;
  let _dragOver_decorators;
  let _drop_decorators;
  let _dragAndDrop_decorators;
  let _select_decorators;
  let _tap_decorators;
  let _touchStart_decorators;
  let _touchMove_decorators;
  let _touchEnd_decorators;
  let _focus_decorators;
  let _type_decorators;
  let _press_decorators;
  let _boundingBox_decorators;
  let _boxModel_decorators;
  let _screenshot_decorators;
  let _isIntersectingViewport_decorators;
  let _scrollIntoView_decorators;
  return _a2 = class extends _classSuper {
    /**
     * @internal
     */
    constructor(handle) {
      super();
      __privateAdd(this, _checkVisibility);
      __privateAdd(this, _clickableBox);
      __privateAdd(this, _intersectBoundingBoxesWithFrame);
      __privateAdd(this, _getTopLeftCornerOfFrame);
      __privateAdd(this, _nonEmptyVisibleBoundingBox);
      /**
       * Returns true if an element is an SVGElement (included svg, path, rect
       * etc.).
       */
      __privateAdd(this, _asSVGElementHandle);
      __privateAdd(this, _getOwnerSVGElement);
      /**
       * @internal
       * Cached isolatedHandle to prevent
       * trying to adopt it multiple times
       */
      __publicField(this, "isolatedHandle", (__runInitializers2(this, _instanceExtraInitializers), void 0));
      /**
       * @internal
       */
      __publicField(this, "handle");
      this.handle = handle;
      this[_isElementHandle] = true;
    }
    /**
     * A given method will have it's `this` replaced with an isolated version of
     * `this` when decorated with this decorator.
     *
     * All changes of isolated `this` are reflected on the actual `this`.
     *
     * @internal
     */
    static bindIsolatedHandle(target, _) {
      return async function(...args) {
        if (this.realm === this.frame.isolatedRealm()) {
          return await target.call(this, ...args);
        }
        let adoptedThis;
        if (this["isolatedHandle"]) {
          adoptedThis = this["isolatedHandle"];
        } else {
          this["isolatedHandle"] = adoptedThis = await this.frame.isolatedRealm().adoptHandle(this);
        }
        const result = await target.call(adoptedThis, ...args);
        if (result === adoptedThis) {
          return this;
        }
        if (result instanceof JSHandle) {
          return await this.realm.transferHandle(result);
        }
        if (Array.isArray(result)) {
          await Promise.all(result.map(async (item, index, result2) => {
            if (item instanceof JSHandle) {
              result2[index] = await this.realm.transferHandle(item);
            }
          }));
        }
        if (result instanceof Map) {
          await Promise.all([...result.entries()].map(async ([key, value]) => {
            if (value instanceof JSHandle) {
              result.set(key, await this.realm.transferHandle(value));
            }
          }));
        }
        return result;
      };
    }
    /**
     * @internal
     */
    get id() {
      return this.handle.id;
    }
    /**
     * @internal
     */
    get disposed() {
      return this.handle.disposed;
    }
    /**
     * @internal
     */
    async getProperty(propertyName) {
      return await this.handle.getProperty(propertyName);
    }
    /**
     * @internal
     */
    async getProperties() {
      return await this.handle.getProperties();
    }
    /**
     * @internal
     */
    async evaluate(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
      return await this.handle.evaluate(pageFunction, ...args);
    }
    /**
     * @internal
     */
    async evaluateHandle(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
      return await this.handle.evaluateHandle(pageFunction, ...args);
    }
    /**
     * @internal
     */
    async jsonValue() {
      return await this.handle.jsonValue();
    }
    /**
     * @internal
     */
    toString() {
      return this.handle.toString();
    }
    /**
     * @internal
     */
    remoteObject() {
      return this.handle.remoteObject();
    }
    /**
     * @internal
     */
    dispose() {
      return this.handle.dispose();
    }
    /**
     * @internal
     */
    asElement() {
      return this;
    }
    /**
     * Queries the current element for an element matching the given selector.
     *
     * @param selector - The selector to query for.
     * @returns A {@link ElementHandle | element handle} to the first element
     * matching the given selector. Otherwise, `null`.
     */
    async $(selector) {
      const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
      return await QueryHandler2.queryOne(this, updatedSelector);
    }
    /**
     * Queries the current element for all elements matching the given selector.
     *
     * @param selector - The selector to query for.
     * @returns An array of {@link ElementHandle | element handles} that point to
     * elements matching the given selector.
     */
    async $$(selector) {
      const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
      return await AsyncIterableUtil.collect(QueryHandler2.queryAll(this, updatedSelector));
    }
    /**
     * Runs the given function on the first element matching the given selector in
     * the current element.
     *
     * If the given function returns a promise, then this method will wait till
     * the promise resolves.
     *
     * @example
     *
     * ```ts
     * const tweetHandle = await page.$('.tweet');
     * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe(
     *   '100'
     * );
     * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe(
     *   '10'
     * );
     * ```
     *
     * @param selector - The selector to query for.
     * @param pageFunction - The function to be evaluated in this element's page's
     * context. The first element matching the selector will be passed in as the
     * first argument.
     * @param args - Additional arguments to pass to `pageFunction`.
     * @returns A promise to the result of the function.
     */
    async $eval(selector, pageFunction, ...args) {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
        const elementHandle = __addDisposableResource4(env_1, await this.$(selector), false);
        if (!elementHandle) {
          throw new Error(`Error: failed to find element matching selector "${selector}"`);
        }
        return await elementHandle.evaluate(pageFunction, ...args);
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        __disposeResources4(env_1);
      }
    }
    /**
     * Runs the given function on an array of elements matching the given selector
     * in the current element.
     *
     * If the given function returns a promise, then this method will wait till
     * the promise resolves.
     *
     * @example
     * HTML:
     *
     * ```html
     * <div class="feed">
     *   <div class="tweet">Hello!</div>
     *   <div class="tweet">Hi!</div>
     * </div>
     * ```
     *
     * JavaScript:
     *
     * ```ts
     * const feedHandle = await page.$('.feed');
     * expect(
     *   await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText))
     * ).toEqual(['Hello!', 'Hi!']);
     * ```
     *
     * @param selector - The selector to query for.
     * @param pageFunction - The function to be evaluated in the element's page's
     * context. An array of elements matching the given selector will be passed to
     * the function as its first argument.
     * @param args - Additional arguments to pass to `pageFunction`.
     * @returns A promise to the result of the function.
     */
    async $$eval(selector, pageFunction, ...args) {
      const env_2 = { stack: [], error: void 0, hasError: false };
      try {
        pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
        const results = await this.$$(selector);
        const elements = __addDisposableResource4(env_2, await this.evaluateHandle((_, ...elements2) => {
          return elements2;
        }, ...results), false);
        const [result] = await Promise.all([
          elements.evaluate(pageFunction, ...args),
          ...results.map((results2) => {
            return results2.dispose();
          })
        ]);
        return result;
      } catch (e_2) {
        env_2.error = e_2;
        env_2.hasError = true;
      } finally {
        __disposeResources4(env_2);
      }
    }
    /**
     * Wait for an element matching the given selector to appear in the current
     * element.
     *
     * Unlike {@link Frame.waitForSelector}, this method does not work across
     * navigations or if the element is detached from DOM.
     *
     * @example
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     *
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   let currentURL;
     *   page
     *     .mainFrame()
     *     .waitForSelector('img')
     *     .then(() => console.log('First URL with image: ' + currentURL));
     *
     *   for (currentURL of [
     *     'https://example.com',
     *     'https://google.com',
     *     'https://bbc.com',
     *   ]) {
     *     await page.goto(currentURL);
     *   }
     *   await browser.close();
     * })();
     * ```
     *
     * @param selector - The selector to query and wait for.
     * @param options - Options for customizing waiting behavior.
     * @returns An element matching the given selector.
     * @throws Throws if an element matching the given selector doesn't appear.
     */
    async waitForSelector(selector, options = {}) {
      const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
      return await QueryHandler2.waitFor(this, updatedSelector, options);
    }
    /**
     * Checks if an element is visible using the same mechanism as
     * {@link ElementHandle.waitForSelector}.
     */
    async isVisible() {
      return await __privateMethod(this, _checkVisibility, checkVisibility_fn).call(this, true);
    }
    /**
     * Checks if an element is hidden using the same mechanism as
     * {@link ElementHandle.waitForSelector}.
     */
    async isHidden() {
      return await __privateMethod(this, _checkVisibility, checkVisibility_fn).call(this, false);
    }
    /**
     * Converts the current handle to the given element type.
     *
     * @example
     *
     * ```ts
     * const element: ElementHandle<Element> = await page.$(
     *   '.class-name-of-anchor'
     * );
     * // DO NOT DISPOSE `element`, this will be always be the same handle.
     * const anchor: ElementHandle<HTMLAnchorElement> =
     *   await element.toElement('a');
     * ```
     *
     * @param tagName - The tag name of the desired element type.
     * @throws An error if the handle does not match. **The handle will not be
     * automatically disposed.**
     */
    async toElement(tagName) {
      const isMatchingTagName = await this.evaluate((node, tagName2) => {
        return node.nodeName === tagName2.toUpperCase();
      }, tagName);
      if (!isMatchingTagName) {
        throw new Error(`Element is not a(n) \`${tagName}\` element`);
      }
      return this;
    }
    /**
     * Returns the middle point within an element unless a specific offset is provided.
     */
    async clickablePoint(offset) {
      const box = await __privateMethod(this, _clickableBox, clickableBox_fn).call(this);
      if (!box) {
        throw new Error("Node is either not clickable or not an Element");
      }
      if (offset !== void 0) {
        return {
          x: box.x + offset.x,
          y: box.y + offset.y
        };
      }
      return {
        x: box.x + box.width / 2,
        y: box.y + box.height / 2
      };
    }
    /**
     * This method scrolls element into view if needed, and then
     * uses {@link Page.mouse} to hover over the center of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async hover() {
      await this.scrollIntoViewIfNeeded();
      const { x, y } = await this.clickablePoint();
      await this.frame.page().mouse.move(x, y);
    }
    /**
     * This method scrolls element into view if needed, and then
     * uses {@link Page.mouse} to click in the center of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async click(options = {}) {
      await this.scrollIntoViewIfNeeded();
      const { x, y } = await this.clickablePoint(options.offset);
      await this.frame.page().mouse.click(x, y, options);
    }
    /**
     * Drags an element over the given element or point.
     *
     * @returns DEPRECATED. When drag interception is enabled, the drag payload is
     * returned.
     */
    async drag(target) {
      await this.scrollIntoViewIfNeeded();
      const page = this.frame.page();
      if (page.isDragInterceptionEnabled()) {
        const source2 = await this.clickablePoint();
        if (target instanceof _a2) {
          target = await target.clickablePoint();
        }
        return await page.mouse.drag(source2, target);
      }
      try {
        if (!page._isDragging) {
          page._isDragging = true;
          await this.hover();
          await page.mouse.down();
        }
        if (target instanceof _a2) {
          await target.hover();
        } else {
          await page.mouse.move(target.x, target.y);
        }
      } catch (error) {
        page._isDragging = false;
        throw error;
      }
    }
    /**
     * @deprecated Do not use. `dragenter` will automatically be performed during dragging.
     */
    async dragEnter(data = { items: [], dragOperationsMask: 1 }) {
      const page = this.frame.page();
      await this.scrollIntoViewIfNeeded();
      const target = await this.clickablePoint();
      await page.mouse.dragEnter(target, data);
    }
    /**
     * @deprecated Do not use. `dragover` will automatically be performed during dragging.
     */
    async dragOver(data = { items: [], dragOperationsMask: 1 }) {
      const page = this.frame.page();
      await this.scrollIntoViewIfNeeded();
      const target = await this.clickablePoint();
      await page.mouse.dragOver(target, data);
    }
    /**
     * @internal
     */
    async drop(dataOrElement = {
      items: [],
      dragOperationsMask: 1
    }) {
      const page = this.frame.page();
      if ("items" in dataOrElement) {
        await this.scrollIntoViewIfNeeded();
        const destination = await this.clickablePoint();
        await page.mouse.drop(destination, dataOrElement);
      } else {
        await dataOrElement.drag(this);
        page._isDragging = false;
        await page.mouse.up();
      }
    }
    /**
     * @deprecated Use `ElementHandle.drop` instead.
     */
    async dragAndDrop(target, options) {
      const page = this.frame.page();
      assert(page.isDragInterceptionEnabled(), "Drag Interception is not enabled!");
      await this.scrollIntoViewIfNeeded();
      const startPoint = await this.clickablePoint();
      const targetPoint = await target.clickablePoint();
      await page.mouse.dragAndDrop(startPoint, targetPoint, options);
    }
    /**
     * Triggers a `change` and `input` event once all the provided options have been
     * selected. If there's no `<select>` element matching `selector`, the method
     * throws an error.
     *
     * @example
     *
     * ```ts
     * handle.select('blue'); // single selection
     * handle.select('red', 'green', 'blue'); // multiple selections
     * ```
     *
     * @param values - Values of options to select. If the `<select>` has the
     * `multiple` attribute, all values are considered, otherwise only the first
     * one is taken into account.
     */
    async select(...values) {
      for (const value of values) {
        assert(isString(value), 'Values must be strings. Found value "' + value + '" of type "' + typeof value + '"');
      }
      return await this.evaluate((element, vals) => {
        const values2 = new Set(vals);
        if (!(element instanceof HTMLSelectElement)) {
          throw new Error("Element is not a <select> element.");
        }
        const selectedValues = /* @__PURE__ */ new Set();
        if (!element.multiple) {
          for (const option of element.options) {
            option.selected = false;
          }
          for (const option of element.options) {
            if (values2.has(option.value)) {
              option.selected = true;
              selectedValues.add(option.value);
              break;
            }
          }
        } else {
          for (const option of element.options) {
            option.selected = values2.has(option.value);
            if (option.selected) {
              selectedValues.add(option.value);
            }
          }
        }
        element.dispatchEvent(new Event("input", { bubbles: true }));
        element.dispatchEvent(new Event("change", { bubbles: true }));
        return [...selectedValues.values()];
      }, values);
    }
    /**
     * This method scrolls element into view if needed, and then uses
     * {@link Touchscreen.tap} to tap in the center of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async tap() {
      await this.scrollIntoViewIfNeeded();
      const { x, y } = await this.clickablePoint();
      await this.frame.page().touchscreen.tap(x, y);
    }
    async touchStart() {
      await this.scrollIntoViewIfNeeded();
      const { x, y } = await this.clickablePoint();
      await this.frame.page().touchscreen.touchStart(x, y);
    }
    async touchMove() {
      await this.scrollIntoViewIfNeeded();
      const { x, y } = await this.clickablePoint();
      await this.frame.page().touchscreen.touchMove(x, y);
    }
    async touchEnd() {
      await this.scrollIntoViewIfNeeded();
      await this.frame.page().touchscreen.touchEnd();
    }
    /**
     * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.
     */
    async focus() {
      await this.evaluate((element) => {
        if (!(element instanceof HTMLElement)) {
          throw new Error("Cannot focus non-HTMLElement");
        }
        return element.focus();
      });
    }
    /**
     * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and
     * `keyup` event for each character in the text.
     *
     * To press a special key, like `Control` or `ArrowDown`,
     * use {@link ElementHandle.press}.
     *
     * @example
     *
     * ```ts
     * await elementHandle.type('Hello'); // Types instantly
     * await elementHandle.type('World', {delay: 100}); // Types slower, like a user
     * ```
     *
     * @example
     * An example of typing into a text field and then submitting the form:
     *
     * ```ts
     * const elementHandle = await page.$('input');
     * await elementHandle.type('some text');
     * await elementHandle.press('Enter');
     * ```
     *
     * @param options - Delay in milliseconds. Defaults to 0.
     */
    async type(text, options) {
      await this.focus();
      await this.frame.page().keyboard.type(text, options);
    }
    /**
     * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.
     *
     * @remarks
     * If `key` is a single character and no modifier keys besides `Shift`
     * are being held down, a `keypress`/`input` event will also be generated.
     * The `text` option can be specified to force an input event to be generated.
     *
     * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`
     * will type the text in upper case.
     *
     * @param key - Name of key to press, such as `ArrowLeft`.
     * See {@link KeyInput} for a list of all key names.
     */
    async press(key, options) {
      await this.focus();
      await this.frame.page().keyboard.press(key, options);
    }
    /**
     * This method returns the bounding box of the element (relative to the main frame),
     * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}
     * (example: `display: none`).
     */
    async boundingBox() {
      const box = await this.evaluate((element) => {
        if (!(element instanceof Element)) {
          return null;
        }
        if (element.getClientRects().length === 0) {
          return null;
        }
        const rect = element.getBoundingClientRect();
        return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
      });
      if (!box) {
        return null;
      }
      const offset = await __privateMethod(this, _getTopLeftCornerOfFrame, getTopLeftCornerOfFrame_fn).call(this);
      if (!offset) {
        return null;
      }
      return {
        x: box.x + offset.x,
        y: box.y + offset.y,
        height: box.height,
        width: box.width
      };
    }
    /**
     * This method returns boxes of the element,
     * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}
     * (example: `display: none`).
     *
     * @remarks
     *
     * Boxes are represented as an array of points;
     * Each Point is an object `{x, y}`. Box points are sorted clock-wise.
     */
    async boxModel() {
      const model = await this.evaluate((element) => {
        if (!(element instanceof Element)) {
          return null;
        }
        if (element.getClientRects().length === 0) {
          return null;
        }
        const rect = element.getBoundingClientRect();
        const style = window.getComputedStyle(element);
        const offsets = {
          padding: {
            left: parseInt(style.paddingLeft, 10),
            top: parseInt(style.paddingTop, 10),
            right: parseInt(style.paddingRight, 10),
            bottom: parseInt(style.paddingBottom, 10)
          },
          margin: {
            left: -parseInt(style.marginLeft, 10),
            top: -parseInt(style.marginTop, 10),
            right: -parseInt(style.marginRight, 10),
            bottom: -parseInt(style.marginBottom, 10)
          },
          border: {
            left: parseInt(style.borderLeft, 10),
            top: parseInt(style.borderTop, 10),
            right: parseInt(style.borderRight, 10),
            bottom: parseInt(style.borderBottom, 10)
          }
        };
        const border = [
          { x: rect.left, y: rect.top },
          { x: rect.left + rect.width, y: rect.top },
          { x: rect.left + rect.width, y: rect.top + rect.bottom },
          { x: rect.left, y: rect.top + rect.bottom }
        ];
        const padding = transformQuadWithOffsets(border, offsets.border);
        const content = transformQuadWithOffsets(padding, offsets.padding);
        const margin = transformQuadWithOffsets(border, offsets.margin);
        return {
          content,
          padding,
          border,
          margin,
          width: rect.width,
          height: rect.height
        };
        function transformQuadWithOffsets(quad, offsets2) {
          return [
            {
              x: quad[0].x + offsets2.left,
              y: quad[0].y + offsets2.top
            },
            {
              x: quad[1].x - offsets2.right,
              y: quad[1].y + offsets2.top
            },
            {
              x: quad[2].x - offsets2.right,
              y: quad[2].y - offsets2.bottom
            },
            {
              x: quad[3].x + offsets2.left,
              y: quad[3].y - offsets2.bottom
            }
          ];
        }
      });
      if (!model) {
        return null;
      }
      const offset = await __privateMethod(this, _getTopLeftCornerOfFrame, getTopLeftCornerOfFrame_fn).call(this);
      if (!offset) {
        return null;
      }
      for (const attribute of [
        "content",
        "padding",
        "border",
        "margin"
      ]) {
        for (const point of model[attribute]) {
          point.x += offset.x;
          point.y += offset.y;
        }
      }
      return model;
    }
    async screenshot(options = {}) {
      const { scrollIntoView = true, clip } = options;
      const page = this.frame.page();
      if (scrollIntoView) {
        await this.scrollIntoViewIfNeeded();
      }
      const elementClip = await __privateMethod(this, _nonEmptyVisibleBoundingBox, nonEmptyVisibleBoundingBox_fn).call(this);
      const [pageLeft, pageTop] = await this.evaluate(() => {
        if (!window.visualViewport) {
          throw new Error("window.visualViewport is not supported.");
        }
        return [
          window.visualViewport.pageLeft,
          window.visualViewport.pageTop
        ];
      });
      elementClip.x += pageLeft;
      elementClip.y += pageTop;
      if (clip) {
        elementClip.x += clip.x;
        elementClip.y += clip.y;
        elementClip.height = clip.height;
        elementClip.width = clip.width;
      }
      return await page.screenshot({ ...options, clip: elementClip });
    }
    /**
     * @internal
     */
    async assertConnectedElement() {
      const error = await this.evaluate(async (element) => {
        if (!element.isConnected) {
          return "Node is detached from document";
        }
        if (element.nodeType !== Node.ELEMENT_NODE) {
          return "Node is not of type HTMLElement";
        }
        return;
      });
      if (error) {
        throw new Error(error);
      }
    }
    /**
     * @internal
     */
    async scrollIntoViewIfNeeded() {
      if (await this.isIntersectingViewport({
        threshold: 1
      })) {
        return;
      }
      await this.scrollIntoView();
    }
    /**
     * Resolves to true if the element is visible in the current viewport. If an
     * element is an SVG, we check if the svg owner element is in the viewport
     * instead. See https://crbug.com/963246.
     *
     * @param options - Threshold for the intersection between 0 (no intersection) and 1
     * (full intersection). Defaults to 1.
     */
    async isIntersectingViewport(options = {}) {
      var _a3;
      const env_5 = { stack: [], error: void 0, hasError: false };
      try {
        await this.assertConnectedElement();
        const handle = await __privateMethod(this, _asSVGElementHandle, asSVGElementHandle_fn).call(this);
        const target = __addDisposableResource4(env_5, handle && await __privateMethod(_a3 = handle, _getOwnerSVGElement, getOwnerSVGElement_fn).call(_a3), false);
        return await (target ?? this).evaluate(async (element, threshold) => {
          const visibleRatio = await new Promise((resolve) => {
            const observer = new IntersectionObserver((entries) => {
              resolve(entries[0].intersectionRatio);
              observer.disconnect();
            });
            observer.observe(element);
          });
          return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;
        }, options.threshold ?? 0);
      } catch (e_5) {
        env_5.error = e_5;
        env_5.hasError = true;
      } finally {
        __disposeResources4(env_5);
      }
    }
    /**
     * Scrolls the element into view using either the automation protocol client
     * or by calling element.scrollIntoView.
     */
    async scrollIntoView() {
      await this.assertConnectedElement();
      await this.evaluate(async (element) => {
        element.scrollIntoView({
          block: "center",
          inline: "center",
          behavior: "instant"
        });
      });
    }
  }, _checkVisibility = new WeakSet(), checkVisibility_fn = async function(visibility) {
    return await this.evaluate(async (element, PuppeteerUtil, visibility2) => {
      return Boolean(PuppeteerUtil.checkVisibility(element, visibility2));
    }, LazyArg.create((context) => {
      return context.puppeteerUtil;
    }), visibility);
  }, _clickableBox = new WeakSet(), clickableBox_fn = async function() {
    var _a3;
    const boxes = await this.evaluate((element) => {
      if (!(element instanceof Element)) {
        return null;
      }
      return [...element.getClientRects()].map((rect) => {
        return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
      });
    });
    if (!(boxes == null ? void 0 : boxes.length)) {
      return null;
    }
    await __privateMethod(this, _intersectBoundingBoxesWithFrame, intersectBoundingBoxesWithFrame_fn).call(this, boxes);
    let frame = this.frame;
    let parentFrame;
    while (parentFrame = frame == null ? void 0 : frame.parentFrame()) {
      const env_3 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource4(env_3, await frame.frameElement(), false);
        if (!handle) {
          throw new Error("Unsupported frame type");
        }
        const parentBox = await handle.evaluate((element) => {
          if (element.getClientRects().length === 0) {
            return null;
          }
          const rect = element.getBoundingClientRect();
          const style = window.getComputedStyle(element);
          return {
            left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),
            top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)
          };
        });
        if (!parentBox) {
          return null;
        }
        for (const box2 of boxes) {
          box2.x += parentBox.left;
          box2.y += parentBox.top;
        }
        await __privateMethod(_a3 = handle, _intersectBoundingBoxesWithFrame, intersectBoundingBoxesWithFrame_fn).call(_a3, boxes);
        frame = parentFrame;
      } catch (e_3) {
        env_3.error = e_3;
        env_3.hasError = true;
      } finally {
        __disposeResources4(env_3);
      }
    }
    const box = boxes.find((box2) => {
      return box2.width >= 1 && box2.height >= 1;
    });
    if (!box) {
      return null;
    }
    return {
      x: box.x,
      y: box.y,
      height: box.height,
      width: box.width
    };
  }, _intersectBoundingBoxesWithFrame = new WeakSet(), intersectBoundingBoxesWithFrame_fn = async function(boxes) {
    const { documentWidth, documentHeight } = await this.frame.isolatedRealm().evaluate(() => {
      return {
        documentWidth: document.documentElement.clientWidth,
        documentHeight: document.documentElement.clientHeight
      };
    });
    for (const box of boxes) {
      intersectBoundingBox(box, documentWidth, documentHeight);
    }
  }, _getTopLeftCornerOfFrame = new WeakSet(), getTopLeftCornerOfFrame_fn = async function() {
    const point = { x: 0, y: 0 };
    let frame = this.frame;
    let parentFrame;
    while (parentFrame = frame == null ? void 0 : frame.parentFrame()) {
      const env_4 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource4(env_4, await frame.frameElement(), false);
        if (!handle) {
          throw new Error("Unsupported frame type");
        }
        const parentBox = await handle.evaluate((element) => {
          if (element.getClientRects().length === 0) {
            return null;
          }
          const rect = element.getBoundingClientRect();
          const style = window.getComputedStyle(element);
          return {
            left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),
            top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)
          };
        });
        if (!parentBox) {
          return null;
        }
        point.x += parentBox.left;
        point.y += parentBox.top;
        frame = parentFrame;
      } catch (e_4) {
        env_4.error = e_4;
        env_4.hasError = true;
      } finally {
        __disposeResources4(env_4);
      }
    }
    return point;
  }, _nonEmptyVisibleBoundingBox = new WeakSet(), nonEmptyVisibleBoundingBox_fn = async function() {
    const box = await this.boundingBox();
    assert(box, "Node is either not visible or not an HTMLElement");
    assert(box.width !== 0, "Node has 0 width.");
    assert(box.height !== 0, "Node has 0 height.");
    return box;
  }, _asSVGElementHandle = new WeakSet(), asSVGElementHandle_fn = async function() {
    if (await this.evaluate((element) => {
      return element instanceof SVGElement;
    })) {
      return this;
    } else {
      return null;
    }
  }, _getOwnerSVGElement = new WeakSet(), getOwnerSVGElement_fn = async function() {
    return await this.evaluateHandle((element) => {
      if (element instanceof SVGSVGElement) {
        return element;
      }
      return element.ownerSVGElement;
    });
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _getProperty_decorators = [throwIfDisposed(), (_a = _a2).bindIsolatedHandle.bind(_a)];
    _getProperties_decorators = [throwIfDisposed(), (_b = _a2).bindIsolatedHandle.bind(_b)];
    _jsonValue_decorators = [throwIfDisposed(), (_c = _a2).bindIsolatedHandle.bind(_c)];
    _$_decorators = [throwIfDisposed(), (_d = _a2).bindIsolatedHandle.bind(_d)];
    _$$_decorators = [throwIfDisposed(), (_e = _a2).bindIsolatedHandle.bind(_e)];
    _waitForSelector_decorators = [throwIfDisposed(), (_f = _a2).bindIsolatedHandle.bind(_f)];
    _isVisible_decorators = [throwIfDisposed(), (_g = _a2).bindIsolatedHandle.bind(_g)];
    _isHidden_decorators = [throwIfDisposed(), (_h = _a2).bindIsolatedHandle.bind(_h)];
    _toElement_decorators = [throwIfDisposed(), (_j = _a2).bindIsolatedHandle.bind(_j)];
    _clickablePoint_decorators = [throwIfDisposed(), (_k = _a2).bindIsolatedHandle.bind(_k)];
    _hover_decorators = [throwIfDisposed(), (_l = _a2).bindIsolatedHandle.bind(_l)];
    _click_decorators = [throwIfDisposed(), (_m = _a2).bindIsolatedHandle.bind(_m)];
    _drag_decorators = [throwIfDisposed(), (_o = _a2).bindIsolatedHandle.bind(_o)];
    _dragEnter_decorators = [throwIfDisposed(), (_p = _a2).bindIsolatedHandle.bind(_p)];
    _dragOver_decorators = [throwIfDisposed(), (_q = _a2).bindIsolatedHandle.bind(_q)];
    _drop_decorators = [throwIfDisposed(), (_r = _a2).bindIsolatedHandle.bind(_r)];
    _dragAndDrop_decorators = [throwIfDisposed(), (_s = _a2).bindIsolatedHandle.bind(_s)];
    _select_decorators = [throwIfDisposed(), (_t = _a2).bindIsolatedHandle.bind(_t)];
    _tap_decorators = [throwIfDisposed(), (_u = _a2).bindIsolatedHandle.bind(_u)];
    _touchStart_decorators = [throwIfDisposed(), (_v = _a2).bindIsolatedHandle.bind(_v)];
    _touchMove_decorators = [throwIfDisposed(), (_w = _a2).bindIsolatedHandle.bind(_w)];
    _touchEnd_decorators = [throwIfDisposed(), (_x = _a2).bindIsolatedHandle.bind(_x)];
    _focus_decorators = [throwIfDisposed(), (_y = _a2).bindIsolatedHandle.bind(_y)];
    _type_decorators = [throwIfDisposed(), (_z = _a2).bindIsolatedHandle.bind(_z)];
    _press_decorators = [throwIfDisposed(), (_0 = _a2).bindIsolatedHandle.bind(_0)];
    _boundingBox_decorators = [throwIfDisposed(), (_1 = _a2).bindIsolatedHandle.bind(_1)];
    _boxModel_decorators = [throwIfDisposed(), (_2 = _a2).bindIsolatedHandle.bind(_2)];
    _screenshot_decorators = [throwIfDisposed(), (_3 = _a2).bindIsolatedHandle.bind(_3)];
    _isIntersectingViewport_decorators = [throwIfDisposed(), (_4 = _a2).bindIsolatedHandle.bind(_4)];
    _scrollIntoView_decorators = [throwIfDisposed(), (_5 = _a2).bindIsolatedHandle.bind(_5)];
    __esDecorate2(_a2, null, _getProperty_decorators, { kind: "method", name: "getProperty", static: false, private: false, access: { has: (obj) => "getProperty" in obj, get: (obj) => obj.getProperty }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _getProperties_decorators, { kind: "method", name: "getProperties", static: false, private: false, access: { has: (obj) => "getProperties" in obj, get: (obj) => obj.getProperties }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _jsonValue_decorators, { kind: "method", name: "jsonValue", static: false, private: false, access: { has: (obj) => "jsonValue" in obj, get: (obj) => obj.jsonValue }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _$_decorators, { kind: "method", name: "$", static: false, private: false, access: { has: (obj) => "$" in obj, get: (obj) => obj.$ }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _$$_decorators, { kind: "method", name: "$$", static: false, private: false, access: { has: (obj) => "$$" in obj, get: (obj) => obj.$$ }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _waitForSelector_decorators, { kind: "method", name: "waitForSelector", static: false, private: false, access: { has: (obj) => "waitForSelector" in obj, get: (obj) => obj.waitForSelector }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _isVisible_decorators, { kind: "method", name: "isVisible", static: false, private: false, access: { has: (obj) => "isVisible" in obj, get: (obj) => obj.isVisible }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _isHidden_decorators, { kind: "method", name: "isHidden", static: false, private: false, access: { has: (obj) => "isHidden" in obj, get: (obj) => obj.isHidden }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _toElement_decorators, { kind: "method", name: "toElement", static: false, private: false, access: { has: (obj) => "toElement" in obj, get: (obj) => obj.toElement }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _clickablePoint_decorators, { kind: "method", name: "clickablePoint", static: false, private: false, access: { has: (obj) => "clickablePoint" in obj, get: (obj) => obj.clickablePoint }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _hover_decorators, { kind: "method", name: "hover", static: false, private: false, access: { has: (obj) => "hover" in obj, get: (obj) => obj.hover }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _click_decorators, { kind: "method", name: "click", static: false, private: false, access: { has: (obj) => "click" in obj, get: (obj) => obj.click }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _drag_decorators, { kind: "method", name: "drag", static: false, private: false, access: { has: (obj) => "drag" in obj, get: (obj) => obj.drag }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _dragEnter_decorators, { kind: "method", name: "dragEnter", static: false, private: false, access: { has: (obj) => "dragEnter" in obj, get: (obj) => obj.dragEnter }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _dragOver_decorators, { kind: "method", name: "dragOver", static: false, private: false, access: { has: (obj) => "dragOver" in obj, get: (obj) => obj.dragOver }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _drop_decorators, { kind: "method", name: "drop", static: false, private: false, access: { has: (obj) => "drop" in obj, get: (obj) => obj.drop }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _dragAndDrop_decorators, { kind: "method", name: "dragAndDrop", static: false, private: false, access: { has: (obj) => "dragAndDrop" in obj, get: (obj) => obj.dragAndDrop }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _select_decorators, { kind: "method", name: "select", static: false, private: false, access: { has: (obj) => "select" in obj, get: (obj) => obj.select }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _tap_decorators, { kind: "method", name: "tap", static: false, private: false, access: { has: (obj) => "tap" in obj, get: (obj) => obj.tap }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _touchStart_decorators, { kind: "method", name: "touchStart", static: false, private: false, access: { has: (obj) => "touchStart" in obj, get: (obj) => obj.touchStart }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _touchMove_decorators, { kind: "method", name: "touchMove", static: false, private: false, access: { has: (obj) => "touchMove" in obj, get: (obj) => obj.touchMove }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _touchEnd_decorators, { kind: "method", name: "touchEnd", static: false, private: false, access: { has: (obj) => "touchEnd" in obj, get: (obj) => obj.touchEnd }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _focus_decorators, { kind: "method", name: "focus", static: false, private: false, access: { has: (obj) => "focus" in obj, get: (obj) => obj.focus }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _type_decorators, { kind: "method", name: "type", static: false, private: false, access: { has: (obj) => "type" in obj, get: (obj) => obj.type }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _press_decorators, { kind: "method", name: "press", static: false, private: false, access: { has: (obj) => "press" in obj, get: (obj) => obj.press }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _boundingBox_decorators, { kind: "method", name: "boundingBox", static: false, private: false, access: { has: (obj) => "boundingBox" in obj, get: (obj) => obj.boundingBox }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _boxModel_decorators, { kind: "method", name: "boxModel", static: false, private: false, access: { has: (obj) => "boxModel" in obj, get: (obj) => obj.boxModel }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _screenshot_decorators, { kind: "method", name: "screenshot", static: false, private: false, access: { has: (obj) => "screenshot" in obj, get: (obj) => obj.screenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _isIntersectingViewport_decorators, { kind: "method", name: "isIntersectingViewport", static: false, private: false, access: { has: (obj) => "isIntersectingViewport" in obj, get: (obj) => obj.isIntersectingViewport }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate2(_a2, null, _scrollIntoView_decorators, { kind: "method", name: "scrollIntoView", static: false, private: false, access: { has: (obj) => "scrollIntoView" in obj, get: (obj) => obj.scrollIntoView }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata)
      Object.defineProperty(_a2, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a2;
})();
function intersectBoundingBox(box, width, height) {
  box.width = Math.max(box.x >= 0 ? Math.min(width - box.x, box.width) : Math.min(width, box.width + box.x), 0);
  box.height = Math.max(box.y >= 0 ? Math.min(height - box.y, box.height) : Math.min(height, box.height + box.y), 0);
}

// node_modules/puppeteer-core/lib/esm/puppeteer/api/locators/locators.js
var __addDisposableResource5 = function(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources5 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    function next() {
      while (env.stack.length) {
        var rec = env.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
        } catch (e) {
          fail(e);
        }
      }
      if (env.hasError)
        throw env.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var LocatorEvent;
(function(LocatorEvent2) {
  LocatorEvent2["Action"] = "action";
})(LocatorEvent || (LocatorEvent = {}));
var _ensureElementIsInTheViewport, _waitForEnabled, _waitForStableBoundingBox, _waitForEnabledIfNeeded, _waitForStableBoundingBoxIfNeeded, _ensureElementIsInTheViewportIfNeeded, _click, click_fn, _fill, fill_fn, _hover, hover_fn, _scroll, scroll_fn;
var Locator = class extends EventEmitter {
  constructor() {
    super(...arguments);
    __privateAdd(this, _click);
    __privateAdd(this, _fill);
    __privateAdd(this, _hover);
    __privateAdd(this, _scroll);
    /**
     * @internal
     */
    __publicField(this, "visibility", null);
    /**
     * @internal
     */
    __publicField(this, "_timeout", 3e4);
    __privateAdd(this, _ensureElementIsInTheViewport, true);
    __privateAdd(this, _waitForEnabled, true);
    __privateAdd(this, _waitForStableBoundingBox, true);
    /**
     * @internal
     */
    __publicField(this, "operators", {
      conditions: (conditions, signal) => {
        return mergeMap((handle) => {
          return merge(...conditions.map((condition) => {
            return condition(handle, signal);
          })).pipe(defaultIfEmpty(handle));
        });
      },
      retryAndRaceWithSignalAndTimer: (signal, cause) => {
        const candidates = [];
        if (signal) {
          candidates.push(fromEvent(signal, "abort").pipe(map(() => {
            if (signal.reason instanceof Error) {
              signal.reason.cause = cause;
            }
            throw signal.reason;
          })));
        }
        candidates.push(timeout(this._timeout, cause));
        return pipe(retry({ delay: RETRY_DELAY }), raceWith(...candidates));
      }
    });
    /**
     * If the element has a "disabled" property, wait for the element to be
     * enabled.
     */
    __privateAdd(this, _waitForEnabledIfNeeded, (handle, signal) => {
      if (!__privateGet(this, _waitForEnabled)) {
        return EMPTY;
      }
      return from(handle.frame.waitForFunction((element) => {
        if (!(element instanceof HTMLElement)) {
          return true;
        }
        const isNativeFormControl = [
          "BUTTON",
          "INPUT",
          "SELECT",
          "TEXTAREA",
          "OPTION",
          "OPTGROUP"
        ].includes(element.nodeName);
        return !isNativeFormControl || !element.hasAttribute("disabled");
      }, {
        timeout: this._timeout,
        signal
      }, handle)).pipe(ignoreElements());
    });
    /**
     * Compares the bounding box of the element for two consecutive animation
     * frames and waits till they are the same.
     */
    __privateAdd(this, _waitForStableBoundingBoxIfNeeded, (handle) => {
      if (!__privateGet(this, _waitForStableBoundingBox)) {
        return EMPTY;
      }
      return defer(() => {
        return from(handle.evaluate((element) => {
          return new Promise((resolve) => {
            window.requestAnimationFrame(() => {
              const rect1 = element.getBoundingClientRect();
              window.requestAnimationFrame(() => {
                const rect2 = element.getBoundingClientRect();
                resolve([
                  {
                    x: rect1.x,
                    y: rect1.y,
                    width: rect1.width,
                    height: rect1.height
                  },
                  {
                    x: rect2.x,
                    y: rect2.y,
                    width: rect2.width,
                    height: rect2.height
                  }
                ]);
              });
            });
          });
        }));
      }).pipe(first(([rect1, rect2]) => {
        return rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;
      }), retry({ delay: RETRY_DELAY }), ignoreElements());
    });
    /**
     * Checks if the element is in the viewport and auto-scrolls it if it is not.
     */
    __privateAdd(this, _ensureElementIsInTheViewportIfNeeded, (handle) => {
      if (!__privateGet(this, _ensureElementIsInTheViewport)) {
        return EMPTY;
      }
      return from(handle.isIntersectingViewport({ threshold: 0 })).pipe(filter((isIntersectingViewport) => {
        return !isIntersectingViewport;
      }), mergeMap(() => {
        return from(handle.scrollIntoView());
      }), mergeMap(() => {
        return defer(() => {
          return from(handle.isIntersectingViewport({ threshold: 0 }));
        }).pipe(first(identity), retry({ delay: RETRY_DELAY }), ignoreElements());
      }));
    });
  }
  /**
   * Creates a race between multiple locators but ensures that only a single one
   * acts.
   *
   * @public
   */
  static race(locators) {
    return RaceLocator.create(locators);
  }
  // Determines when the locator will timeout for actions.
  get timeout() {
    return this._timeout;
  }
  setTimeout(timeout2) {
    const locator = this._clone();
    locator._timeout = timeout2;
    return locator;
  }
  setVisibility(visibility) {
    const locator = this._clone();
    locator.visibility = visibility;
    return locator;
  }
  setWaitForEnabled(value) {
    const locator = this._clone();
    __privateSet(locator, _waitForEnabled, value);
    return locator;
  }
  setEnsureElementIsInTheViewport(value) {
    const locator = this._clone();
    __privateSet(locator, _ensureElementIsInTheViewport, value);
    return locator;
  }
  setWaitForStableBoundingBox(value) {
    const locator = this._clone();
    __privateSet(locator, _waitForStableBoundingBox, value);
    return locator;
  }
  /**
   * @internal
   */
  copyOptions(locator) {
    this._timeout = locator._timeout;
    this.visibility = locator.visibility;
    __privateSet(this, _waitForEnabled, __privateGet(locator, _waitForEnabled));
    __privateSet(this, _ensureElementIsInTheViewport, __privateGet(locator, _ensureElementIsInTheViewport));
    __privateSet(this, _waitForStableBoundingBox, __privateGet(locator, _waitForStableBoundingBox));
    return this;
  }
  /**
   * Clones the locator.
   */
  clone() {
    return this._clone();
  }
  /**
   * Waits for the locator to get a handle from the page.
   *
   * @public
   */
  async waitHandle(options) {
    const cause = new Error("Locator.waitHandle");
    return await firstValueFrom(this._wait(options).pipe(this.operators.retryAndRaceWithSignalAndTimer(options == null ? void 0 : options.signal, cause)));
  }
  /**
   * Waits for the locator to get the serialized value from the page.
   *
   * Note this requires the value to be JSON-serializable.
   *
   * @public
   */
  async wait(options) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      const handle = __addDisposableResource5(env_1, await this.waitHandle(options), false);
      return await handle.jsonValue();
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources5(env_1);
    }
  }
  /**
   * Maps the locator using the provided mapper.
   *
   * @public
   */
  map(mapper) {
    return new MappedLocator(this._clone(), (handle) => {
      return handle.evaluateHandle(mapper);
    });
  }
  /**
   * Creates an expectation that is evaluated against located values.
   *
   * If the expectations do not match, then the locator will retry.
   *
   * @public
   */
  filter(predicate) {
    return new FilteredLocator(this._clone(), async (handle, signal) => {
      await handle.frame.waitForFunction(predicate, { signal, timeout: this._timeout }, handle);
      return true;
    });
  }
  /**
   * Creates an expectation that is evaluated against located handles.
   *
   * If the expectations do not match, then the locator will retry.
   *
   * @internal
   */
  filterHandle(predicate) {
    return new FilteredLocator(this._clone(), predicate);
  }
  /**
   * Maps the locator using the provided mapper.
   *
   * @internal
   */
  mapHandle(mapper) {
    return new MappedLocator(this._clone(), mapper);
  }
  click(options) {
    return firstValueFrom(__privateMethod(this, _click, click_fn).call(this, options));
  }
  /**
   * Fills out the input identified by the locator using the provided value. The
   * type of the input is determined at runtime and the appropriate fill-out
   * method is chosen based on the type. contenteditable, selector, inputs are
   * supported.
   */
  fill(value, options) {
    return firstValueFrom(__privateMethod(this, _fill, fill_fn).call(this, value, options));
  }
  hover(options) {
    return firstValueFrom(__privateMethod(this, _hover, hover_fn).call(this, options));
  }
  scroll(options) {
    return firstValueFrom(__privateMethod(this, _scroll, scroll_fn).call(this, options));
  }
};
_ensureElementIsInTheViewport = new WeakMap();
_waitForEnabled = new WeakMap();
_waitForStableBoundingBox = new WeakMap();
_waitForEnabledIfNeeded = new WeakMap();
_waitForStableBoundingBoxIfNeeded = new WeakMap();
_ensureElementIsInTheViewportIfNeeded = new WeakMap();
_click = new WeakSet();
click_fn = function(options) {
  const signal = options == null ? void 0 : options.signal;
  const cause = new Error("Locator.click");
  return this._wait(options).pipe(this.operators.conditions([
    __privateGet(this, _ensureElementIsInTheViewportIfNeeded),
    __privateGet(this, _waitForStableBoundingBoxIfNeeded),
    __privateGet(this, _waitForEnabledIfNeeded)
  ], signal), tap(() => {
    return this.emit(LocatorEvent.Action, void 0);
  }), mergeMap((handle) => {
    return from(handle.click(options)).pipe(catchError((err) => {
      void handle.dispose().catch(debugError);
      throw err;
    }));
  }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
};
_fill = new WeakSet();
fill_fn = function(value, options) {
  const signal = options == null ? void 0 : options.signal;
  const cause = new Error("Locator.fill");
  return this._wait(options).pipe(this.operators.conditions([
    __privateGet(this, _ensureElementIsInTheViewportIfNeeded),
    __privateGet(this, _waitForStableBoundingBoxIfNeeded),
    __privateGet(this, _waitForEnabledIfNeeded)
  ], signal), tap(() => {
    return this.emit(LocatorEvent.Action, void 0);
  }), mergeMap((handle) => {
    return from(handle.evaluate((el) => {
      if (el instanceof HTMLSelectElement) {
        return "select";
      }
      if (el instanceof HTMLTextAreaElement) {
        return "typeable-input";
      }
      if (el instanceof HTMLInputElement) {
        if ((/* @__PURE__ */ new Set([
          "textarea",
          "text",
          "url",
          "tel",
          "search",
          "password",
          "number",
          "email"
        ])).has(el.type)) {
          return "typeable-input";
        } else {
          return "other-input";
        }
      }
      if (el.isContentEditable) {
        return "contenteditable";
      }
      return "unknown";
    })).pipe(mergeMap((inputType) => {
      switch (inputType) {
        case "select":
          return from(handle.select(value).then(noop));
        case "contenteditable":
        case "typeable-input":
          return from(handle.evaluate((input, newValue) => {
            const currentValue = input.isContentEditable ? input.innerText : input.value;
            if (newValue.length <= currentValue.length || !newValue.startsWith(input.value)) {
              if (input.isContentEditable) {
                input.innerText = "";
              } else {
                input.value = "";
              }
              return newValue;
            }
            const originalValue = input.isContentEditable ? input.innerText : input.value;
            if (input.isContentEditable) {
              input.innerText = "";
              input.innerText = originalValue;
            } else {
              input.value = "";
              input.value = originalValue;
            }
            return newValue.substring(originalValue.length);
          }, value)).pipe(mergeMap((textToType) => {
            return from(handle.type(textToType));
          }));
        case "other-input":
          return from(handle.focus()).pipe(mergeMap(() => {
            return from(handle.evaluate((input, value2) => {
              input.value = value2;
              input.dispatchEvent(new Event("input", { bubbles: true }));
              input.dispatchEvent(new Event("change", { bubbles: true }));
            }, value));
          }));
        case "unknown":
          throw new Error(`Element cannot be filled out.`);
      }
    })).pipe(catchError((err) => {
      void handle.dispose().catch(debugError);
      throw err;
    }));
  }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
};
_hover = new WeakSet();
hover_fn = function(options) {
  const signal = options == null ? void 0 : options.signal;
  const cause = new Error("Locator.hover");
  return this._wait(options).pipe(this.operators.conditions([
    __privateGet(this, _ensureElementIsInTheViewportIfNeeded),
    __privateGet(this, _waitForStableBoundingBoxIfNeeded)
  ], signal), tap(() => {
    return this.emit(LocatorEvent.Action, void 0);
  }), mergeMap((handle) => {
    return from(handle.hover()).pipe(catchError((err) => {
      void handle.dispose().catch(debugError);
      throw err;
    }));
  }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
};
_scroll = new WeakSet();
scroll_fn = function(options) {
  const signal = options == null ? void 0 : options.signal;
  const cause = new Error("Locator.scroll");
  return this._wait(options).pipe(this.operators.conditions([
    __privateGet(this, _ensureElementIsInTheViewportIfNeeded),
    __privateGet(this, _waitForStableBoundingBoxIfNeeded)
  ], signal), tap(() => {
    return this.emit(LocatorEvent.Action, void 0);
  }), mergeMap((handle) => {
    return from(handle.evaluate((el, scrollTop, scrollLeft) => {
      if (scrollTop !== void 0) {
        el.scrollTop = scrollTop;
      }
      if (scrollLeft !== void 0) {
        el.scrollLeft = scrollLeft;
      }
    }, options == null ? void 0 : options.scrollTop, options == null ? void 0 : options.scrollLeft)).pipe(catchError((err) => {
      void handle.dispose().catch(debugError);
      throw err;
    }));
  }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
};
var _pageOrFrame, _func;
var _FunctionLocator = class _FunctionLocator extends Locator {
  constructor(pageOrFrame, func) {
    super();
    __privateAdd(this, _pageOrFrame, void 0);
    __privateAdd(this, _func, void 0);
    __privateSet(this, _pageOrFrame, pageOrFrame);
    __privateSet(this, _func, func);
  }
  static create(pageOrFrame, func) {
    return new _FunctionLocator(pageOrFrame, func).setTimeout("getDefaultTimeout" in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());
  }
  _clone() {
    return new _FunctionLocator(__privateGet(this, _pageOrFrame), __privateGet(this, _func));
  }
  _wait(options) {
    const signal = options == null ? void 0 : options.signal;
    return defer(() => {
      return from(__privateGet(this, _pageOrFrame).waitForFunction(__privateGet(this, _func), {
        timeout: this.timeout,
        signal
      }));
    }).pipe(throwIfEmpty());
  }
};
_pageOrFrame = new WeakMap();
_func = new WeakMap();
var FunctionLocator = _FunctionLocator;
var _delegate;
var DelegatedLocator = class extends Locator {
  constructor(delegate) {
    super();
    __privateAdd(this, _delegate, void 0);
    __privateSet(this, _delegate, delegate);
    this.copyOptions(__privateGet(this, _delegate));
  }
  get delegate() {
    return __privateGet(this, _delegate);
  }
  setTimeout(timeout2) {
    const locator = super.setTimeout(timeout2);
    __privateSet(locator, _delegate, __privateGet(this, _delegate).setTimeout(timeout2));
    return locator;
  }
  setVisibility(visibility) {
    const locator = super.setVisibility(visibility);
    __privateSet(locator, _delegate, __privateGet(locator, _delegate).setVisibility(visibility));
    return locator;
  }
  setWaitForEnabled(value) {
    const locator = super.setWaitForEnabled(value);
    __privateSet(locator, _delegate, __privateGet(this, _delegate).setWaitForEnabled(value));
    return locator;
  }
  setEnsureElementIsInTheViewport(value) {
    const locator = super.setEnsureElementIsInTheViewport(value);
    __privateSet(locator, _delegate, __privateGet(this, _delegate).setEnsureElementIsInTheViewport(value));
    return locator;
  }
  setWaitForStableBoundingBox(value) {
    const locator = super.setWaitForStableBoundingBox(value);
    __privateSet(locator, _delegate, __privateGet(this, _delegate).setWaitForStableBoundingBox(value));
    return locator;
  }
};
_delegate = new WeakMap();
var _predicate;
var _FilteredLocator = class _FilteredLocator extends DelegatedLocator {
  constructor(base, predicate) {
    super(base);
    __privateAdd(this, _predicate, void 0);
    __privateSet(this, _predicate, predicate);
  }
  _clone() {
    return new _FilteredLocator(this.delegate.clone(), __privateGet(this, _predicate)).copyOptions(this);
  }
  _wait(options) {
    return this.delegate._wait(options).pipe(mergeMap((handle) => {
      return from(Promise.resolve(__privateGet(this, _predicate).call(this, handle, options == null ? void 0 : options.signal))).pipe(filter((value) => {
        return value;
      }), map(() => {
        return handle;
      }));
    }), throwIfEmpty());
  }
};
_predicate = new WeakMap();
var FilteredLocator = _FilteredLocator;
var _mapper;
var _MappedLocator = class _MappedLocator extends DelegatedLocator {
  constructor(base, mapper) {
    super(base);
    __privateAdd(this, _mapper, void 0);
    __privateSet(this, _mapper, mapper);
  }
  _clone() {
    return new _MappedLocator(this.delegate.clone(), __privateGet(this, _mapper)).copyOptions(this);
  }
  _wait(options) {
    return this.delegate._wait(options).pipe(mergeMap((handle) => {
      return from(Promise.resolve(__privateGet(this, _mapper).call(this, handle, options == null ? void 0 : options.signal)));
    }));
  }
};
_mapper = new WeakMap();
var MappedLocator = _MappedLocator;
var _pageOrFrame2, _selector, _waitForVisibilityIfNeeded;
var _NodeLocator = class _NodeLocator extends Locator {
  constructor(pageOrFrame, selector) {
    super();
    __privateAdd(this, _pageOrFrame2, void 0);
    __privateAdd(this, _selector, void 0);
    /**
     * Waits for the element to become visible or hidden. visibility === 'visible'
     * means that the element has a computed style, the visibility property other
     * than 'hidden' or 'collapse' and non-empty bounding box. visibility ===
     * 'hidden' means the opposite of that.
     */
    __privateAdd(this, _waitForVisibilityIfNeeded, (handle) => {
      if (!this.visibility) {
        return EMPTY;
      }
      return (() => {
        switch (this.visibility) {
          case "hidden":
            return defer(() => {
              return from(handle.isHidden());
            });
          case "visible":
            return defer(() => {
              return from(handle.isVisible());
            });
        }
      })().pipe(first(identity), retry({ delay: RETRY_DELAY }), ignoreElements());
    });
    __privateSet(this, _pageOrFrame2, pageOrFrame);
    __privateSet(this, _selector, selector);
  }
  static create(pageOrFrame, selector) {
    return new _NodeLocator(pageOrFrame, selector).setTimeout("getDefaultTimeout" in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());
  }
  _clone() {
    return new _NodeLocator(__privateGet(this, _pageOrFrame2), __privateGet(this, _selector)).copyOptions(this);
  }
  _wait(options) {
    const signal = options == null ? void 0 : options.signal;
    return defer(() => {
      return from(__privateGet(this, _pageOrFrame2).waitForSelector(__privateGet(this, _selector), {
        visible: false,
        timeout: this._timeout,
        signal
      }));
    }).pipe(filter((value) => {
      return value !== null;
    }), throwIfEmpty(), this.operators.conditions([__privateGet(this, _waitForVisibilityIfNeeded)], signal));
  }
};
_pageOrFrame2 = new WeakMap();
_selector = new WeakMap();
_waitForVisibilityIfNeeded = new WeakMap();
var NodeLocator = _NodeLocator;
function checkLocatorArray(locators) {
  for (const locator of locators) {
    if (!(locator instanceof Locator)) {
      throw new Error("Unknown locator for race candidate");
    }
  }
  return locators;
}
var _locators;
var _RaceLocator = class _RaceLocator extends Locator {
  constructor(locators) {
    super();
    __privateAdd(this, _locators, void 0);
    __privateSet(this, _locators, locators);
  }
  static create(locators) {
    const array = checkLocatorArray(locators);
    return new _RaceLocator(array);
  }
  _clone() {
    return new _RaceLocator(__privateGet(this, _locators).map((locator) => {
      return locator.clone();
    })).copyOptions(this);
  }
  _wait(options) {
    return race(...__privateGet(this, _locators).map((locator) => {
      return locator._wait(options);
    }));
  }
};
_locators = new WeakMap();
var RaceLocator = _RaceLocator;
var RETRY_DELAY = 100;

// node_modules/puppeteer-core/lib/esm/puppeteer/api/Frame.js
var __runInitializers3 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate3 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn)
      context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access)
      context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.unshift(_);
      else
        descriptor[key] = _;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __addDisposableResource6 = function(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources6 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    function next() {
      while (env.stack.length) {
        var rec = env.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
        } catch (e) {
          fail(e);
        }
      }
      if (env.hasError)
        throw env.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var FrameEvent;
(function(FrameEvent2) {
  FrameEvent2.FrameNavigated = Symbol("Frame.FrameNavigated");
  FrameEvent2.FrameSwapped = Symbol("Frame.FrameSwapped");
  FrameEvent2.LifecycleEvent = Symbol("Frame.LifecycleEvent");
  FrameEvent2.FrameNavigatedWithinDocument = Symbol("Frame.FrameNavigatedWithinDocument");
  FrameEvent2.FrameDetached = Symbol("Frame.FrameDetached");
  FrameEvent2.FrameSwappedByActivation = Symbol("Frame.FrameSwappedByActivation");
})(FrameEvent || (FrameEvent = {}));
var throwIfDetached = throwIfDisposed((frame) => {
  return `Attempted to use detached Frame '${frame._id}'.`;
});
var Frame = (() => {
  var __document, _document, document_fn, _a;
  let _classSuper = EventEmitter;
  let _instanceExtraInitializers = [];
  let _frameElement_decorators;
  let _evaluateHandle_decorators;
  let _evaluate_decorators;
  let _locator_decorators;
  let _$_decorators;
  let _$$_decorators;
  let _$eval_decorators;
  let _$$eval_decorators;
  let _waitForSelector_decorators;
  let _waitForFunction_decorators;
  let _content_decorators;
  let _addScriptTag_decorators;
  let _addStyleTag_decorators;
  let _click_decorators;
  let _focus_decorators;
  let _hover_decorators;
  let _select_decorators;
  let _tap_decorators;
  let _type_decorators;
  let _title_decorators;
  return _a = class extends _classSuper {
    /**
     * @internal
     */
    constructor() {
      super();
      /**
       * @internal
       */
      __privateAdd(this, _document);
      /**
       * @internal
       */
      __publicField(this, "_id", (__runInitializers3(this, _instanceExtraInitializers), void 0));
      /**
       * @internal
       */
      __publicField(this, "_parentId");
      /**
       * @internal
       */
      __publicField(this, "_name");
      /**
       * @internal
       */
      __publicField(this, "_hasStartedLoading", false);
      __privateAdd(this, __document, void 0);
    }
    /**
     * Used to clear the document handle that has been destroyed.
     *
     * @internal
     */
    clearDocumentHandle() {
      __privateSet(this, __document, void 0);
    }
    /**
     * @returns The frame element associated with this frame (if any).
     */
    async frameElement() {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        const parentFrame = this.parentFrame();
        if (!parentFrame) {
          return null;
        }
        const list = __addDisposableResource6(env_1, await parentFrame.isolatedRealm().evaluateHandle(() => {
          return document.querySelectorAll("iframe,frame");
        }), false);
        for await (const iframe_1 of transposeIterableHandle(list)) {
          const env_2 = { stack: [], error: void 0, hasError: false };
          try {
            const iframe = __addDisposableResource6(env_2, iframe_1, false);
            const frame = await iframe.contentFrame();
            if ((frame == null ? void 0 : frame._id) === this._id) {
              return iframe.move();
            }
          } catch (e_1) {
            env_2.error = e_1;
            env_2.hasError = true;
          } finally {
            __disposeResources6(env_2);
          }
        }
        return null;
      } catch (e_2) {
        env_1.error = e_2;
        env_1.hasError = true;
      } finally {
        __disposeResources6(env_1);
      }
    }
    /**
     * Behaves identically to {@link Page.evaluateHandle} except it's run within
     * the context of this frame.
     *
     * @see {@link Page.evaluateHandle} for details.
     */
    async evaluateHandle(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
      return await this.mainRealm().evaluateHandle(pageFunction, ...args);
    }
    /**
     * Behaves identically to {@link Page.evaluate} except it's run within
     * the context of this frame.
     *
     * @see {@link Page.evaluate} for details.
     */
    async evaluate(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
      return await this.mainRealm().evaluate(pageFunction, ...args);
    }
    /**
     * @internal
     */
    locator(selectorOrFunc) {
      if (typeof selectorOrFunc === "string") {
        return NodeLocator.create(this, selectorOrFunc);
      } else {
        return FunctionLocator.create(this, selectorOrFunc);
      }
    }
    /**
     * Queries the frame for an element matching the given selector.
     *
     * @param selector - The selector to query for.
     * @returns A {@link ElementHandle | element handle} to the first element
     * matching the given selector. Otherwise, `null`.
     */
    async $(selector) {
      const document2 = await __privateMethod(this, _document, document_fn).call(this);
      return await document2.$(selector);
    }
    /**
     * Queries the frame for all elements matching the given selector.
     *
     * @param selector - The selector to query for.
     * @returns An array of {@link ElementHandle | element handles} that point to
     * elements matching the given selector.
     */
    async $$(selector) {
      const document2 = await __privateMethod(this, _document, document_fn).call(this);
      return await document2.$$(selector);
    }
    /**
     * Runs the given function on the first element matching the given selector in
     * the frame.
     *
     * If the given function returns a promise, then this method will wait till
     * the promise resolves.
     *
     * @example
     *
     * ```ts
     * const searchValue = await frame.$eval('#search', el => el.value);
     * ```
     *
     * @param selector - The selector to query for.
     * @param pageFunction - The function to be evaluated in the frame's context.
     * The first element matching the selector will be passed to the function as
     * its first argument.
     * @param args - Additional arguments to pass to `pageFunction`.
     * @returns A promise to the result of the function.
     */
    async $eval(selector, pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
      const document2 = await __privateMethod(this, _document, document_fn).call(this);
      return await document2.$eval(selector, pageFunction, ...args);
    }
    /**
     * Runs the given function on an array of elements matching the given selector
     * in the frame.
     *
     * If the given function returns a promise, then this method will wait till
     * the promise resolves.
     *
     * @example
     *
     * ```ts
     * const divsCounts = await frame.$$eval('div', divs => divs.length);
     * ```
     *
     * @param selector - The selector to query for.
     * @param pageFunction - The function to be evaluated in the frame's context.
     * An array of elements matching the given selector will be passed to the
     * function as its first argument.
     * @param args - Additional arguments to pass to `pageFunction`.
     * @returns A promise to the result of the function.
     */
    async $$eval(selector, pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
      const document2 = await __privateMethod(this, _document, document_fn).call(this);
      return await document2.$$eval(selector, pageFunction, ...args);
    }
    /**
     * Waits for an element matching the given selector to appear in the frame.
     *
     * This method works across navigations.
     *
     * @example
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     *
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   let currentURL;
     *   page
     *     .mainFrame()
     *     .waitForSelector('img')
     *     .then(() => console.log('First URL with image: ' + currentURL));
     *
     *   for (currentURL of [
     *     'https://example.com',
     *     'https://google.com',
     *     'https://bbc.com',
     *   ]) {
     *     await page.goto(currentURL);
     *   }
     *   await browser.close();
     * })();
     * ```
     *
     * @param selector - The selector to query and wait for.
     * @param options - Options for customizing waiting behavior.
     * @returns An element matching the given selector.
     * @throws Throws if an element matching the given selector doesn't appear.
     */
    async waitForSelector(selector, options = {}) {
      const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
      return await QueryHandler2.waitFor(this, updatedSelector, options);
    }
    /**
     * @example
     * The `waitForFunction` can be used to observe viewport size change:
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     *
     * (async () => {
     * .  const browser = await puppeteer.launch();
     * .  const page = await browser.newPage();
     * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');
     * .  page.setViewport({width: 50, height: 50});
     * .  await watchDog;
     * .  await browser.close();
     * })();
     * ```
     *
     * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:
     *
     * ```ts
     * const selector = '.foo';
     * await frame.waitForFunction(
     *   selector => !!document.querySelector(selector),
     *   {}, // empty options object
     *   selector
     * );
     * ```
     *
     * @param pageFunction - the function to evaluate in the frame context.
     * @param options - options to configure the polling method and timeout.
     * @param args - arguments to pass to the `pageFunction`.
     * @returns the promise which resolve when the `pageFunction` returns a truthy value.
     */
    async waitForFunction(pageFunction, options = {}, ...args) {
      return await this.mainRealm().waitForFunction(pageFunction, options, ...args);
    }
    /**
     * The full HTML contents of the frame, including the DOCTYPE.
     */
    async content() {
      return await this.evaluate(() => {
        let content = "";
        for (const node of document.childNodes) {
          switch (node) {
            case document.documentElement:
              content += document.documentElement.outerHTML;
              break;
            default:
              content += new XMLSerializer().serializeToString(node);
              break;
          }
        }
        return content;
      });
    }
    /**
     * @internal
     */
    async setFrameContent(content) {
      return await this.evaluate((html) => {
        document.open();
        document.write(html);
        document.close();
      }, content);
    }
    /**
     * The frame's `name` attribute as specified in the tag.
     *
     * @remarks
     * If the name is empty, it returns the `id` attribute instead.
     *
     * @remarks
     * This value is calculated once when the frame is created, and will not
     * update if the attribute is changed later.
     *
     * @deprecated Use
     *
     * ```ts
     * const element = await frame.frameElement();
     * const nameOrId = await element.evaluate(frame => frame.name ?? frame.id);
     * ```
     */
    name() {
      return this._name || "";
    }
    /**
     * Is`true` if the frame has been detached. Otherwise, `false`.
     *
     * @deprecated Use the `detached` getter.
     */
    isDetached() {
      return this.detached;
    }
    /**
     * @internal
     */
    get disposed() {
      return this.detached;
    }
    /**
     * Adds a `<script>` tag into the page with the desired url or content.
     *
     * @param options - Options for the script.
     * @returns An {@link ElementHandle | element handle} to the injected
     * `<script>` element.
     */
    async addScriptTag(options) {
      let { content = "", type } = options;
      const { path } = options;
      if (+!!options.url + +!!path + +!!content !== 1) {
        throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
      }
      if (path) {
        const fs = await importFSPromises();
        content = await fs.readFile(path, "utf8");
        content += `//# sourceURL=${path.replace(/\n/g, "")}`;
      }
      type = type ?? "text/javascript";
      return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ url, id, type: type2, content: content2 }) => {
        return await new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.type = type2;
          script.text = content2;
          script.addEventListener("error", (event) => {
            reject(new Error(event.message ?? "Could not load script"));
          }, { once: true });
          if (id) {
            script.id = id;
          }
          if (url) {
            script.src = url;
            script.addEventListener("load", () => {
              resolve(script);
            }, { once: true });
            document.head.appendChild(script);
          } else {
            document.head.appendChild(script);
            resolve(script);
          }
        });
      }, { ...options, type, content }));
    }
    /**
     * @internal
     */
    async addStyleTag(options) {
      let { content = "" } = options;
      const { path } = options;
      if (+!!options.url + +!!path + +!!content !== 1) {
        throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
      }
      if (path) {
        const fs = await importFSPromises();
        content = await fs.readFile(path, "utf8");
        content += "/*# sourceURL=" + path.replace(/\n/g, "") + "*/";
        options.content = content;
      }
      return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ url, content: content2 }) => {
        return await new Promise((resolve, reject) => {
          let element;
          if (!url) {
            element = document.createElement("style");
            element.appendChild(document.createTextNode(content2));
          } else {
            const link = document.createElement("link");
            link.rel = "stylesheet";
            link.href = url;
            element = link;
          }
          element.addEventListener("load", () => {
            resolve(element);
          }, { once: true });
          element.addEventListener("error", (event) => {
            reject(new Error(event.message ?? "Could not load style"));
          }, { once: true });
          document.head.appendChild(element);
          return element;
        });
      }, options));
    }
    /**
     * Clicks the first element found that matches `selector`.
     *
     * @remarks
     * If `click()` triggers a navigation event and there's a separate
     * `page.waitForNavigation()` promise to be resolved, you may end up with a
     * race condition that yields unexpected results. The correct pattern for
     * click and wait for navigation is the following:
     *
     * ```ts
     * const [response] = await Promise.all([
     *   page.waitForNavigation(waitOptions),
     *   frame.click(selector, clickOptions),
     * ]);
     * ```
     *
     * @param selector - The selector to query for.
     */
    async click(selector, options = {}) {
      const env_3 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource6(env_3, await this.$(selector), false);
        assert(handle, `No element found for selector: ${selector}`);
        await handle.click(options);
        await handle.dispose();
      } catch (e_3) {
        env_3.error = e_3;
        env_3.hasError = true;
      } finally {
        __disposeResources6(env_3);
      }
    }
    /**
     * Focuses the first element that matches the `selector`.
     *
     * @param selector - The selector to query for.
     * @throws Throws if there's no element matching `selector`.
     */
    async focus(selector) {
      const env_4 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource6(env_4, await this.$(selector), false);
        assert(handle, `No element found for selector: ${selector}`);
        await handle.focus();
      } catch (e_4) {
        env_4.error = e_4;
        env_4.hasError = true;
      } finally {
        __disposeResources6(env_4);
      }
    }
    /**
     * Hovers the pointer over the center of the first element that matches the
     * `selector`.
     *
     * @param selector - The selector to query for.
     * @throws Throws if there's no element matching `selector`.
     */
    async hover(selector) {
      const env_5 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource6(env_5, await this.$(selector), false);
        assert(handle, `No element found for selector: ${selector}`);
        await handle.hover();
      } catch (e_5) {
        env_5.error = e_5;
        env_5.hasError = true;
      } finally {
        __disposeResources6(env_5);
      }
    }
    /**
     * Selects a set of value on the first `<select>` element that matches the
     * `selector`.
     *
     * @example
     *
     * ```ts
     * frame.select('select#colors', 'blue'); // single selection
     * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections
     * ```
     *
     * @param selector - The selector to query for.
     * @param values - The array of values to select. If the `<select>` has the
     * `multiple` attribute, all values are considered, otherwise only the first
     * one is taken into account.
     * @returns the list of values that were successfully selected.
     * @throws Throws if there's no `<select>` matching `selector`.
     */
    async select(selector, ...values) {
      const env_6 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource6(env_6, await this.$(selector), false);
        assert(handle, `No element found for selector: ${selector}`);
        return await handle.select(...values);
      } catch (e_6) {
        env_6.error = e_6;
        env_6.hasError = true;
      } finally {
        __disposeResources6(env_6);
      }
    }
    /**
     * Taps the first element that matches the `selector`.
     *
     * @param selector - The selector to query for.
     * @throws Throws if there's no element matching `selector`.
     */
    async tap(selector) {
      const env_7 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource6(env_7, await this.$(selector), false);
        assert(handle, `No element found for selector: ${selector}`);
        await handle.tap();
      } catch (e_7) {
        env_7.error = e_7;
        env_7.hasError = true;
      } finally {
        __disposeResources6(env_7);
      }
    }
    /**
     * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character
     * in the text.
     *
     * @remarks
     * To press a special key, like `Control` or `ArrowDown`, use
     * {@link Keyboard.press}.
     *
     * @example
     *
     * ```ts
     * await frame.type('#mytextarea', 'Hello'); // Types instantly
     * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user
     * ```
     *
     * @param selector - the selector for the element to type into. If there are
     * multiple the first will be used.
     * @param text - text to type into the element
     * @param options - takes one option, `delay`, which sets the time to wait
     * between key presses in milliseconds. Defaults to `0`.
     */
    async type(selector, text, options) {
      const env_8 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource6(env_8, await this.$(selector), false);
        assert(handle, `No element found for selector: ${selector}`);
        await handle.type(text, options);
      } catch (e_8) {
        env_8.error = e_8;
        env_8.hasError = true;
      } finally {
        __disposeResources6(env_8);
      }
    }
    /**
     * The frame's title.
     */
    async title() {
      return await this.isolatedRealm().evaluate(() => {
        return document.title;
      });
    }
  }, __document = new WeakMap(), _document = new WeakSet(), document_fn = function() {
    if (!__privateGet(this, __document)) {
      __privateSet(this, __document, this.isolatedRealm().evaluateHandle(() => {
        return document;
      }).then((handle) => {
        return this.mainRealm().transferHandle(handle);
      }));
    }
    return __privateGet(this, __document);
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _frameElement_decorators = [throwIfDetached];
    _evaluateHandle_decorators = [throwIfDetached];
    _evaluate_decorators = [throwIfDetached];
    _locator_decorators = [throwIfDetached];
    _$_decorators = [throwIfDetached];
    _$$_decorators = [throwIfDetached];
    _$eval_decorators = [throwIfDetached];
    _$$eval_decorators = [throwIfDetached];
    _waitForSelector_decorators = [throwIfDetached];
    _waitForFunction_decorators = [throwIfDetached];
    _content_decorators = [throwIfDetached];
    _addScriptTag_decorators = [throwIfDetached];
    _addStyleTag_decorators = [throwIfDetached];
    _click_decorators = [throwIfDetached];
    _focus_decorators = [throwIfDetached];
    _hover_decorators = [throwIfDetached];
    _select_decorators = [throwIfDetached];
    _tap_decorators = [throwIfDetached];
    _type_decorators = [throwIfDetached];
    _title_decorators = [throwIfDetached];
    __esDecorate3(_a, null, _frameElement_decorators, { kind: "method", name: "frameElement", static: false, private: false, access: { has: (obj) => "frameElement" in obj, get: (obj) => obj.frameElement }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_a, null, _evaluateHandle_decorators, { kind: "method", name: "evaluateHandle", static: false, private: false, access: { has: (obj) => "evaluateHandle" in obj, get: (obj) => obj.evaluateHandle }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_a, null, _evaluate_decorators, { kind: "method", name: "evaluate", static: false, private: false, access: { has: (obj) => "evaluate" in obj, get: (obj) => obj.evaluate }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_a, null, _locator_decorators, { kind: "method", name: "locator", static: false, private: false, access: { has: (obj) => "locator" in obj, get: (obj) => obj.locator }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_a, null, _$_decorators, { kind: "method", name: "$", static: false, private: false, access: { has: (obj) => "$" in obj, get: (obj) => obj.$ }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_a, null, _$$_decorators, { kind: "method", name: "$$", static: false, private: false, access: { has: (obj) => "$$" in obj, get: (obj) => obj.$$ }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_a, null, _$eval_decorators, { kind: "method", name: "$eval", static: false, private: false, access: { has: (obj) => "$eval" in obj, get: (obj) => obj.$eval }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_a, null, _$$eval_decorators, { kind: "method", name: "$$eval", static: false, private: false, access: { has: (obj) => "$$eval" in obj, get: (obj) => obj.$$eval }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_a, null, _waitForSelector_decorators, { kind: "method", name: "waitForSelector", static: false, private: false, access: { has: (obj) => "waitForSelector" in obj, get: (obj) => obj.waitForSelector }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_a, null, _waitForFunction_decorators, { kind: "method", name: "waitForFunction", static: false, private: false, access: { has: (obj) => "waitForFunction" in obj, get: (obj) => obj.waitForFunction }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_a, null, _content_decorators, { kind: "method", name: "content", static: false, private: false, access: { has: (obj) => "content" in obj, get: (obj) => obj.content }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_a, null, _addScriptTag_decorators, { kind: "method", name: "addScriptTag", static: false, private: false, access: { has: (obj) => "addScriptTag" in obj, get: (obj) => obj.addScriptTag }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_a, null, _addStyleTag_decorators, { kind: "method", name: "addStyleTag", static: false, private: false, access: { has: (obj) => "addStyleTag" in obj, get: (obj) => obj.addStyleTag }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_a, null, _click_decorators, { kind: "method", name: "click", static: false, private: false, access: { has: (obj) => "click" in obj, get: (obj) => obj.click }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_a, null, _focus_decorators, { kind: "method", name: "focus", static: false, private: false, access: { has: (obj) => "focus" in obj, get: (obj) => obj.focus }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_a, null, _hover_decorators, { kind: "method", name: "hover", static: false, private: false, access: { has: (obj) => "hover" in obj, get: (obj) => obj.hover }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_a, null, _select_decorators, { kind: "method", name: "select", static: false, private: false, access: { has: (obj) => "select" in obj, get: (obj) => obj.select }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_a, null, _tap_decorators, { kind: "method", name: "tap", static: false, private: false, access: { has: (obj) => "tap" in obj, get: (obj) => obj.tap }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_a, null, _type_decorators, { kind: "method", name: "type", static: false, private: false, access: { has: (obj) => "type" in obj, get: (obj) => obj.type }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate3(_a, null, _title_decorators, { kind: "method", name: "title", static: false, private: false, access: { has: (obj) => "title" in obj, get: (obj) => obj.title }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata)
      Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a;
})();

// node_modules/puppeteer-core/lib/esm/puppeteer/api/HTTPRequest.js
var DEFAULT_INTERCEPT_RESOLUTION_PRIORITY = 0;
var HTTPRequest = class {
  /**
   * @internal
   */
  constructor() {
    /**
     * @internal
     */
    __publicField(this, "_interceptionId");
    /**
     * @internal
     */
    __publicField(this, "_failureText", null);
    /**
     * @internal
     */
    __publicField(this, "_response", null);
    /**
     * @internal
     */
    __publicField(this, "_fromMemoryCache", false);
    /**
     * @internal
     */
    __publicField(this, "_redirectChain", []);
    /**
     * @internal
     */
    __publicField(this, "interception", {
      enabled: false,
      handled: false,
      handlers: [],
      resolutionState: {
        action: InterceptResolutionAction.None
      },
      requestOverrides: {},
      response: null,
      abortReason: null
    });
  }
  /**
   * The `ContinueRequestOverrides` that will be used
   * if the interception is allowed to continue (ie, `abort()` and
   * `respond()` aren't called).
   */
  continueRequestOverrides() {
    assert(this.interception.enabled, "Request Interception is not enabled!");
    return this.interception.requestOverrides;
  }
  /**
   * The `ResponseForRequest` that gets used if the
   * interception is allowed to respond (ie, `abort()` is not called).
   */
  responseForRequest() {
    assert(this.interception.enabled, "Request Interception is not enabled!");
    return this.interception.response;
  }
  /**
   * The most recent reason for aborting the request
   */
  abortErrorReason() {
    assert(this.interception.enabled, "Request Interception is not enabled!");
    return this.interception.abortReason;
  }
  /**
   * An InterceptResolutionState object describing the current resolution
   * action and priority.
   *
   * InterceptResolutionState contains:
   * action: InterceptResolutionAction
   * priority?: number
   *
   * InterceptResolutionAction is one of: `abort`, `respond`, `continue`,
   * `disabled`, `none`, or `already-handled`.
   */
  interceptResolutionState() {
    if (!this.interception.enabled) {
      return { action: InterceptResolutionAction.Disabled };
    }
    if (this.interception.handled) {
      return { action: InterceptResolutionAction.AlreadyHandled };
    }
    return { ...this.interception.resolutionState };
  }
  /**
   * Is `true` if the intercept resolution has already been handled,
   * `false` otherwise.
   */
  isInterceptResolutionHandled() {
    return this.interception.handled;
  }
  /**
   * Adds an async request handler to the processing queue.
   * Deferred handlers are not guaranteed to execute in any particular order,
   * but they are guaranteed to resolve before the request interception
   * is finalized.
   */
  enqueueInterceptAction(pendingHandler) {
    this.interception.handlers.push(pendingHandler);
  }
  /**
   * Awaits pending interception handlers and then decides how to fulfill
   * the request interception.
   */
  async finalizeInterceptions() {
    await this.interception.handlers.reduce((promiseChain, interceptAction) => {
      return promiseChain.then(interceptAction);
    }, Promise.resolve());
    this.interception.handlers = [];
    const { action } = this.interceptResolutionState();
    switch (action) {
      case "abort":
        return await this._abort(this.interception.abortReason);
      case "respond":
        if (this.interception.response === null) {
          throw new Error("Response is missing for the interception");
        }
        return await this._respond(this.interception.response);
      case "continue":
        return await this._continue(this.interception.requestOverrides);
    }
  }
  /**
   * Continues request with optional request overrides.
   *
   * @example
   *
   * ```ts
   * await page.setRequestInterception(true);
   * page.on('request', request => {
   *   // Override headers
   *   const headers = Object.assign({}, request.headers(), {
   *     foo: 'bar', // set "foo" header
   *     origin: undefined, // remove "origin" header
   *   });
   *   request.continue({headers});
   * });
   * ```
   *
   * @param overrides - optional overrides to apply to the request.
   * @param priority - If provided, intercept is resolved using cooperative
   * handling rules. Otherwise, intercept is resolved immediately.
   *
   * @remarks
   *
   * To use this, request interception should be enabled with
   * {@link Page.setRequestInterception}.
   *
   * Exception is immediately thrown if the request interception is not enabled.
   */
  async continue(overrides = {}, priority) {
    if (this.url().startsWith("data:")) {
      return;
    }
    assert(this.interception.enabled, "Request Interception is not enabled!");
    assert(!this.interception.handled, "Request is already handled!");
    if (priority === void 0) {
      return await this._continue(overrides);
    }
    this.interception.requestOverrides = overrides;
    if (this.interception.resolutionState.priority === void 0 || priority > this.interception.resolutionState.priority) {
      this.interception.resolutionState = {
        action: InterceptResolutionAction.Continue,
        priority
      };
      return;
    }
    if (priority === this.interception.resolutionState.priority) {
      if (this.interception.resolutionState.action === "abort" || this.interception.resolutionState.action === "respond") {
        return;
      }
      this.interception.resolutionState.action = InterceptResolutionAction.Continue;
    }
    return;
  }
  /**
   * Fulfills a request with the given response.
   *
   * @example
   * An example of fulfilling all requests with 404 responses:
   *
   * ```ts
   * await page.setRequestInterception(true);
   * page.on('request', request => {
   *   request.respond({
   *     status: 404,
   *     contentType: 'text/plain',
   *     body: 'Not Found!',
   *   });
   * });
   * ```
   *
   * NOTE: Mocking responses for dataURL requests is not supported.
   * Calling `request.respond` for a dataURL request is a noop.
   *
   * @param response - the response to fulfill the request with.
   * @param priority - If provided, intercept is resolved using
   * cooperative handling rules. Otherwise, intercept is resolved
   * immediately.
   *
   * @remarks
   *
   * To use this, request
   * interception should be enabled with {@link Page.setRequestInterception}.
   *
   * Exception is immediately thrown if the request interception is not enabled.
   */
  async respond(response, priority) {
    if (this.url().startsWith("data:")) {
      return;
    }
    assert(this.interception.enabled, "Request Interception is not enabled!");
    assert(!this.interception.handled, "Request is already handled!");
    if (priority === void 0) {
      return await this._respond(response);
    }
    this.interception.response = response;
    if (this.interception.resolutionState.priority === void 0 || priority > this.interception.resolutionState.priority) {
      this.interception.resolutionState = {
        action: InterceptResolutionAction.Respond,
        priority
      };
      return;
    }
    if (priority === this.interception.resolutionState.priority) {
      if (this.interception.resolutionState.action === "abort") {
        return;
      }
      this.interception.resolutionState.action = InterceptResolutionAction.Respond;
    }
  }
  /**
   * Aborts a request.
   *
   * @param errorCode - optional error code to provide.
   * @param priority - If provided, intercept is resolved using
   * cooperative handling rules. Otherwise, intercept is resolved
   * immediately.
   *
   * @remarks
   *
   * To use this, request interception should be enabled with
   * {@link Page.setRequestInterception}. If it is not enabled, this method will
   * throw an exception immediately.
   */
  async abort(errorCode = "failed", priority) {
    if (this.url().startsWith("data:")) {
      return;
    }
    const errorReason = errorReasons[errorCode];
    assert(errorReason, "Unknown error code: " + errorCode);
    assert(this.interception.enabled, "Request Interception is not enabled!");
    assert(!this.interception.handled, "Request is already handled!");
    if (priority === void 0) {
      return await this._abort(errorReason);
    }
    this.interception.abortReason = errorReason;
    if (this.interception.resolutionState.priority === void 0 || priority >= this.interception.resolutionState.priority) {
      this.interception.resolutionState = {
        action: InterceptResolutionAction.Abort,
        priority
      };
      return;
    }
  }
};
var InterceptResolutionAction;
(function(InterceptResolutionAction2) {
  InterceptResolutionAction2["Abort"] = "abort";
  InterceptResolutionAction2["Respond"] = "respond";
  InterceptResolutionAction2["Continue"] = "continue";
  InterceptResolutionAction2["Disabled"] = "disabled";
  InterceptResolutionAction2["None"] = "none";
  InterceptResolutionAction2["AlreadyHandled"] = "already-handled";
})(InterceptResolutionAction || (InterceptResolutionAction = {}));
function headersArray(headers) {
  const result = [];
  for (const name in headers) {
    const value = headers[name];
    if (!Object.is(value, void 0)) {
      const values = Array.isArray(value) ? value : [value];
      result.push(...values.map((value2) => {
        return { name, value: value2 + "" };
      }));
    }
  }
  return result;
}
var STATUS_TEXTS = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "306": "Switch Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
var errorReasons = {
  aborted: "Aborted",
  accessdenied: "AccessDenied",
  addressunreachable: "AddressUnreachable",
  blockedbyclient: "BlockedByClient",
  blockedbyresponse: "BlockedByResponse",
  connectionaborted: "ConnectionAborted",
  connectionclosed: "ConnectionClosed",
  connectionfailed: "ConnectionFailed",
  connectionrefused: "ConnectionRefused",
  connectionreset: "ConnectionReset",
  internetdisconnected: "InternetDisconnected",
  namenotresolved: "NameNotResolved",
  timedout: "TimedOut",
  failed: "Failed"
};
function handleError(error) {
  if (error.originalMessage.includes("Invalid header")) {
    throw error;
  }
  debugError(error);
}

// node_modules/puppeteer-core/lib/esm/puppeteer/api/HTTPResponse.js
var HTTPResponse = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * True if the response was successful (status in the range 200-299).
   */
  ok() {
    const status = this.status();
    return status === 0 || status >= 200 && status <= 299;
  }
  /**
   * Promise which resolves to a text (utf8) representation of response body.
   */
  async text() {
    const content = await this.buffer();
    return content.toString("utf8");
  }
  /**
   * Promise which resolves to a JSON representation of response body.
   *
   * @remarks
   *
   * This method will throw if the response body is not parsable via
   * `JSON.parse`.
   */
  async json() {
    const content = await this.text();
    return JSON.parse(content);
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/api/Input.js
var Keyboard = class {
  /**
   * @internal
   */
  constructor() {
  }
};
var MouseButton = Object.freeze({
  Left: "left",
  Right: "right",
  Middle: "middle",
  Back: "back",
  Forward: "forward"
});
var Mouse = class {
  /**
   * @internal
   */
  constructor() {
  }
};
var Touchscreen = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Dispatches a `touchstart` and `touchend` event.
   * @param x - Horizontal position of the tap.
   * @param y - Vertical position of the tap.
   */
  async tap(x, y) {
    await this.touchStart(x, y);
    await this.touchEnd();
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/TimeoutSettings.js
var DEFAULT_TIMEOUT = 3e4;
var _defaultTimeout, _defaultNavigationTimeout;
var TimeoutSettings = class {
  constructor() {
    __privateAdd(this, _defaultTimeout, void 0);
    __privateAdd(this, _defaultNavigationTimeout, void 0);
    __privateSet(this, _defaultTimeout, null);
    __privateSet(this, _defaultNavigationTimeout, null);
  }
  setDefaultTimeout(timeout2) {
    __privateSet(this, _defaultTimeout, timeout2);
  }
  setDefaultNavigationTimeout(timeout2) {
    __privateSet(this, _defaultNavigationTimeout, timeout2);
  }
  navigationTimeout() {
    if (__privateGet(this, _defaultNavigationTimeout) !== null) {
      return __privateGet(this, _defaultNavigationTimeout);
    }
    if (__privateGet(this, _defaultTimeout) !== null) {
      return __privateGet(this, _defaultTimeout);
    }
    return DEFAULT_TIMEOUT;
  }
  timeout() {
    if (__privateGet(this, _defaultTimeout) !== null) {
      return __privateGet(this, _defaultTimeout);
    }
    return DEFAULT_TIMEOUT;
  }
};
_defaultTimeout = new WeakMap();
_defaultNavigationTimeout = new WeakMap();

// node_modules/puppeteer-core/lib/esm/puppeteer/api/Page.js
var __runInitializers4 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate4 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn)
      context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access)
      context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.unshift(_);
      else
        descriptor[key] = _;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __addDisposableResource7 = function(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources7 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    function next() {
      while (env.stack.length) {
        var rec = env.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
        } catch (e) {
          fail(e);
        }
      }
      if (env.hasError)
        throw env.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
function setDefaultScreenshotOptions(options) {
  options.optimizeForSpeed ?? (options.optimizeForSpeed = false);
  options.type ?? (options.type = "png");
  options.fromSurface ?? (options.fromSurface = true);
  options.fullPage ?? (options.fullPage = false);
  options.omitBackground ?? (options.omitBackground = false);
  options.encoding ?? (options.encoding = "binary");
  options.captureBeyondViewport ?? (options.captureBeyondViewport = true);
}
var Page = (() => {
  var _requestHandlers, _inflight$, _screencastSessionCount, _startScreencastPromise, _getNativePixelDimensions, getNativePixelDimensions_fn, _a;
  let _classSuper = EventEmitter;
  let _instanceExtraInitializers = [];
  let _screenshot_decorators;
  return _a = class extends _classSuper {
    /**
     * @internal
     */
    constructor() {
      super();
      /**
       * Gets the native, non-emulated dimensions of the viewport.
       */
      __privateAdd(this, _getNativePixelDimensions);
      /**
       * @internal
       */
      __publicField(this, "_isDragging", (__runInitializers4(this, _instanceExtraInitializers), false));
      /**
       * @internal
       */
      __publicField(this, "_timeoutSettings", new TimeoutSettings());
      __privateAdd(this, _requestHandlers, /* @__PURE__ */ new WeakMap());
      __privateAdd(this, _inflight$, new ReplaySubject(1));
      __privateAdd(this, _screencastSessionCount, 0);
      __privateAdd(this, _startScreencastPromise, void 0);
      fromEmitterEvent(
        this,
        "request"
        /* PageEvent.Request */
      ).pipe(mergeMap((originalRequest) => {
        return concat(of(1), merge(fromEmitterEvent(
          this,
          "requestfailed"
          /* PageEvent.RequestFailed */
        ), fromEmitterEvent(
          this,
          "requestfinished"
          /* PageEvent.RequestFinished */
        ), fromEmitterEvent(
          this,
          "response"
          /* PageEvent.Response */
        ).pipe(map((response) => {
          return response.request();
        }))).pipe(filter((request) => {
          return request.id === originalRequest.id;
        }), take(1), map(() => {
          return -1;
        })));
      }), mergeScan((acc, addend) => {
        return of(acc + addend);
      }, 0), takeUntil(fromEmitterEvent(
        this,
        "close"
        /* PageEvent.Close */
      )), startWith(0)).subscribe(__privateGet(this, _inflight$));
    }
    /**
     * Listen to page events.
     *
     * @remarks
     * This method exists to define event typings and handle proper wireup of
     * cooperative request interception. Actual event listening and dispatching is
     * delegated to {@link EventEmitter}.
     *
     * @internal
     */
    on(type, handler) {
      if (type !== "request") {
        return super.on(type, handler);
      }
      let wrapper = __privateGet(this, _requestHandlers).get(handler);
      if (wrapper === void 0) {
        wrapper = (event) => {
          event.enqueueInterceptAction(() => {
            return handler(event);
          });
        };
        __privateGet(this, _requestHandlers).set(handler, wrapper);
      }
      return super.on(type, wrapper);
    }
    /**
     * @internal
     */
    off(type, handler) {
      if (type === "request") {
        handler = __privateGet(this, _requestHandlers).get(handler) || handler;
      }
      return super.off(type, handler);
    }
    locator(selectorOrFunc) {
      if (typeof selectorOrFunc === "string") {
        return NodeLocator.create(this, selectorOrFunc);
      } else {
        return FunctionLocator.create(this, selectorOrFunc);
      }
    }
    /**
     * A shortcut for {@link Locator.race} that does not require static imports.
     *
     * @internal
     */
    locatorRace(locators) {
      return Locator.race(locators);
    }
    /**
     * Runs `document.querySelector` within the page. If no element matches the
     * selector, the return value resolves to `null`.
     *
     * @param selector - A `selector` to query page for
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * to query page for.
     */
    async $(selector) {
      return await this.mainFrame().$(selector);
    }
    /**
     * The method runs `document.querySelectorAll` within the page. If no elements
     * match the selector, the return value resolves to `[]`.
     *
     * @param selector - A `selector` to query page for
     *
     * @remarks
     *
     * Shortcut for {@link Frame.$$ | Page.mainFrame().$$(selector) }.
     */
    async $$(selector) {
      return await this.mainFrame().$$(selector);
    }
    /**
     * @remarks
     *
     * The only difference between {@link Page.evaluate | page.evaluate} and
     * `page.evaluateHandle` is that `evaluateHandle` will return the value
     * wrapped in an in-page object.
     *
     * If the function passed to `page.evaluateHandle` returns a Promise, the
     * function will wait for the promise to resolve and return its value.
     *
     * You can pass a string instead of a function (although functions are
     * recommended as they are easier to debug and use with TypeScript):
     *
     * @example
     *
     * ```ts
     * const aHandle = await page.evaluateHandle('document');
     * ```
     *
     * @example
     * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:
     *
     * ```ts
     * const aHandle = await page.evaluateHandle(() => document.body);
     * const resultHandle = await page.evaluateHandle(
     *   body => body.innerHTML,
     *   aHandle
     * );
     * console.log(await resultHandle.jsonValue());
     * await resultHandle.dispose();
     * ```
     *
     * Most of the time this function returns a {@link JSHandle},
     * but if `pageFunction` returns a reference to an element,
     * you instead get an {@link ElementHandle} back:
     *
     * @example
     *
     * ```ts
     * const button = await page.evaluateHandle(() =>
     *   document.querySelector('button')
     * );
     * // can call `click` because `button` is an `ElementHandle`
     * await button.click();
     * ```
     *
     * The TypeScript definitions assume that `evaluateHandle` returns
     * a `JSHandle`, but if you know it's going to return an
     * `ElementHandle`, pass it as the generic argument:
     *
     * ```ts
     * const button = await page.evaluateHandle<ElementHandle>(...);
     * ```
     *
     * @param pageFunction - a function that is run within the page
     * @param args - arguments to be passed to the pageFunction
     */
    async evaluateHandle(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
      return await this.mainFrame().evaluateHandle(pageFunction, ...args);
    }
    /**
     * This method runs `document.querySelector` within the page and passes the
     * result as the first argument to the `pageFunction`.
     *
     * @remarks
     *
     * If no element is found matching `selector`, the method will throw an error.
     *
     * If `pageFunction` returns a promise `$eval` will wait for the promise to
     * resolve and then return its value.
     *
     * @example
     *
     * ```ts
     * const searchValue = await page.$eval('#search', el => el.value);
     * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);
     * const html = await page.$eval('.main-container', el => el.outerHTML);
     * ```
     *
     * If you are using TypeScript, you may have to provide an explicit type to the
     * first argument of the `pageFunction`.
     * By default it is typed as `Element`, but you may need to provide a more
     * specific sub-type:
     *
     * @example
     *
     * ```ts
     * // if you don't provide HTMLInputElement here, TS will error
     * // as `value` is not on `Element`
     * const searchValue = await page.$eval(
     *   '#search',
     *   (el: HTMLInputElement) => el.value
     * );
     * ```
     *
     * The compiler should be able to infer the return type
     * from the `pageFunction` you provide. If it is unable to, you can use the generic
     * type to tell the compiler what return type you expect from `$eval`:
     *
     * @example
     *
     * ```ts
     * // The compiler can infer the return type in this case, but if it can't
     * // or if you want to be more explicit, provide it as the generic type.
     * const searchValue = await page.$eval<string>(
     *   '#search',
     *   (el: HTMLInputElement) => el.value
     * );
     * ```
     *
     * @param selector - the
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * to query for
     * @param pageFunction - the function to be evaluated in the page context.
     * Will be passed the result of `document.querySelector(selector)` as its
     * first argument.
     * @param args - any additional arguments to pass through to `pageFunction`.
     *
     * @returns The result of calling `pageFunction`. If it returns an element it
     * is wrapped in an {@link ElementHandle}, else the raw value itself is
     * returned.
     */
    async $eval(selector, pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
      return await this.mainFrame().$eval(selector, pageFunction, ...args);
    }
    /**
     * This method runs `Array.from(document.querySelectorAll(selector))` within
     * the page and passes the result as the first argument to the `pageFunction`.
     *
     * @remarks
     * If `pageFunction` returns a promise `$$eval` will wait for the promise to
     * resolve and then return its value.
     *
     * @example
     *
     * ```ts
     * // get the amount of divs on the page
     * const divCount = await page.$$eval('div', divs => divs.length);
     *
     * // get the text content of all the `.options` elements:
     * const options = await page.$$eval('div > span.options', options => {
     *   return options.map(option => option.textContent);
     * });
     * ```
     *
     * If you are using TypeScript, you may have to provide an explicit type to the
     * first argument of the `pageFunction`.
     * By default it is typed as `Element[]`, but you may need to provide a more
     * specific sub-type:
     *
     * @example
     *
     * ```ts
     * await page.$$eval('input', elements => {
     *   return elements.map(e => e.value);
     * });
     * ```
     *
     * The compiler should be able to infer the return type
     * from the `pageFunction` you provide. If it is unable to, you can use the generic
     * type to tell the compiler what return type you expect from `$$eval`:
     *
     * @example
     *
     * ```ts
     * const allInputValues = await page.$$eval('input', elements =>
     *   elements.map(e => e.textContent)
     * );
     * ```
     *
     * @param selector - the
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * to query for
     * @param pageFunction - the function to be evaluated in the page context.
     * Will be passed the result of
     * `Array.from(document.querySelectorAll(selector))` as its first argument.
     * @param args - any additional arguments to pass through to `pageFunction`.
     *
     * @returns The result of calling `pageFunction`. If it returns an element it
     * is wrapped in an {@link ElementHandle}, else the raw value itself is
     * returned.
     */
    async $$eval(selector, pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
      return await this.mainFrame().$$eval(selector, pageFunction, ...args);
    }
    /**
     * Adds a `<script>` tag into the page with the desired URL or content.
     *
     * @remarks
     * Shortcut for
     * {@link Frame.addScriptTag | page.mainFrame().addScriptTag(options)}.
     *
     * @param options - Options for the script.
     * @returns An {@link ElementHandle | element handle} to the injected
     * `<script>` element.
     */
    async addScriptTag(options) {
      return await this.mainFrame().addScriptTag(options);
    }
    async addStyleTag(options) {
      return await this.mainFrame().addStyleTag(options);
    }
    /**
     * The page's URL.
     *
     * @remarks
     *
     * Shortcut for {@link Frame.url | page.mainFrame().url()}.
     */
    url() {
      return this.mainFrame().url();
    }
    /**
     * The full HTML contents of the page, including the DOCTYPE.
     */
    async content() {
      return await this.mainFrame().content();
    }
    /**
     * Set the content of the page.
     *
     * @param html - HTML markup to assign to the page.
     * @param options - Parameters that has some properties.
     *
     * @remarks
     *
     * The parameter `options` might have the following options.
     *
     * - `timeout` : Maximum time in milliseconds for resources to load, defaults
     *   to 30 seconds, pass `0` to disable timeout. The default value can be
     *   changed by using the {@link Page.setDefaultNavigationTimeout} or
     *   {@link Page.setDefaultTimeout} methods.
     *
     * - `waitUntil`: When to consider setting markup succeeded, defaults to
     *   `load`. Given an array of event strings, setting content is considered
     *   to be successful after all events have been fired. Events can be
     *   either:<br/>
     * - `load` : consider setting content to be finished when the `load` event
     *   is fired.<br/>
     * - `domcontentloaded` : consider setting content to be finished when the
     *   `DOMContentLoaded` event is fired.<br/>
     * - `networkidle0` : consider setting content to be finished when there are
     *   no more than 0 network connections for at least `500` ms.<br/>
     * - `networkidle2` : consider setting content to be finished when there are
     *   no more than 2 network connections for at least `500` ms.
     */
    async setContent(html, options) {
      await this.mainFrame().setContent(html, options);
    }
    /**
     * Navigates the page to the given `url`.
     *
     * @remarks
     *
     * Navigation to `about:blank` or navigation to the same URL with a different
     * hash will succeed and return `null`.
     *
     * :::warning
     *
     * Headless mode doesn't support navigation to a PDF document. See the {@link
     * https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream
     * issue}.
     *
     * :::
     *
     * Shortcut for {@link Frame.goto | page.mainFrame().goto(url, options)}.
     *
     * @param url - URL to navigate page to. The URL should include scheme, e.g.
     * `https://`
     * @param options - Options to configure waiting behavior.
     * @returns A promise which resolves to the main resource response. In case of
     * multiple redirects, the navigation will resolve with the response of the
     * last redirect.
     * @throws If:
     *
     * - there's an SSL error (e.g. in case of self-signed certificates).
     * - target URL is invalid.
     * - the timeout is exceeded during navigation.
     * - the remote server does not respond or is unreachable.
     * - the main resource failed to load.
     *
     * This method will not throw an error when any valid HTTP status code is
     * returned by the remote server, including 404 "Not Found" and 500 "Internal
     * Server Error". The status code for such responses can be retrieved by
     * calling {@link HTTPResponse.status}.
     */
    async goto(url, options) {
      return await this.mainFrame().goto(url, options);
    }
    /**
     * Waits for the page to navigate to a new URL or to reload. It is useful when
     * you run code that will indirectly cause the page to navigate.
     *
     * @example
     *
     * ```ts
     * const [response] = await Promise.all([
     *   page.waitForNavigation(), // The promise resolves after navigation has finished
     *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation
     * ]);
     * ```
     *
     * @remarks
     *
     * Usage of the
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}
     * to change the URL is considered a navigation.
     *
     * @param options - Navigation parameters which might have the following
     * properties:
     * @returns A `Promise` which resolves to the main resource response.
     *
     * - In case of multiple redirects, the navigation will resolve with the
     *   response of the last redirect.
     * - In case of navigation to a different anchor or navigation due to History
     *   API usage, the navigation will resolve with `null`.
     */
    async waitForNavigation(options = {}) {
      return await this.mainFrame().waitForNavigation(options);
    }
    /**
     * @param urlOrPredicate - A URL or predicate to wait for
     * @param options - Optional waiting parameters
     * @returns Promise which resolves to the matched request
     * @example
     *
     * ```ts
     * const firstRequest = await page.waitForRequest(
     *   'https://example.com/resource'
     * );
     * const finalRequest = await page.waitForRequest(
     *   request => request.url() === 'https://example.com'
     * );
     * return finalRequest.response()?.ok();
     * ```
     *
     * @remarks
     * Optional Waiting Parameters have:
     *
     * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds, pass
     *   `0` to disable the timeout. The default value can be changed by using the
     *   {@link Page.setDefaultTimeout} method.
     */
    waitForRequest(urlOrPredicate, options = {}) {
      const { timeout: ms = this._timeoutSettings.timeout() } = options;
      if (typeof urlOrPredicate === "string") {
        const url = urlOrPredicate;
        urlOrPredicate = (request) => {
          return request.url() === url;
        };
      }
      const observable$ = fromEmitterEvent(
        this,
        "request"
        /* PageEvent.Request */
      ).pipe(filterAsync(urlOrPredicate), raceWith(timeout(ms), fromEmitterEvent(
        this,
        "close"
        /* PageEvent.Close */
      ).pipe(map(() => {
        throw new TargetCloseError("Page closed!");
      }))));
      return firstValueFrom(observable$);
    }
    /**
     * @param urlOrPredicate - A URL or predicate to wait for.
     * @param options - Optional waiting parameters
     * @returns Promise which resolves to the matched response.
     * @example
     *
     * ```ts
     * const firstResponse = await page.waitForResponse(
     *   'https://example.com/resource'
     * );
     * const finalResponse = await page.waitForResponse(
     *   response =>
     *     response.url() === 'https://example.com' && response.status() === 200
     * );
     * const finalResponse = await page.waitForResponse(async response => {
     *   return (await response.text()).includes('<html>');
     * });
     * return finalResponse.ok();
     * ```
     *
     * @remarks
     * Optional Parameter have:
     *
     * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds,
     *   pass `0` to disable the timeout. The default value can be changed by using
     *   the {@link Page.setDefaultTimeout} method.
     */
    waitForResponse(urlOrPredicate, options = {}) {
      const { timeout: ms = this._timeoutSettings.timeout() } = options;
      if (typeof urlOrPredicate === "string") {
        const url = urlOrPredicate;
        urlOrPredicate = (response) => {
          return response.url() === url;
        };
      }
      const observable$ = fromEmitterEvent(
        this,
        "response"
        /* PageEvent.Response */
      ).pipe(filterAsync(urlOrPredicate), raceWith(timeout(ms), fromEmitterEvent(
        this,
        "close"
        /* PageEvent.Close */
      ).pipe(map(() => {
        throw new TargetCloseError("Page closed!");
      }))));
      return firstValueFrom(observable$);
    }
    /**
     * Waits for the network to be idle.
     *
     * @param options - Options to configure waiting behavior.
     * @returns A promise which resolves once the network is idle.
     */
    waitForNetworkIdle(options = {}) {
      return firstValueFrom(this.waitForNetworkIdle$(options));
    }
    /**
     * @internal
     */
    waitForNetworkIdle$(options = {}) {
      const { timeout: ms = this._timeoutSettings.timeout(), idleTime = NETWORK_IDLE_TIME, concurrency = 0 } = options;
      return __privateGet(this, _inflight$).pipe(switchMap((inflight) => {
        if (inflight > concurrency) {
          return EMPTY;
        }
        return timer(idleTime);
      }), map(() => {
      }), raceWith(timeout(ms), fromEmitterEvent(
        this,
        "close"
        /* PageEvent.Close */
      ).pipe(map(() => {
        throw new TargetCloseError("Page closed!");
      }))));
    }
    /**
     * Waits for a frame matching the given conditions to appear.
     *
     * @example
     *
     * ```ts
     * const frame = await page.waitForFrame(async frame => {
     *   return frame.name() === 'Test';
     * });
     * ```
     */
    async waitForFrame(urlOrPredicate, options = {}) {
      const { timeout: ms = this.getDefaultTimeout() } = options;
      if (isString(urlOrPredicate)) {
        urlOrPredicate = (frame) => {
          return urlOrPredicate === frame.url();
        };
      }
      return await firstValueFrom(merge(fromEmitterEvent(
        this,
        "frameattached"
        /* PageEvent.FrameAttached */
      ), fromEmitterEvent(
        this,
        "framenavigated"
        /* PageEvent.FrameNavigated */
      ), from(this.frames())).pipe(filterAsync(urlOrPredicate), first(), raceWith(timeout(ms), fromEmitterEvent(
        this,
        "close"
        /* PageEvent.Close */
      ).pipe(map(() => {
        throw new TargetCloseError("Page closed.");
      })))));
    }
    /**
     * Emulates a given device's metrics and user agent.
     *
     * To aid emulation, Puppeteer provides a list of known devices that can be
     * via {@link KnownDevices}.
     *
     * @remarks
     * This method is a shortcut for calling two methods:
     * {@link Page.setUserAgent} and {@link Page.setViewport}.
     *
     * This method will resize the page. A lot of websites don't expect phones to
     * change size, so you should emulate before navigating to the page.
     *
     * @example
     *
     * ```ts
     * import {KnownDevices} from 'puppeteer';
     * const iPhone = KnownDevices['iPhone 6'];
     *
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   await page.emulate(iPhone);
     *   await page.goto('https://www.google.com');
     *   // other actions...
     *   await browser.close();
     * })();
     * ```
     */
    async emulate(device) {
      await Promise.all([
        this.setUserAgent(device.userAgent),
        this.setViewport(device.viewport)
      ]);
    }
    /**
     * Evaluates a function in the page's context and returns the result.
     *
     * If the function passed to `page.evaluate` returns a Promise, the
     * function will wait for the promise to resolve and return its value.
     *
     * @example
     *
     * ```ts
     * const result = await frame.evaluate(() => {
     *   return Promise.resolve(8 * 7);
     * });
     * console.log(result); // prints "56"
     * ```
     *
     * You can pass a string instead of a function (although functions are
     * recommended as they are easier to debug and use with TypeScript):
     *
     * @example
     *
     * ```ts
     * const aHandle = await page.evaluate('1 + 2');
     * ```
     *
     * To get the best TypeScript experience, you should pass in as the
     * generic the type of `pageFunction`:
     *
     * ```ts
     * const aHandle = await page.evaluate(() => 2);
     * ```
     *
     * @example
     *
     * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed
     * as arguments to the `pageFunction`:
     *
     * ```ts
     * const bodyHandle = await page.$('body');
     * const html = await page.evaluate(body => body.innerHTML, bodyHandle);
     * await bodyHandle.dispose();
     * ```
     *
     * @param pageFunction - a function that is run within the page
     * @param args - arguments to be passed to the pageFunction
     *
     * @returns the return value of `pageFunction`.
     */
    async evaluate(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
      return await this.mainFrame().evaluate(pageFunction, ...args);
    }
    /**
     * @internal
     */
    async _maybeWriteBufferToFile(path, buffer) {
      if (!path) {
        return;
      }
      const fs = await importFSPromises();
      await fs.writeFile(path, buffer);
    }
    /**
     * Captures a screencast of this {@link Page | page}.
     *
     * @example
     * Recording a {@link Page | page}:
     *
     * ```
     * import puppeteer from 'puppeteer';
     *
     * // Launch a browser
     * const browser = await puppeteer.launch();
     *
     * // Create a new page
     * const page = await browser.newPage();
     *
     * // Go to your site.
     * await page.goto("https://www.example.com");
     *
     * // Start recording.
     * const recorder = await page.screencast({path: 'recording.webm'});
     *
     * // Do something.
     *
     * // Stop recording.
     * await recorder.stop();
     *
     * browser.close();
     * ```
     *
     * @param options - Configures screencast behavior.
     *
     * @experimental
     *
     * @remarks
     *
     * All recordings will be {@link https://www.webmproject.org/ | WebM} format using
     * the {@link https://www.webmproject.org/vp9/ | VP9} video codec. The FPS is 30.
     *
     * You must have {@link https://ffmpeg.org/ | ffmpeg} installed on your system.
     */
    async screencast(options = {}) {
      const [{ ScreenRecorder }, [width, height, devicePixelRatio]] = await Promise.all([
        import("./ScreenRecorder-UUZ3MA5F.js"),
        __privateMethod(this, _getNativePixelDimensions, getNativePixelDimensions_fn).call(this)
      ]);
      let crop;
      if (options.crop) {
        const { x, y, width: cropWidth, height: cropHeight } = roundRectangle(normalizeRectangle(options.crop));
        if (x < 0 || y < 0) {
          throw new Error(`\`crop.x\` and \`crop.y\` must be greater than or equal to 0.`);
        }
        if (cropWidth <= 0 || cropHeight <= 0) {
          throw new Error(`\`crop.height\` and \`crop.width\` must be greater than or equal to 0.`);
        }
        const viewportWidth = width / devicePixelRatio;
        const viewportHeight = height / devicePixelRatio;
        if (x + cropWidth > viewportWidth) {
          throw new Error(`\`crop.width\` cannot be larger than the viewport width (${viewportWidth}).`);
        }
        if (y + cropHeight > viewportHeight) {
          throw new Error(`\`crop.height\` cannot be larger than the viewport height (${viewportHeight}).`);
        }
        crop = {
          x: x * devicePixelRatio,
          y: y * devicePixelRatio,
          width: cropWidth * devicePixelRatio,
          height: cropHeight * devicePixelRatio
        };
      }
      if (options.speed !== void 0 && options.speed <= 0) {
        throw new Error(`\`speed\` must be greater than 0.`);
      }
      if (options.scale !== void 0 && options.scale <= 0) {
        throw new Error(`\`scale\` must be greater than 0.`);
      }
      const recorder = new ScreenRecorder(this, width, height, {
        ...options,
        path: options.ffmpegPath,
        crop
      });
      try {
        await this._startScreencast();
      } catch (error) {
        void recorder.stop();
        throw error;
      }
      if (options.path) {
        const { createWriteStream } = await import("./fs-KZQ5ZQOR.js");
        const stream = createWriteStream(options.path, "binary");
        recorder.pipe(stream);
      }
      return recorder;
    }
    /**
     * @internal
     */
    async _startScreencast() {
      ++__privateWrapper(this, _screencastSessionCount)._;
      if (!__privateGet(this, _startScreencastPromise)) {
        __privateSet(this, _startScreencastPromise, this.mainFrame().client.send("Page.startScreencast", { format: "png" }).then(() => {
          return new Promise((resolve) => {
            return this.mainFrame().client.once("Page.screencastFrame", () => {
              return resolve();
            });
          });
        }));
      }
      await __privateGet(this, _startScreencastPromise);
    }
    /**
     * @internal
     */
    async _stopScreencast() {
      --__privateWrapper(this, _screencastSessionCount)._;
      if (!__privateGet(this, _startScreencastPromise)) {
        return;
      }
      __privateSet(this, _startScreencastPromise, void 0);
      if (__privateGet(this, _screencastSessionCount) === 0) {
        await this.mainFrame().client.send("Page.stopScreencast");
      }
    }
    async screenshot(userOptions = {}) {
      const env_2 = { stack: [], error: void 0, hasError: false };
      try {
        await this.bringToFront();
        const options = {
          ...userOptions,
          clip: userOptions.clip ? {
            ...userOptions.clip
          } : void 0
        };
        if (options.type === void 0 && options.path !== void 0) {
          const filePath = options.path;
          const extension = filePath.slice(filePath.lastIndexOf(".") + 1).toLowerCase();
          switch (extension) {
            case "png":
              options.type = "png";
              break;
            case "jpeg":
            case "jpg":
              options.type = "jpeg";
              break;
            case "webp":
              options.type = "webp";
              break;
          }
        }
        if (options.quality !== void 0) {
          if (options.quality < 0 && options.quality > 100) {
            throw new Error(`Expected 'quality' (${options.quality}) to be between 0 and 100, inclusive.`);
          }
          if (options.type === void 0 || !["jpeg", "webp"].includes(options.type)) {
            throw new Error(`${options.type ?? "png"} screenshots do not support 'quality'.`);
          }
        }
        if (options.clip) {
          if (options.clip.width <= 0) {
            throw new Error("'width' in 'clip' must be positive.");
          }
          if (options.clip.height <= 0) {
            throw new Error("'height' in 'clip' must be positive.");
          }
        }
        setDefaultScreenshotOptions(options);
        const stack = __addDisposableResource7(env_2, new AsyncDisposableStack(), true);
        if (options.clip) {
          if (options.fullPage) {
            throw new Error("'clip' and 'fullPage' are mutually exclusive");
          }
          options.clip = roundRectangle(normalizeRectangle(options.clip));
        } else {
          if (options.fullPage) {
            if (!options.captureBeyondViewport) {
              const scrollDimensions = await this.mainFrame().isolatedRealm().evaluate(() => {
                const element = document.documentElement;
                return {
                  width: element.scrollWidth,
                  height: element.scrollHeight
                };
              });
              const viewport = this.viewport();
              await this.setViewport({
                ...viewport,
                ...scrollDimensions
              });
              stack.defer(async () => {
                if (viewport) {
                  await this.setViewport(viewport).catch(debugError);
                } else {
                  await this.setViewport({
                    width: 0,
                    height: 0
                  }).catch(debugError);
                }
              });
            }
          } else {
            options.captureBeyondViewport = false;
          }
        }
        const data = await this._screenshot(options);
        if (options.encoding === "base64") {
          return data;
        }
        const buffer = Buffer.from(data, "base64");
        await this._maybeWriteBufferToFile(options.path, buffer);
        return buffer;
      } catch (e_2) {
        env_2.error = e_2;
        env_2.hasError = true;
      } finally {
        const result_1 = __disposeResources7(env_2);
        if (result_1)
          await result_1;
      }
    }
    /**
     * The page's title
     *
     * @remarks
     *
     * Shortcut for {@link Frame.title | page.mainFrame().title()}.
     */
    async title() {
      return await this.mainFrame().title();
    }
    /**
     * This method fetches an element with `selector`, scrolls it into view if
     * needed, and then uses {@link Page.mouse} to click in the center of the
     * element. If there's no element matching `selector`, the method throws an
     * error.
     *
     * @remarks
     *
     * Bear in mind that if `click()` triggers a navigation event and
     * there's a separate `page.waitForNavigation()` promise to be resolved, you
     * may end up with a race condition that yields unexpected results. The
     * correct pattern for click and wait for navigation is the following:
     *
     * ```ts
     * const [response] = await Promise.all([
     *   page.waitForNavigation(waitOptions),
     *   page.click(selector, clickOptions),
     * ]);
     * ```
     *
     * Shortcut for {@link Frame.click | page.mainFrame().click(selector[, options]) }.
     * @param selector - A `selector` to search for element to click. If there are
     * multiple elements satisfying the `selector`, the first will be clicked
     * @param options - `Object`
     * @returns Promise which resolves when the element matching `selector` is
     * successfully clicked. The Promise will be rejected if there is no element
     * matching `selector`.
     */
    click(selector, options) {
      return this.mainFrame().click(selector, options);
    }
    /**
     * This method fetches an element with `selector` and focuses it. If there's no
     * element matching `selector`, the method throws an error.
     * @param selector - A
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector }
     * of an element to focus. If there are multiple elements satisfying the
     * selector, the first will be focused.
     * @returns Promise which resolves when the element matching selector is
     * successfully focused. The promise will be rejected if there is no element
     * matching selector.
     *
     * @remarks
     *
     * Shortcut for {@link Frame.focus | page.mainFrame().focus(selector)}.
     */
    focus(selector) {
      return this.mainFrame().focus(selector);
    }
    /**
     * This method fetches an element with `selector`, scrolls it into view if
     * needed, and then uses {@link Page.mouse}
     * to hover over the center of the element.
     * If there's no element matching `selector`, the method throws an error.
     * @param selector - A
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * to search for element to hover. If there are multiple elements satisfying
     * the selector, the first will be hovered.
     * @returns Promise which resolves when the element matching `selector` is
     * successfully hovered. Promise gets rejected if there's no element matching
     * `selector`.
     *
     * @remarks
     *
     * Shortcut for {@link Page.hover | page.mainFrame().hover(selector)}.
     */
    hover(selector) {
      return this.mainFrame().hover(selector);
    }
    /**
     * Triggers a `change` and `input` event once all the provided options have been
     * selected. If there's no `<select>` element matching `selector`, the method
     * throws an error.
     *
     * @example
     *
     * ```ts
     * page.select('select#colors', 'blue'); // single selection
     * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections
     * ```
     *
     * @param selector - A
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}
     * to query the page for
     * @param values - Values of options to select. If the `<select>` has the
     * `multiple` attribute, all values are considered, otherwise only the first one
     * is taken into account.
     * @returns
     *
     * @remarks
     *
     * Shortcut for {@link Frame.select | page.mainFrame().select()}
     */
    select(selector, ...values) {
      return this.mainFrame().select(selector, ...values);
    }
    /**
     * This method fetches an element with `selector`, scrolls it into view if
     * needed, and then uses {@link Page.touchscreen}
     * to tap in the center of the element.
     * If there's no element matching `selector`, the method throws an error.
     * @param selector - A
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}
     * to search for element to tap. If there are multiple elements satisfying the
     * selector, the first will be tapped.
     *
     * @remarks
     *
     * Shortcut for {@link Frame.tap | page.mainFrame().tap(selector)}.
     */
    tap(selector) {
      return this.mainFrame().tap(selector);
    }
    /**
     * Sends a `keydown`, `keypress/input`, and `keyup` event for each character
     * in the text.
     *
     * To press a special key, like `Control` or `ArrowDown`, use {@link Keyboard.press}.
     * @example
     *
     * ```ts
     * await page.type('#mytextarea', 'Hello');
     * // Types instantly
     * await page.type('#mytextarea', 'World', {delay: 100});
     * // Types slower, like a user
     * ```
     *
     * @param selector - A
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * of an element to type into. If there are multiple elements satisfying the
     * selector, the first will be used.
     * @param text - A text to type into a focused element.
     * @param options - have property `delay` which is the Time to wait between
     * key presses in milliseconds. Defaults to `0`.
     * @returns
     */
    type(selector, text, options) {
      return this.mainFrame().type(selector, text, options);
    }
    /**
     * Wait for the `selector` to appear in page. If at the moment of calling the
     * method the `selector` already exists, the method will return immediately. If
     * the `selector` doesn't appear after the `timeout` milliseconds of waiting, the
     * function will throw.
     *
     * @example
     * This method works across navigations:
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   let currentURL;
     *   page
     *     .waitForSelector('img')
     *     .then(() => console.log('First URL with image: ' + currentURL));
     *   for (currentURL of [
     *     'https://example.com',
     *     'https://google.com',
     *     'https://bbc.com',
     *   ]) {
     *     await page.goto(currentURL);
     *   }
     *   await browser.close();
     * })();
     * ```
     *
     * @param selector - A
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * of an element to wait for
     * @param options - Optional waiting parameters
     * @returns Promise which resolves when element specified by selector string
     * is added to DOM. Resolves to `null` if waiting for hidden: `true` and
     * selector is not found in DOM.
     *
     * @remarks
     * The optional Parameter in Arguments `options` are:
     *
     * - `visible`: A boolean wait for element to be present in DOM and to be
     *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS
     *   properties. Defaults to `false`.
     *
     * - `hidden`: Wait for element to not be found in the DOM or to be hidden,
     *   i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to
     *   `false`.
     *
     * - `timeout`: maximum time to wait for in milliseconds. Defaults to `30000`
     *   (30 seconds). Pass `0` to disable timeout. The default value can be changed
     *   by using the {@link Page.setDefaultTimeout} method.
     */
    async waitForSelector(selector, options = {}) {
      return await this.mainFrame().waitForSelector(selector, options);
    }
    /**
     * Waits for the provided function, `pageFunction`, to return a truthy value when
     * evaluated in the page's context.
     *
     * @example
     * {@link Page.waitForFunction} can be used to observe a viewport size change:
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   const watchDog = page.waitForFunction('window.innerWidth < 100');
     *   await page.setViewport({width: 50, height: 50});
     *   await watchDog;
     *   await browser.close();
     * })();
     * ```
     *
     * @example
     * Arguments can be passed from Node.js to `pageFunction`:
     *
     * ```ts
     * const selector = '.foo';
     * await page.waitForFunction(
     *   selector => !!document.querySelector(selector),
     *   {},
     *   selector
     * );
     * ```
     *
     * @example
     * The provided `pageFunction` can be asynchronous:
     *
     * ```ts
     * const username = 'github-username';
     * await page.waitForFunction(
     *   async username => {
     *     const githubResponse = await fetch(
     *       `https://api.github.com/users/${username}`
     *     );
     *     const githubUser = await githubResponse.json();
     *     // show the avatar
     *     const img = document.createElement('img');
     *     img.src = githubUser.avatar_url;
     *     // wait 3 seconds
     *     await new Promise((resolve, reject) => setTimeout(resolve, 3000));
     *     img.remove();
     *   },
     *   {},
     *   username
     * );
     * ```
     *
     * @param pageFunction - Function to be evaluated in browser context until it returns a
     * truthy value.
     * @param options - Options for configuring waiting behavior.
     */
    waitForFunction(pageFunction, options, ...args) {
      return this.mainFrame().waitForFunction(pageFunction, options, ...args);
    }
    /** @internal */
    [(_screenshot_decorators = [guarded(function() {
      return this.browser();
    })], disposeSymbol)]() {
      return void this.close().catch(debugError);
    }
    /** @internal */
    [asyncDisposeSymbol]() {
      return this.close();
    }
  }, _requestHandlers = new WeakMap(), _inflight$ = new WeakMap(), _screencastSessionCount = new WeakMap(), _startScreencastPromise = new WeakMap(), _getNativePixelDimensions = new WeakSet(), getNativePixelDimensions_fn = async function() {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      const viewport = this.viewport();
      const stack = __addDisposableResource7(env_1, new DisposableStack(), false);
      if (viewport && viewport.deviceScaleFactor !== 0) {
        await this.setViewport({ ...viewport, deviceScaleFactor: 0 });
        stack.defer(() => {
          void this.setViewport(viewport).catch(debugError);
        });
      }
      return await this.mainFrame().isolatedRealm().evaluate(() => {
        return [
          window.visualViewport.width * window.devicePixelRatio,
          window.visualViewport.height * window.devicePixelRatio,
          window.devicePixelRatio
        ];
      });
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources7(env_1);
    }
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    __esDecorate4(_a, null, _screenshot_decorators, { kind: "method", name: "screenshot", static: false, private: false, access: { has: (obj) => "screenshot" in obj, get: (obj) => obj.screenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata)
      Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a;
})();
var supportedMetrics = /* @__PURE__ */ new Set([
  "Timestamp",
  "Documents",
  "Frames",
  "JSEventListeners",
  "Nodes",
  "LayoutCount",
  "RecalcStyleCount",
  "LayoutDuration",
  "RecalcStyleDuration",
  "ScriptDuration",
  "TaskDuration",
  "JSHeapUsedSize",
  "JSHeapTotalSize"
]);
function normalizeRectangle(clip) {
  return {
    ...clip,
    ...clip.width < 0 ? {
      x: clip.x + clip.width,
      width: -clip.width
    } : {
      x: clip.x,
      width: clip.width
    },
    ...clip.height < 0 ? {
      y: clip.y + clip.height,
      height: -clip.height
    } : {
      y: clip.y,
      height: clip.height
    }
  };
}
function roundRectangle(clip) {
  const x = Math.round(clip.x);
  const y = Math.round(clip.y);
  const width = Math.round(clip.width + clip.x - x);
  const height = Math.round(clip.height + clip.y - y);
  return { ...clip, x, y, width, height };
}

// node_modules/puppeteer-core/lib/esm/puppeteer/common/WaitTask.js
var _world, _polling, _root, _fn, _args, _timeout, _timeoutError, _result, _poller, _signal, _reruns;
var WaitTask = class {
  constructor(world, options, fn, ...args) {
    __privateAdd(this, _world, void 0);
    __privateAdd(this, _polling, void 0);
    __privateAdd(this, _root, void 0);
    __privateAdd(this, _fn, void 0);
    __privateAdd(this, _args, void 0);
    __privateAdd(this, _timeout, void 0);
    __privateAdd(this, _timeoutError, void 0);
    __privateAdd(this, _result, Deferred.create());
    __privateAdd(this, _poller, void 0);
    __privateAdd(this, _signal, void 0);
    __privateAdd(this, _reruns, []);
    var _a;
    __privateSet(this, _world, world);
    __privateSet(this, _polling, options.polling);
    __privateSet(this, _root, options.root);
    __privateSet(this, _signal, options.signal);
    (_a = __privateGet(this, _signal)) == null ? void 0 : _a.addEventListener("abort", () => {
      var _a2;
      void this.terminate((_a2 = __privateGet(this, _signal)) == null ? void 0 : _a2.reason);
    }, {
      once: true
    });
    switch (typeof fn) {
      case "string":
        __privateSet(this, _fn, `() => {return (${fn});}`);
        break;
      default:
        __privateSet(this, _fn, stringifyFunction(fn));
        break;
    }
    __privateSet(this, _args, args);
    __privateGet(this, _world).taskManager.add(this);
    if (options.timeout) {
      __privateSet(this, _timeoutError, new TimeoutError(`Waiting failed: ${options.timeout}ms exceeded`));
      __privateSet(this, _timeout, setTimeout(() => {
        void this.terminate(__privateGet(this, _timeoutError));
      }, options.timeout));
    }
    void this.rerun();
  }
  get result() {
    return __privateGet(this, _result).valueOrThrow();
  }
  async rerun() {
    for (const prev of __privateGet(this, _reruns)) {
      prev.abort();
    }
    __privateGet(this, _reruns).length = 0;
    const controller = new AbortController();
    __privateGet(this, _reruns).push(controller);
    try {
      switch (__privateGet(this, _polling)) {
        case "raf":
          __privateSet(this, _poller, await __privateGet(this, _world).evaluateHandle(({ RAFPoller, createFunction: createFunction2 }, fn, ...args) => {
            const fun = createFunction2(fn);
            return new RAFPoller(() => {
              return fun(...args);
            });
          }, LazyArg.create((context) => {
            return context.puppeteerUtil;
          }), __privateGet(this, _fn), ...__privateGet(this, _args)));
          break;
        case "mutation":
          __privateSet(this, _poller, await __privateGet(this, _world).evaluateHandle(({ MutationPoller, createFunction: createFunction2 }, root, fn, ...args) => {
            const fun = createFunction2(fn);
            return new MutationPoller(() => {
              return fun(...args);
            }, root || document);
          }, LazyArg.create((context) => {
            return context.puppeteerUtil;
          }), __privateGet(this, _root), __privateGet(this, _fn), ...__privateGet(this, _args)));
          break;
        default:
          __privateSet(this, _poller, await __privateGet(this, _world).evaluateHandle(({ IntervalPoller, createFunction: createFunction2 }, ms, fn, ...args) => {
            const fun = createFunction2(fn);
            return new IntervalPoller(() => {
              return fun(...args);
            }, ms);
          }, LazyArg.create((context) => {
            return context.puppeteerUtil;
          }), __privateGet(this, _polling), __privateGet(this, _fn), ...__privateGet(this, _args)));
          break;
      }
      await __privateGet(this, _poller).evaluate((poller) => {
        void poller.start();
      });
      const result = await __privateGet(this, _poller).evaluateHandle((poller) => {
        return poller.result();
      });
      __privateGet(this, _result).resolve(result);
      await this.terminate();
    } catch (error) {
      if (controller.signal.aborted) {
        return;
      }
      const badError = this.getBadError(error);
      if (badError) {
        await this.terminate(badError);
      }
    }
  }
  async terminate(error) {
    __privateGet(this, _world).taskManager.delete(this);
    clearTimeout(__privateGet(this, _timeout));
    if (error && !__privateGet(this, _result).finished()) {
      __privateGet(this, _result).reject(error);
    }
    if (__privateGet(this, _poller)) {
      try {
        await __privateGet(this, _poller).evaluateHandle(async (poller) => {
          await poller.stop();
        });
        if (__privateGet(this, _poller)) {
          await __privateGet(this, _poller).dispose();
          __privateSet(this, _poller, void 0);
        }
      } catch {
      }
    }
  }
  /**
   * Not all errors lead to termination. They usually imply we need to rerun the task.
   */
  getBadError(error) {
    if (isErrorLike(error)) {
      if (error.message.includes("Execution context is not available in detached frame")) {
        return new Error("Waiting failed: Frame detached");
      }
      if (error.message.includes("Execution context was destroyed")) {
        return;
      }
      if (error.message.includes("Cannot find context with specified id")) {
        return;
      }
      if (error.message.includes("AbortError: Actor 'MessageHandlerFrame' destroyed")) {
        return;
      }
      return error;
    }
    return new Error("WaitTask failed with an error", {
      cause: error
    });
  }
};
_world = new WeakMap();
_polling = new WeakMap();
_root = new WeakMap();
_fn = new WeakMap();
_args = new WeakMap();
_timeout = new WeakMap();
_timeoutError = new WeakMap();
_result = new WeakMap();
_poller = new WeakMap();
_signal = new WeakMap();
_reruns = new WeakMap();
var _tasks;
var TaskManager = class {
  constructor() {
    __privateAdd(this, _tasks, /* @__PURE__ */ new Set());
  }
  add(task) {
    __privateGet(this, _tasks).add(task);
  }
  delete(task) {
    __privateGet(this, _tasks).delete(task);
  }
  terminateAll(error) {
    for (const task of __privateGet(this, _tasks)) {
      void task.terminate(error);
    }
    __privateGet(this, _tasks).clear();
  }
  async rerunAll() {
    await Promise.all([...__privateGet(this, _tasks)].map((task) => {
      return task.rerun();
    }));
  }
};
_tasks = new WeakMap();

// node_modules/puppeteer-core/lib/esm/puppeteer/api/Realm.js
var _disposed;
var Realm = class {
  constructor(timeoutSettings) {
    __publicField(this, "timeoutSettings");
    __publicField(this, "taskManager", new TaskManager());
    __privateAdd(this, _disposed, false);
    this.timeoutSettings = timeoutSettings;
  }
  async waitForFunction(pageFunction, options = {}, ...args) {
    const { polling = "raf", timeout: timeout2 = this.timeoutSettings.timeout(), root, signal } = options;
    if (typeof polling === "number" && polling < 0) {
      throw new Error("Cannot poll with non-positive interval");
    }
    const waitTask = new WaitTask(this, {
      polling,
      root,
      timeout: timeout2,
      signal
    }, pageFunction, ...args);
    return await waitTask.result;
  }
  get disposed() {
    return __privateGet(this, _disposed);
  }
  /** @internal */
  dispose() {
    __privateSet(this, _disposed, true);
    this.taskManager.terminateAll(new Error("waitForFunction failed: frame got detached."));
  }
  /** @internal */
  [disposeSymbol]() {
    this.dispose();
  }
};
_disposed = new WeakMap();

// node_modules/puppeteer-core/lib/esm/puppeteer/api/Target.js
var TargetType;
(function(TargetType2) {
  TargetType2["PAGE"] = "page";
  TargetType2["BACKGROUND_PAGE"] = "background_page";
  TargetType2["SERVICE_WORKER"] = "service_worker";
  TargetType2["SHARED_WORKER"] = "shared_worker";
  TargetType2["BROWSER"] = "browser";
  TargetType2["WEBVIEW"] = "webview";
  TargetType2["OTHER"] = "other";
  TargetType2["TAB"] = "tab";
})(TargetType || (TargetType = {}));
var Target = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * If the target is not of type `"service_worker"` or `"shared_worker"`, returns `null`.
   */
  async worker() {
    return null;
  }
  /**
   * If the target is not of type `"page"`, `"webview"` or `"background_page"`,
   * returns `null`.
   */
  async page() {
    return null;
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/api/WebWorker.js
var _url;
var WebWorker = class extends EventEmitter {
  /**
   * @internal
   */
  constructor(url) {
    super();
    /**
     * @internal
     */
    __publicField(this, "timeoutSettings", new TimeoutSettings());
    __privateAdd(this, _url, void 0);
    __privateSet(this, _url, url);
  }
  /**
   * The URL of this web worker.
   */
  url() {
    return __privateGet(this, _url);
  }
  /**
   * Evaluates a given function in the {@link WebWorker | worker}.
   *
   * @remarks If the given function returns a promise,
   * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.
   *
   * As a rule of thumb, if the return value of the given function is more
   * complicated than a JSON object (e.g. most classes), then
   * {@link WebWorker.evaluate | evaluate} will _likely_ return some truncated
   * value (or `{}`). This is because we are not returning the actual return
   * value, but a deserialized version as a result of transferring the return
   * value through a protocol to Puppeteer.
   *
   * In general, you should use
   * {@link WebWorker.evaluateHandle | evaluateHandle} if
   * {@link WebWorker.evaluate | evaluate} cannot serialize the return value
   * properly or you need a mutable {@link JSHandle | handle} to the return
   * object.
   *
   * @param func - Function to be evaluated.
   * @param args - Arguments to pass into `func`.
   * @returns The result of `func`.
   */
  async evaluate(func, ...args) {
    func = withSourcePuppeteerURLIfNone(this.evaluate.name, func);
    return await this.mainRealm().evaluate(func, ...args);
  }
  /**
   * Evaluates a given function in the {@link WebWorker | worker}.
   *
   * @remarks If the given function returns a promise,
   * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.
   *
   * In general, you should use
   * {@link WebWorker.evaluateHandle | evaluateHandle} if
   * {@link WebWorker.evaluate | evaluate} cannot serialize the return value
   * properly or you need a mutable {@link JSHandle | handle} to the return
   * object.
   *
   * @param func - Function to be evaluated.
   * @param args - Arguments to pass into `func`.
   * @returns A {@link JSHandle | handle} to the return value of `func`.
   */
  async evaluateHandle(func, ...args) {
    func = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, func);
    return await this.mainRealm().evaluateHandle(func, ...args);
  }
  async close() {
    throw new UnsupportedOperation("WebWorker.close() is not supported");
  }
};
_url = new WeakMap();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Accessibility.js
var _client;
var Accessibility = class {
  /**
   * @internal
   */
  constructor(client) {
    __privateAdd(this, _client, void 0);
    __privateSet(this, _client, client);
  }
  /**
   * @internal
   */
  updateClient(client) {
    __privateSet(this, _client, client);
  }
  /**
   * Captures the current state of the accessibility tree.
   * The returned object represents the root accessible node of the page.
   *
   * @remarks
   *
   * **NOTE** The Chrome accessibility tree contains nodes that go unused on
   * most platforms and by most screen readers. Puppeteer will discard them as
   * well for an easier to process tree, unless `interestingOnly` is set to
   * `false`.
   *
   * @example
   * An example of dumping the entire accessibility tree:
   *
   * ```ts
   * const snapshot = await page.accessibility.snapshot();
   * console.log(snapshot);
   * ```
   *
   * @example
   * An example of logging the focused node's name:
   *
   * ```ts
   * const snapshot = await page.accessibility.snapshot();
   * const node = findFocusedNode(snapshot);
   * console.log(node && node.name);
   *
   * function findFocusedNode(node) {
   *   if (node.focused) return node;
   *   for (const child of node.children || []) {
   *     const foundNode = findFocusedNode(child);
   *     return foundNode;
   *   }
   *   return null;
   * }
   * ```
   *
   * @returns An AXNode object representing the snapshot.
   */
  async snapshot(options = {}) {
    const { interestingOnly = true, root = null } = options;
    const { nodes } = await __privateGet(this, _client).send("Accessibility.getFullAXTree");
    let backendNodeId;
    if (root) {
      const { node } = await __privateGet(this, _client).send("DOM.describeNode", {
        objectId: root.id
      });
      backendNodeId = node.backendNodeId;
    }
    const defaultRoot = AXNode.createTree(nodes);
    let needle = defaultRoot;
    if (backendNodeId) {
      needle = defaultRoot.find((node) => {
        return node.payload.backendDOMNodeId === backendNodeId;
      });
      if (!needle) {
        return null;
      }
    }
    if (!interestingOnly) {
      return this.serializeTree(needle)[0] ?? null;
    }
    const interestingNodes = /* @__PURE__ */ new Set();
    this.collectInterestingNodes(interestingNodes, defaultRoot, false);
    if (!interestingNodes.has(needle)) {
      return null;
    }
    return this.serializeTree(needle, interestingNodes)[0] ?? null;
  }
  serializeTree(node, interestingNodes) {
    const children = [];
    for (const child of node.children) {
      children.push(...this.serializeTree(child, interestingNodes));
    }
    if (interestingNodes && !interestingNodes.has(node)) {
      return children;
    }
    const serializedNode = node.serialize();
    if (children.length) {
      serializedNode.children = children;
    }
    return [serializedNode];
  }
  collectInterestingNodes(collection, node, insideControl) {
    if (node.isInteresting(insideControl)) {
      collection.add(node);
    }
    if (node.isLeafNode()) {
      return;
    }
    insideControl = insideControl || node.isControl();
    for (const child of node.children) {
      this.collectInterestingNodes(collection, child, insideControl);
    }
  }
};
_client = new WeakMap();
var _richlyEditable, _editable, _focusable, _hidden, _name, _role, _ignored, _cachedHasFocusableChild, _isPlainTextField, isPlainTextField_fn, _isTextOnlyObject, isTextOnlyObject_fn, _hasFocusableChild, hasFocusableChild_fn;
var _AXNode = class _AXNode {
  constructor(payload) {
    __privateAdd(this, _isPlainTextField);
    __privateAdd(this, _isTextOnlyObject);
    __privateAdd(this, _hasFocusableChild);
    __publicField(this, "payload");
    __publicField(this, "children", []);
    __privateAdd(this, _richlyEditable, false);
    __privateAdd(this, _editable, false);
    __privateAdd(this, _focusable, false);
    __privateAdd(this, _hidden, false);
    __privateAdd(this, _name, void 0);
    __privateAdd(this, _role, void 0);
    __privateAdd(this, _ignored, void 0);
    __privateAdd(this, _cachedHasFocusableChild, void 0);
    this.payload = payload;
    __privateSet(this, _name, this.payload.name ? this.payload.name.value : "");
    __privateSet(this, _role, this.payload.role ? this.payload.role.value : "Unknown");
    __privateSet(this, _ignored, this.payload.ignored);
    for (const property of this.payload.properties || []) {
      if (property.name === "editable") {
        __privateSet(this, _richlyEditable, property.value.value === "richtext");
        __privateSet(this, _editable, true);
      }
      if (property.name === "focusable") {
        __privateSet(this, _focusable, property.value.value);
      }
      if (property.name === "hidden") {
        __privateSet(this, _hidden, property.value.value);
      }
    }
  }
  find(predicate) {
    if (predicate(this)) {
      return this;
    }
    for (const child of this.children) {
      const result = child.find(predicate);
      if (result) {
        return result;
      }
    }
    return null;
  }
  isLeafNode() {
    if (!this.children.length) {
      return true;
    }
    if (__privateMethod(this, _isPlainTextField, isPlainTextField_fn).call(this) || __privateMethod(this, _isTextOnlyObject, isTextOnlyObject_fn).call(this)) {
      return true;
    }
    switch (__privateGet(this, _role)) {
      case "doc-cover":
      case "graphics-symbol":
      case "img":
      case "image":
      case "Meter":
      case "scrollbar":
      case "slider":
      case "separator":
      case "progressbar":
        return true;
      default:
        break;
    }
    if (__privateMethod(this, _hasFocusableChild, hasFocusableChild_fn).call(this)) {
      return false;
    }
    if (__privateGet(this, _focusable) && __privateGet(this, _name)) {
      return true;
    }
    if (__privateGet(this, _role) === "heading" && __privateGet(this, _name)) {
      return true;
    }
    return false;
  }
  isControl() {
    switch (__privateGet(this, _role)) {
      case "button":
      case "checkbox":
      case "ColorWell":
      case "combobox":
      case "DisclosureTriangle":
      case "listbox":
      case "menu":
      case "menubar":
      case "menuitem":
      case "menuitemcheckbox":
      case "menuitemradio":
      case "radio":
      case "scrollbar":
      case "searchbox":
      case "slider":
      case "spinbutton":
      case "switch":
      case "tab":
      case "textbox":
      case "tree":
      case "treeitem":
        return true;
      default:
        return false;
    }
  }
  isInteresting(insideControl) {
    const role = __privateGet(this, _role);
    if (role === "Ignored" || __privateGet(this, _hidden) || __privateGet(this, _ignored)) {
      return false;
    }
    if (__privateGet(this, _focusable) || __privateGet(this, _richlyEditable)) {
      return true;
    }
    if (this.isControl()) {
      return true;
    }
    if (insideControl) {
      return false;
    }
    return this.isLeafNode() && !!__privateGet(this, _name);
  }
  serialize() {
    const properties = /* @__PURE__ */ new Map();
    for (const property of this.payload.properties || []) {
      properties.set(property.name.toLowerCase(), property.value.value);
    }
    if (this.payload.name) {
      properties.set("name", this.payload.name.value);
    }
    if (this.payload.value) {
      properties.set("value", this.payload.value.value);
    }
    if (this.payload.description) {
      properties.set("description", this.payload.description.value);
    }
    const node = {
      role: __privateGet(this, _role)
    };
    const userStringProperties = [
      "name",
      "value",
      "description",
      "keyshortcuts",
      "roledescription",
      "valuetext"
    ];
    const getUserStringPropertyValue = (key) => {
      return properties.get(key);
    };
    for (const userStringProperty of userStringProperties) {
      if (!properties.has(userStringProperty)) {
        continue;
      }
      node[userStringProperty] = getUserStringPropertyValue(userStringProperty);
    }
    const booleanProperties = [
      "disabled",
      "expanded",
      "focused",
      "modal",
      "multiline",
      "multiselectable",
      "readonly",
      "required",
      "selected"
    ];
    const getBooleanPropertyValue = (key) => {
      return properties.get(key);
    };
    for (const booleanProperty of booleanProperties) {
      if (booleanProperty === "focused" && __privateGet(this, _role) === "RootWebArea") {
        continue;
      }
      const value = getBooleanPropertyValue(booleanProperty);
      if (!value) {
        continue;
      }
      node[booleanProperty] = getBooleanPropertyValue(booleanProperty);
    }
    const tristateProperties = ["checked", "pressed"];
    for (const tristateProperty of tristateProperties) {
      if (!properties.has(tristateProperty)) {
        continue;
      }
      const value = properties.get(tristateProperty);
      node[tristateProperty] = value === "mixed" ? "mixed" : value === "true" ? true : false;
    }
    const numericalProperties = [
      "level",
      "valuemax",
      "valuemin"
    ];
    const getNumericalPropertyValue = (key) => {
      return properties.get(key);
    };
    for (const numericalProperty of numericalProperties) {
      if (!properties.has(numericalProperty)) {
        continue;
      }
      node[numericalProperty] = getNumericalPropertyValue(numericalProperty);
    }
    const tokenProperties = [
      "autocomplete",
      "haspopup",
      "invalid",
      "orientation"
    ];
    const getTokenPropertyValue = (key) => {
      return properties.get(key);
    };
    for (const tokenProperty of tokenProperties) {
      const value = getTokenPropertyValue(tokenProperty);
      if (!value || value === "false") {
        continue;
      }
      node[tokenProperty] = getTokenPropertyValue(tokenProperty);
    }
    return node;
  }
  static createTree(payloads) {
    const nodeById = /* @__PURE__ */ new Map();
    for (const payload of payloads) {
      nodeById.set(payload.nodeId, new _AXNode(payload));
    }
    for (const node of nodeById.values()) {
      for (const childId of node.payload.childIds || []) {
        const child = nodeById.get(childId);
        if (child) {
          node.children.push(child);
        }
      }
    }
    return nodeById.values().next().value;
  }
};
_richlyEditable = new WeakMap();
_editable = new WeakMap();
_focusable = new WeakMap();
_hidden = new WeakMap();
_name = new WeakMap();
_role = new WeakMap();
_ignored = new WeakMap();
_cachedHasFocusableChild = new WeakMap();
_isPlainTextField = new WeakSet();
isPlainTextField_fn = function() {
  if (__privateGet(this, _richlyEditable)) {
    return false;
  }
  if (__privateGet(this, _editable)) {
    return true;
  }
  return __privateGet(this, _role) === "textbox" || __privateGet(this, _role) === "searchbox";
};
_isTextOnlyObject = new WeakSet();
isTextOnlyObject_fn = function() {
  const role = __privateGet(this, _role);
  return role === "LineBreak" || role === "text" || role === "InlineTextBox" || role === "StaticText";
};
_hasFocusableChild = new WeakSet();
hasFocusableChild_fn = function() {
  var _a;
  if (__privateGet(this, _cachedHasFocusableChild) === void 0) {
    __privateSet(this, _cachedHasFocusableChild, false);
    for (const child of this.children) {
      if (__privateGet(child, _focusable) || __privateMethod(_a = child, _hasFocusableChild, hasFocusableChild_fn).call(_a)) {
        __privateSet(this, _cachedHasFocusableChild, true);
        break;
      }
    }
  }
  return __privateGet(this, _cachedHasFocusableChild);
};
var AXNode = _AXNode;

// node_modules/puppeteer-core/lib/esm/puppeteer/common/CallbackRegistry.js
var _callbacks, _idGenerator;
var CallbackRegistry = class {
  constructor() {
    __privateAdd(this, _callbacks, /* @__PURE__ */ new Map());
    __privateAdd(this, _idGenerator, createIncrementalIdGenerator());
  }
  create(label, timeout2, request) {
    const callback = new Callback(__privateGet(this, _idGenerator).call(this), label, timeout2);
    __privateGet(this, _callbacks).set(callback.id, callback);
    try {
      request(callback.id);
    } catch (error) {
      callback.promise.catch(debugError).finally(() => {
        __privateGet(this, _callbacks).delete(callback.id);
      });
      callback.reject(error);
      throw error;
    }
    return callback.promise.finally(() => {
      __privateGet(this, _callbacks).delete(callback.id);
    });
  }
  reject(id, message, originalMessage) {
    const callback = __privateGet(this, _callbacks).get(id);
    if (!callback) {
      return;
    }
    this._reject(callback, message, originalMessage);
  }
  _reject(callback, errorMessage, originalMessage) {
    let error;
    let message;
    if (errorMessage instanceof ProtocolError) {
      error = errorMessage;
      error.cause = callback.error;
      message = errorMessage.message;
    } else {
      error = callback.error;
      message = errorMessage;
    }
    callback.reject(rewriteError(error, `Protocol error (${callback.label}): ${message}`, originalMessage));
  }
  resolve(id, value) {
    const callback = __privateGet(this, _callbacks).get(id);
    if (!callback) {
      return;
    }
    callback.resolve(value);
  }
  clear() {
    for (const callback of __privateGet(this, _callbacks).values()) {
      this._reject(callback, new TargetCloseError("Target closed"));
    }
    __privateGet(this, _callbacks).clear();
  }
  /**
   * @internal
   */
  getPendingProtocolErrors() {
    const result = [];
    for (const callback of __privateGet(this, _callbacks).values()) {
      result.push(new Error(`${callback.label} timed out. Trace: ${callback.error.stack}`));
    }
    return result;
  }
};
_callbacks = new WeakMap();
_idGenerator = new WeakMap();
var _id, _error, _deferred, _timer, _label;
var Callback = class {
  constructor(id, label, timeout2) {
    __privateAdd(this, _id, void 0);
    __privateAdd(this, _error, new ProtocolError());
    __privateAdd(this, _deferred, Deferred.create());
    __privateAdd(this, _timer, void 0);
    __privateAdd(this, _label, void 0);
    __privateSet(this, _id, id);
    __privateSet(this, _label, label);
    if (timeout2) {
      __privateSet(this, _timer, setTimeout(() => {
        __privateGet(this, _deferred).reject(rewriteError(__privateGet(this, _error), `${label} timed out. Increase the 'protocolTimeout' setting in launch/connect calls for a higher timeout if needed.`));
      }, timeout2));
    }
  }
  resolve(value) {
    clearTimeout(__privateGet(this, _timer));
    __privateGet(this, _deferred).resolve(value);
  }
  reject(error) {
    clearTimeout(__privateGet(this, _timer));
    __privateGet(this, _deferred).reject(error);
  }
  get id() {
    return __privateGet(this, _id);
  }
  get promise() {
    return __privateGet(this, _deferred).valueOrThrow();
  }
  get error() {
    return __privateGet(this, _error);
  }
  get label() {
    return __privateGet(this, _label);
  }
};
_id = new WeakMap();
_error = new WeakMap();
_deferred = new WeakMap();
_timer = new WeakMap();
_label = new WeakMap();
function createIncrementalIdGenerator() {
  let id = 0;
  return () => {
    return ++id;
  };
}

// node_modules/puppeteer-core/lib/esm/puppeteer/common/ConsoleMessage.js
var _type2, _text, _args2, _stackTraceLocations;
var ConsoleMessage = class {
  /**
   * @public
   */
  constructor(type, text, args, stackTraceLocations) {
    __privateAdd(this, _type2, void 0);
    __privateAdd(this, _text, void 0);
    __privateAdd(this, _args2, void 0);
    __privateAdd(this, _stackTraceLocations, void 0);
    __privateSet(this, _type2, type);
    __privateSet(this, _text, text);
    __privateSet(this, _args2, args);
    __privateSet(this, _stackTraceLocations, stackTraceLocations);
  }
  /**
   * The type of the console message.
   */
  type() {
    return __privateGet(this, _type2);
  }
  /**
   * The text of the console message.
   */
  text() {
    return __privateGet(this, _text);
  }
  /**
   * An array of arguments passed to the console.
   */
  args() {
    return __privateGet(this, _args2);
  }
  /**
   * The location of the console message.
   */
  location() {
    return __privateGet(this, _stackTraceLocations)[0] ?? {};
  }
  /**
   * The array of locations on the stack of the console message.
   */
  stackTrace() {
    return __privateGet(this, _stackTraceLocations);
  }
};
_type2 = new WeakMap();
_text = new WeakMap();
_args2 = new WeakMap();
_stackTraceLocations = new WeakMap();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Coverage.js
var _jsCoverage, _cssCoverage;
var Coverage = class {
  constructor(client) {
    __privateAdd(this, _jsCoverage, void 0);
    __privateAdd(this, _cssCoverage, void 0);
    __privateSet(this, _jsCoverage, new JSCoverage(client));
    __privateSet(this, _cssCoverage, new CSSCoverage(client));
  }
  /**
   * @internal
   */
  updateClient(client) {
    __privateGet(this, _jsCoverage).updateClient(client);
    __privateGet(this, _cssCoverage).updateClient(client);
  }
  /**
   * @param options - Set of configurable options for coverage defaults to
   * `resetOnNavigation : true, reportAnonymousScripts : false,`
   * `includeRawScriptCoverage : false, useBlockCoverage : true`
   * @returns Promise that resolves when coverage is started.
   *
   * @remarks
   * Anonymous scripts are ones that don't have an associated url. These are
   * scripts that are dynamically created on the page using `eval` or
   * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous
   * scripts URL will start with `debugger://VM` (unless a magic //# sourceURL
   * comment is present, in which case that will the be URL).
   */
  async startJSCoverage(options = {}) {
    return await __privateGet(this, _jsCoverage).start(options);
  }
  /**
   * Promise that resolves to the array of coverage reports for
   * all scripts.
   *
   * @remarks
   * JavaScript Coverage doesn't include anonymous scripts by default.
   * However, scripts with sourceURLs are reported.
   */
  async stopJSCoverage() {
    return await __privateGet(this, _jsCoverage).stop();
  }
  /**
   * @param options - Set of configurable options for coverage, defaults to
   * `resetOnNavigation : true`
   * @returns Promise that resolves when coverage is started.
   */
  async startCSSCoverage(options = {}) {
    return await __privateGet(this, _cssCoverage).start(options);
  }
  /**
   * Promise that resolves to the array of coverage reports
   * for all stylesheets.
   *
   * @remarks
   * CSS Coverage doesn't include dynamically injected style tags
   * without sourceURLs.
   */
  async stopCSSCoverage() {
    return await __privateGet(this, _cssCoverage).stop();
  }
};
_jsCoverage = new WeakMap();
_cssCoverage = new WeakMap();
var _client2, _enabled, _scriptURLs, _scriptSources, _subscriptions, _resetOnNavigation, _reportAnonymousScripts, _includeRawScriptCoverage, _onExecutionContextsCleared, onExecutionContextsCleared_fn, _onScriptParsed, onScriptParsed_fn;
var JSCoverage = class {
  constructor(client) {
    __privateAdd(this, _onExecutionContextsCleared);
    __privateAdd(this, _onScriptParsed);
    __privateAdd(this, _client2, void 0);
    __privateAdd(this, _enabled, false);
    __privateAdd(this, _scriptURLs, /* @__PURE__ */ new Map());
    __privateAdd(this, _scriptSources, /* @__PURE__ */ new Map());
    __privateAdd(this, _subscriptions, void 0);
    __privateAdd(this, _resetOnNavigation, false);
    __privateAdd(this, _reportAnonymousScripts, false);
    __privateAdd(this, _includeRawScriptCoverage, false);
    __privateSet(this, _client2, client);
  }
  /**
   * @internal
   */
  updateClient(client) {
    __privateSet(this, _client2, client);
  }
  async start(options = {}) {
    assert(!__privateGet(this, _enabled), "JSCoverage is already enabled");
    const { resetOnNavigation = true, reportAnonymousScripts = false, includeRawScriptCoverage = false, useBlockCoverage = true } = options;
    __privateSet(this, _resetOnNavigation, resetOnNavigation);
    __privateSet(this, _reportAnonymousScripts, reportAnonymousScripts);
    __privateSet(this, _includeRawScriptCoverage, includeRawScriptCoverage);
    __privateSet(this, _enabled, true);
    __privateGet(this, _scriptURLs).clear();
    __privateGet(this, _scriptSources).clear();
    __privateSet(this, _subscriptions, new DisposableStack());
    const clientEmitter = __privateGet(this, _subscriptions).use(new EventEmitter(__privateGet(this, _client2)));
    clientEmitter.on("Debugger.scriptParsed", __privateMethod(this, _onScriptParsed, onScriptParsed_fn).bind(this));
    clientEmitter.on("Runtime.executionContextsCleared", __privateMethod(this, _onExecutionContextsCleared, onExecutionContextsCleared_fn).bind(this));
    await Promise.all([
      __privateGet(this, _client2).send("Profiler.enable"),
      __privateGet(this, _client2).send("Profiler.startPreciseCoverage", {
        callCount: __privateGet(this, _includeRawScriptCoverage),
        detailed: useBlockCoverage
      }),
      __privateGet(this, _client2).send("Debugger.enable"),
      __privateGet(this, _client2).send("Debugger.setSkipAllPauses", { skip: true })
    ]);
  }
  async stop() {
    var _a;
    assert(__privateGet(this, _enabled), "JSCoverage is not enabled");
    __privateSet(this, _enabled, false);
    const result = await Promise.all([
      __privateGet(this, _client2).send("Profiler.takePreciseCoverage"),
      __privateGet(this, _client2).send("Profiler.stopPreciseCoverage"),
      __privateGet(this, _client2).send("Profiler.disable"),
      __privateGet(this, _client2).send("Debugger.disable")
    ]);
    (_a = __privateGet(this, _subscriptions)) == null ? void 0 : _a.dispose();
    const coverage = [];
    const profileResponse = result[0];
    for (const entry of profileResponse.result) {
      let url = __privateGet(this, _scriptURLs).get(entry.scriptId);
      if (!url && __privateGet(this, _reportAnonymousScripts)) {
        url = "debugger://VM" + entry.scriptId;
      }
      const text = __privateGet(this, _scriptSources).get(entry.scriptId);
      if (text === void 0 || url === void 0) {
        continue;
      }
      const flattenRanges = [];
      for (const func of entry.functions) {
        flattenRanges.push(...func.ranges);
      }
      const ranges = convertToDisjointRanges(flattenRanges);
      if (!__privateGet(this, _includeRawScriptCoverage)) {
        coverage.push({ url, ranges, text });
      } else {
        coverage.push({ url, ranges, text, rawScriptCoverage: entry });
      }
    }
    return coverage;
  }
};
_client2 = new WeakMap();
_enabled = new WeakMap();
_scriptURLs = new WeakMap();
_scriptSources = new WeakMap();
_subscriptions = new WeakMap();
_resetOnNavigation = new WeakMap();
_reportAnonymousScripts = new WeakMap();
_includeRawScriptCoverage = new WeakMap();
_onExecutionContextsCleared = new WeakSet();
onExecutionContextsCleared_fn = function() {
  if (!__privateGet(this, _resetOnNavigation)) {
    return;
  }
  __privateGet(this, _scriptURLs).clear();
  __privateGet(this, _scriptSources).clear();
};
_onScriptParsed = new WeakSet();
onScriptParsed_fn = async function(event) {
  if (PuppeteerURL.isPuppeteerURL(event.url)) {
    return;
  }
  if (!event.url && !__privateGet(this, _reportAnonymousScripts)) {
    return;
  }
  try {
    const response = await __privateGet(this, _client2).send("Debugger.getScriptSource", {
      scriptId: event.scriptId
    });
    __privateGet(this, _scriptURLs).set(event.scriptId, event.url);
    __privateGet(this, _scriptSources).set(event.scriptId, response.scriptSource);
  } catch (error) {
    debugError(error);
  }
};
var _client3, _enabled2, _stylesheetURLs, _stylesheetSources, _eventListeners, _resetOnNavigation2, _onExecutionContextsCleared2, onExecutionContextsCleared_fn2, _onStyleSheet, onStyleSheet_fn;
var CSSCoverage = class {
  constructor(client) {
    __privateAdd(this, _onExecutionContextsCleared2);
    __privateAdd(this, _onStyleSheet);
    __privateAdd(this, _client3, void 0);
    __privateAdd(this, _enabled2, false);
    __privateAdd(this, _stylesheetURLs, /* @__PURE__ */ new Map());
    __privateAdd(this, _stylesheetSources, /* @__PURE__ */ new Map());
    __privateAdd(this, _eventListeners, void 0);
    __privateAdd(this, _resetOnNavigation2, false);
    __privateSet(this, _client3, client);
  }
  /**
   * @internal
   */
  updateClient(client) {
    __privateSet(this, _client3, client);
  }
  async start(options = {}) {
    assert(!__privateGet(this, _enabled2), "CSSCoverage is already enabled");
    const { resetOnNavigation = true } = options;
    __privateSet(this, _resetOnNavigation2, resetOnNavigation);
    __privateSet(this, _enabled2, true);
    __privateGet(this, _stylesheetURLs).clear();
    __privateGet(this, _stylesheetSources).clear();
    __privateSet(this, _eventListeners, new DisposableStack());
    const clientEmitter = __privateGet(this, _eventListeners).use(new EventEmitter(__privateGet(this, _client3)));
    clientEmitter.on("CSS.styleSheetAdded", __privateMethod(this, _onStyleSheet, onStyleSheet_fn).bind(this));
    clientEmitter.on("Runtime.executionContextsCleared", __privateMethod(this, _onExecutionContextsCleared2, onExecutionContextsCleared_fn2).bind(this));
    await Promise.all([
      __privateGet(this, _client3).send("DOM.enable"),
      __privateGet(this, _client3).send("CSS.enable"),
      __privateGet(this, _client3).send("CSS.startRuleUsageTracking")
    ]);
  }
  async stop() {
    var _a;
    assert(__privateGet(this, _enabled2), "CSSCoverage is not enabled");
    __privateSet(this, _enabled2, false);
    const ruleTrackingResponse = await __privateGet(this, _client3).send("CSS.stopRuleUsageTracking");
    await Promise.all([
      __privateGet(this, _client3).send("CSS.disable"),
      __privateGet(this, _client3).send("DOM.disable")
    ]);
    (_a = __privateGet(this, _eventListeners)) == null ? void 0 : _a.dispose();
    const styleSheetIdToCoverage = /* @__PURE__ */ new Map();
    for (const entry of ruleTrackingResponse.ruleUsage) {
      let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
      if (!ranges) {
        ranges = [];
        styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
      }
      ranges.push({
        startOffset: entry.startOffset,
        endOffset: entry.endOffset,
        count: entry.used ? 1 : 0
      });
    }
    const coverage = [];
    for (const styleSheetId of __privateGet(this, _stylesheetURLs).keys()) {
      const url = __privateGet(this, _stylesheetURLs).get(styleSheetId);
      assert(typeof url !== "undefined", `Stylesheet URL is undefined (styleSheetId=${styleSheetId})`);
      const text = __privateGet(this, _stylesheetSources).get(styleSheetId);
      assert(typeof text !== "undefined", `Stylesheet text is undefined (styleSheetId=${styleSheetId})`);
      const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
      coverage.push({ url, ranges, text });
    }
    return coverage;
  }
};
_client3 = new WeakMap();
_enabled2 = new WeakMap();
_stylesheetURLs = new WeakMap();
_stylesheetSources = new WeakMap();
_eventListeners = new WeakMap();
_resetOnNavigation2 = new WeakMap();
_onExecutionContextsCleared2 = new WeakSet();
onExecutionContextsCleared_fn2 = function() {
  if (!__privateGet(this, _resetOnNavigation2)) {
    return;
  }
  __privateGet(this, _stylesheetURLs).clear();
  __privateGet(this, _stylesheetSources).clear();
};
_onStyleSheet = new WeakSet();
onStyleSheet_fn = async function(event) {
  const header = event.header;
  if (!header.sourceURL) {
    return;
  }
  try {
    const response = await __privateGet(this, _client3).send("CSS.getStyleSheetText", {
      styleSheetId: header.styleSheetId
    });
    __privateGet(this, _stylesheetURLs).set(header.styleSheetId, header.sourceURL);
    __privateGet(this, _stylesheetSources).set(header.styleSheetId, response.text);
  } catch (error) {
    debugError(error);
  }
};
function convertToDisjointRanges(nestedRanges) {
  const points = [];
  for (const range of nestedRanges) {
    points.push({ offset: range.startOffset, type: 0, range });
    points.push({ offset: range.endOffset, type: 1, range });
  }
  points.sort((a, b) => {
    if (a.offset !== b.offset) {
      return a.offset - b.offset;
    }
    if (a.type !== b.type) {
      return b.type - a.type;
    }
    const aLength = a.range.endOffset - a.range.startOffset;
    const bLength = b.range.endOffset - b.range.startOffset;
    if (a.type === 0) {
      return bLength - aLength;
    }
    return aLength - bLength;
  });
  const hitCountStack = [];
  const results = [];
  let lastOffset = 0;
  for (const point of points) {
    if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
      const lastResult = results[results.length - 1];
      if (lastResult && lastResult.end === lastOffset) {
        lastResult.end = point.offset;
      } else {
        results.push({ start: lastOffset, end: point.offset });
      }
    }
    lastOffset = point.offset;
    if (point.type === 0) {
      hitCountStack.push(point.range.count);
    } else {
      hitCountStack.pop();
    }
  }
  return results.filter((range) => {
    return range.end - range.start > 0;
  });
}

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/EmulationManager.js
var __runInitializers5 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate5 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn)
      context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access)
      context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.unshift(_);
      else
        descriptor[key] = _;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __setFunctionName = function(f, name, prefix) {
  if (typeof name === "symbol")
    name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
var _state, _clientProvider, _updater;
var EmulatedState = class {
  constructor(initialState, clientProvider, updater) {
    __privateAdd(this, _state, void 0);
    __privateAdd(this, _clientProvider, void 0);
    __privateAdd(this, _updater, void 0);
    __privateSet(this, _state, initialState);
    __privateSet(this, _clientProvider, clientProvider);
    __privateSet(this, _updater, updater);
    __privateGet(this, _clientProvider).registerState(this);
  }
  async setState(state) {
    __privateSet(this, _state, state);
    await this.sync();
  }
  get state() {
    return __privateGet(this, _state);
  }
  async sync() {
    await Promise.all(__privateGet(this, _clientProvider).clients().map((client) => {
      return __privateGet(this, _updater).call(this, client, __privateGet(this, _state));
    }));
  }
};
_state = new WeakMap();
_clientProvider = new WeakMap();
_updater = new WeakMap();
var EmulationManager = (() => {
  var _client5, _emulatingMobile, _hasTouch, _states, _viewportState, _idleOverridesState, _timezoneState, _visionDeficiencyState, _cpuThrottlingState, _mediaFeaturesState, _mediaTypeState, _geoLocationState, _defaultBackgroundColorState, _javascriptEnabledState, _secondaryClients, _applyViewport, applyViewport_get, _emulateIdleState, emulateIdleState_get, _emulateTimezone, emulateTimezone_get, _emulateVisionDeficiency, emulateVisionDeficiency_get, _emulateCpuThrottling, emulateCpuThrottling_get, _emulateMediaFeatures, emulateMediaFeatures_get, _emulateMediaType, emulateMediaType_get, _setGeolocation, setGeolocation_get, _setDefaultBackgroundColor, setDefaultBackgroundColor_get, _setJavaScriptEnabled, setJavaScriptEnabled_get, _a;
  let _instanceExtraInitializers = [];
  let _private_applyViewport_decorators;
  let _private_applyViewport_descriptor;
  let _private_emulateIdleState_decorators;
  let _private_emulateIdleState_descriptor;
  let _private_emulateTimezone_decorators;
  let _private_emulateTimezone_descriptor;
  let _private_emulateVisionDeficiency_decorators;
  let _private_emulateVisionDeficiency_descriptor;
  let _private_emulateCpuThrottling_decorators;
  let _private_emulateCpuThrottling_descriptor;
  let _private_emulateMediaFeatures_decorators;
  let _private_emulateMediaFeatures_descriptor;
  let _private_emulateMediaType_decorators;
  let _private_emulateMediaType_descriptor;
  let _private_setGeolocation_decorators;
  let _private_setGeolocation_descriptor;
  let _private_setDefaultBackgroundColor_decorators;
  let _private_setDefaultBackgroundColor_descriptor;
  let _private_setJavaScriptEnabled_decorators;
  let _private_setJavaScriptEnabled_descriptor;
  return _a = class {
    constructor(client) {
      __privateAdd(this, _applyViewport);
      __privateAdd(this, _emulateIdleState);
      __privateAdd(this, _emulateTimezone);
      __privateAdd(this, _emulateVisionDeficiency);
      __privateAdd(this, _emulateCpuThrottling);
      __privateAdd(this, _emulateMediaFeatures);
      __privateAdd(this, _emulateMediaType);
      __privateAdd(this, _setGeolocation);
      __privateAdd(this, _setDefaultBackgroundColor);
      __privateAdd(this, _setJavaScriptEnabled);
      __privateAdd(this, _client5, (__runInitializers5(this, _instanceExtraInitializers), void 0));
      __privateAdd(this, _emulatingMobile, false);
      __privateAdd(this, _hasTouch, false);
      __privateAdd(this, _states, []);
      __privateAdd(this, _viewportState, new EmulatedState({
        active: false
      }, this, __privateGet(this, _applyViewport, applyViewport_get)));
      __privateAdd(this, _idleOverridesState, new EmulatedState({
        active: false
      }, this, __privateGet(this, _emulateIdleState, emulateIdleState_get)));
      __privateAdd(this, _timezoneState, new EmulatedState({
        active: false
      }, this, __privateGet(this, _emulateTimezone, emulateTimezone_get)));
      __privateAdd(this, _visionDeficiencyState, new EmulatedState({
        active: false
      }, this, __privateGet(this, _emulateVisionDeficiency, emulateVisionDeficiency_get)));
      __privateAdd(this, _cpuThrottlingState, new EmulatedState({
        active: false
      }, this, __privateGet(this, _emulateCpuThrottling, emulateCpuThrottling_get)));
      __privateAdd(this, _mediaFeaturesState, new EmulatedState({
        active: false
      }, this, __privateGet(this, _emulateMediaFeatures, emulateMediaFeatures_get)));
      __privateAdd(this, _mediaTypeState, new EmulatedState({
        active: false
      }, this, __privateGet(this, _emulateMediaType, emulateMediaType_get)));
      __privateAdd(this, _geoLocationState, new EmulatedState({
        active: false
      }, this, __privateGet(this, _setGeolocation, setGeolocation_get)));
      __privateAdd(this, _defaultBackgroundColorState, new EmulatedState({
        active: false
      }, this, __privateGet(this, _setDefaultBackgroundColor, setDefaultBackgroundColor_get)));
      __privateAdd(this, _javascriptEnabledState, new EmulatedState({
        javaScriptEnabled: true,
        active: false
      }, this, __privateGet(this, _setJavaScriptEnabled, setJavaScriptEnabled_get)));
      __privateAdd(this, _secondaryClients, /* @__PURE__ */ new Set());
      __privateSet(this, _client5, client);
    }
    updateClient(client) {
      __privateSet(this, _client5, client);
      __privateGet(this, _secondaryClients).delete(client);
    }
    registerState(state) {
      __privateGet(this, _states).push(state);
    }
    clients() {
      return [__privateGet(this, _client5), ...Array.from(__privateGet(this, _secondaryClients))];
    }
    async registerSpeculativeSession(client) {
      __privateGet(this, _secondaryClients).add(client);
      client.once(CDPSessionEvent.Disconnected, () => {
        __privateGet(this, _secondaryClients).delete(client);
      });
      void Promise.all(__privateGet(this, _states).map((s) => {
        return s.sync().catch(debugError);
      }));
    }
    get javascriptEnabled() {
      return __privateGet(this, _javascriptEnabledState).state.javaScriptEnabled;
    }
    async emulateViewport(viewport) {
      await __privateGet(this, _viewportState).setState({
        viewport,
        active: true
      });
      const mobile = viewport.isMobile || false;
      const hasTouch = viewport.hasTouch || false;
      const reloadNeeded = __privateGet(this, _emulatingMobile) !== mobile || __privateGet(this, _hasTouch) !== hasTouch;
      __privateSet(this, _emulatingMobile, mobile);
      __privateSet(this, _hasTouch, hasTouch);
      return reloadNeeded;
    }
    async emulateIdleState(overrides) {
      await __privateGet(this, _idleOverridesState).setState({
        active: true,
        overrides
      });
    }
    async emulateTimezone(timezoneId) {
      await __privateGet(this, _timezoneState).setState({
        timezoneId,
        active: true
      });
    }
    async emulateVisionDeficiency(type) {
      const visionDeficiencies = /* @__PURE__ */ new Set([
        "none",
        "achromatopsia",
        "blurredVision",
        "deuteranopia",
        "protanopia",
        "tritanopia"
      ]);
      assert(!type || visionDeficiencies.has(type), `Unsupported vision deficiency: ${type}`);
      await __privateGet(this, _visionDeficiencyState).setState({
        active: true,
        visionDeficiency: type
      });
    }
    async emulateCPUThrottling(factor) {
      assert(factor === null || factor >= 1, "Throttling rate should be greater or equal to 1");
      await __privateGet(this, _cpuThrottlingState).setState({
        active: true,
        factor: factor ?? void 0
      });
    }
    async emulateMediaFeatures(features) {
      if (Array.isArray(features)) {
        for (const mediaFeature of features) {
          const name = mediaFeature.name;
          assert(/^(?:prefers-(?:color-scheme|reduced-motion)|color-gamut)$/.test(name), "Unsupported media feature: " + name);
        }
      }
      await __privateGet(this, _mediaFeaturesState).setState({
        active: true,
        mediaFeatures: features
      });
    }
    async emulateMediaType(type) {
      assert(type === "screen" || type === "print" || (type ?? void 0) === void 0, "Unsupported media type: " + type);
      await __privateGet(this, _mediaTypeState).setState({
        type,
        active: true
      });
    }
    async setGeolocation(options) {
      const { longitude, latitude, accuracy = 0 } = options;
      if (longitude < -180 || longitude > 180) {
        throw new Error(`Invalid longitude "${longitude}": precondition -180 <= LONGITUDE <= 180 failed.`);
      }
      if (latitude < -90 || latitude > 90) {
        throw new Error(`Invalid latitude "${latitude}": precondition -90 <= LATITUDE <= 90 failed.`);
      }
      if (accuracy < 0) {
        throw new Error(`Invalid accuracy "${accuracy}": precondition 0 <= ACCURACY failed.`);
      }
      await __privateGet(this, _geoLocationState).setState({
        active: true,
        geoLocation: {
          longitude,
          latitude,
          accuracy
        }
      });
    }
    /**
     * Resets default white background
     */
    async resetDefaultBackgroundColor() {
      await __privateGet(this, _defaultBackgroundColorState).setState({
        active: true,
        color: void 0
      });
    }
    /**
     * Hides default white background
     */
    async setTransparentBackgroundColor() {
      await __privateGet(this, _defaultBackgroundColorState).setState({
        active: true,
        color: { r: 0, g: 0, b: 0, a: 0 }
      });
    }
    async setJavaScriptEnabled(enabled) {
      await __privateGet(this, _javascriptEnabledState).setState({
        active: true,
        javaScriptEnabled: enabled
      });
    }
  }, _client5 = new WeakMap(), _emulatingMobile = new WeakMap(), _hasTouch = new WeakMap(), _states = new WeakMap(), _viewportState = new WeakMap(), _idleOverridesState = new WeakMap(), _timezoneState = new WeakMap(), _visionDeficiencyState = new WeakMap(), _cpuThrottlingState = new WeakMap(), _mediaFeaturesState = new WeakMap(), _mediaTypeState = new WeakMap(), _geoLocationState = new WeakMap(), _defaultBackgroundColorState = new WeakMap(), _javascriptEnabledState = new WeakMap(), _secondaryClients = new WeakMap(), _applyViewport = new WeakSet(), applyViewport_get = function() {
    return _private_applyViewport_descriptor.value;
  }, _emulateIdleState = new WeakSet(), emulateIdleState_get = function() {
    return _private_emulateIdleState_descriptor.value;
  }, _emulateTimezone = new WeakSet(), emulateTimezone_get = function() {
    return _private_emulateTimezone_descriptor.value;
  }, _emulateVisionDeficiency = new WeakSet(), emulateVisionDeficiency_get = function() {
    return _private_emulateVisionDeficiency_descriptor.value;
  }, _emulateCpuThrottling = new WeakSet(), emulateCpuThrottling_get = function() {
    return _private_emulateCpuThrottling_descriptor.value;
  }, _emulateMediaFeatures = new WeakSet(), emulateMediaFeatures_get = function() {
    return _private_emulateMediaFeatures_descriptor.value;
  }, _emulateMediaType = new WeakSet(), emulateMediaType_get = function() {
    return _private_emulateMediaType_descriptor.value;
  }, _setGeolocation = new WeakSet(), setGeolocation_get = function() {
    return _private_setGeolocation_descriptor.value;
  }, _setDefaultBackgroundColor = new WeakSet(), setDefaultBackgroundColor_get = function() {
    return _private_setDefaultBackgroundColor_descriptor.value;
  }, _setJavaScriptEnabled = new WeakSet(), setJavaScriptEnabled_get = function() {
    return _private_setJavaScriptEnabled_descriptor.value;
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
    _private_applyViewport_decorators = [invokeAtMostOnceForArguments];
    _private_emulateIdleState_decorators = [invokeAtMostOnceForArguments];
    _private_emulateTimezone_decorators = [invokeAtMostOnceForArguments];
    _private_emulateVisionDeficiency_decorators = [invokeAtMostOnceForArguments];
    _private_emulateCpuThrottling_decorators = [invokeAtMostOnceForArguments];
    _private_emulateMediaFeatures_decorators = [invokeAtMostOnceForArguments];
    _private_emulateMediaType_decorators = [invokeAtMostOnceForArguments];
    _private_setGeolocation_decorators = [invokeAtMostOnceForArguments];
    _private_setDefaultBackgroundColor_decorators = [invokeAtMostOnceForArguments];
    _private_setJavaScriptEnabled_decorators = [invokeAtMostOnceForArguments];
    __esDecorate5(_a, _private_applyViewport_descriptor = { value: __setFunctionName(async function(client, viewportState) {
      if (!viewportState.viewport) {
        return;
      }
      const { viewport } = viewportState;
      const mobile = viewport.isMobile || false;
      const width = viewport.width;
      const height = viewport.height;
      const deviceScaleFactor = viewport.deviceScaleFactor ?? 1;
      const screenOrientation = viewport.isLandscape ? { angle: 90, type: "landscapePrimary" } : { angle: 0, type: "portraitPrimary" };
      const hasTouch = viewport.hasTouch || false;
      await Promise.all([
        client.send("Emulation.setDeviceMetricsOverride", {
          mobile,
          width,
          height,
          deviceScaleFactor,
          screenOrientation
        }).catch((err) => {
          if (err.message.includes("Target does not support metrics override")) {
            debugError(err);
            return;
          }
          throw err;
        }),
        client.send("Emulation.setTouchEmulationEnabled", {
          enabled: hasTouch
        })
      ]);
    }, "#applyViewport") }, _private_applyViewport_decorators, { kind: "method", name: "#applyViewport", static: false, private: true, access: { has: (obj) => __privateIn(_applyViewport, obj), get: (obj) => __privateGet(obj, _applyViewport, applyViewport_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate5(_a, _private_emulateIdleState_descriptor = { value: __setFunctionName(async function(client, idleStateState) {
      if (!idleStateState.active) {
        return;
      }
      if (idleStateState.overrides) {
        await client.send("Emulation.setIdleOverride", {
          isUserActive: idleStateState.overrides.isUserActive,
          isScreenUnlocked: idleStateState.overrides.isScreenUnlocked
        });
      } else {
        await client.send("Emulation.clearIdleOverride");
      }
    }, "#emulateIdleState") }, _private_emulateIdleState_decorators, { kind: "method", name: "#emulateIdleState", static: false, private: true, access: { has: (obj) => __privateIn(_emulateIdleState, obj), get: (obj) => __privateGet(obj, _emulateIdleState, emulateIdleState_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate5(_a, _private_emulateTimezone_descriptor = { value: __setFunctionName(async function(client, timezoneState) {
      if (!timezoneState.active) {
        return;
      }
      try {
        await client.send("Emulation.setTimezoneOverride", {
          timezoneId: timezoneState.timezoneId || ""
        });
      } catch (error) {
        if (isErrorLike(error) && error.message.includes("Invalid timezone")) {
          throw new Error(`Invalid timezone ID: ${timezoneState.timezoneId}`);
        }
        throw error;
      }
    }, "#emulateTimezone") }, _private_emulateTimezone_decorators, { kind: "method", name: "#emulateTimezone", static: false, private: true, access: { has: (obj) => __privateIn(_emulateTimezone, obj), get: (obj) => __privateGet(obj, _emulateTimezone, emulateTimezone_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate5(_a, _private_emulateVisionDeficiency_descriptor = { value: __setFunctionName(async function(client, visionDeficiency) {
      if (!visionDeficiency.active) {
        return;
      }
      await client.send("Emulation.setEmulatedVisionDeficiency", {
        type: visionDeficiency.visionDeficiency || "none"
      });
    }, "#emulateVisionDeficiency") }, _private_emulateVisionDeficiency_decorators, { kind: "method", name: "#emulateVisionDeficiency", static: false, private: true, access: { has: (obj) => __privateIn(_emulateVisionDeficiency, obj), get: (obj) => __privateGet(obj, _emulateVisionDeficiency, emulateVisionDeficiency_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate5(_a, _private_emulateCpuThrottling_descriptor = { value: __setFunctionName(async function(client, state) {
      if (!state.active) {
        return;
      }
      await client.send("Emulation.setCPUThrottlingRate", {
        rate: state.factor ?? 1
      });
    }, "#emulateCpuThrottling") }, _private_emulateCpuThrottling_decorators, { kind: "method", name: "#emulateCpuThrottling", static: false, private: true, access: { has: (obj) => __privateIn(_emulateCpuThrottling, obj), get: (obj) => __privateGet(obj, _emulateCpuThrottling, emulateCpuThrottling_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate5(_a, _private_emulateMediaFeatures_descriptor = { value: __setFunctionName(async function(client, state) {
      if (!state.active) {
        return;
      }
      await client.send("Emulation.setEmulatedMedia", {
        features: state.mediaFeatures
      });
    }, "#emulateMediaFeatures") }, _private_emulateMediaFeatures_decorators, { kind: "method", name: "#emulateMediaFeatures", static: false, private: true, access: { has: (obj) => __privateIn(_emulateMediaFeatures, obj), get: (obj) => __privateGet(obj, _emulateMediaFeatures, emulateMediaFeatures_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate5(_a, _private_emulateMediaType_descriptor = { value: __setFunctionName(async function(client, state) {
      if (!state.active) {
        return;
      }
      await client.send("Emulation.setEmulatedMedia", {
        media: state.type || ""
      });
    }, "#emulateMediaType") }, _private_emulateMediaType_decorators, { kind: "method", name: "#emulateMediaType", static: false, private: true, access: { has: (obj) => __privateIn(_emulateMediaType, obj), get: (obj) => __privateGet(obj, _emulateMediaType, emulateMediaType_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate5(_a, _private_setGeolocation_descriptor = { value: __setFunctionName(async function(client, state) {
      if (!state.active) {
        return;
      }
      await client.send("Emulation.setGeolocationOverride", state.geoLocation ? {
        longitude: state.geoLocation.longitude,
        latitude: state.geoLocation.latitude,
        accuracy: state.geoLocation.accuracy
      } : void 0);
    }, "#setGeolocation") }, _private_setGeolocation_decorators, { kind: "method", name: "#setGeolocation", static: false, private: true, access: { has: (obj) => __privateIn(_setGeolocation, obj), get: (obj) => __privateGet(obj, _setGeolocation, setGeolocation_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate5(_a, _private_setDefaultBackgroundColor_descriptor = { value: __setFunctionName(async function(client, state) {
      if (!state.active) {
        return;
      }
      await client.send("Emulation.setDefaultBackgroundColorOverride", {
        color: state.color
      });
    }, "#setDefaultBackgroundColor") }, _private_setDefaultBackgroundColor_decorators, { kind: "method", name: "#setDefaultBackgroundColor", static: false, private: true, access: { has: (obj) => __privateIn(_setDefaultBackgroundColor, obj), get: (obj) => __privateGet(obj, _setDefaultBackgroundColor, setDefaultBackgroundColor_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate5(_a, _private_setJavaScriptEnabled_descriptor = { value: __setFunctionName(async function(client, state) {
      if (!state.active) {
        return;
      }
      await client.send("Emulation.setScriptExecutionDisabled", {
        value: !state.javaScriptEnabled
      });
    }, "#setJavaScriptEnabled") }, _private_setJavaScriptEnabled_decorators, { kind: "method", name: "#setJavaScriptEnabled", static: false, private: true, access: { has: (obj) => __privateIn(_setJavaScriptEnabled, obj), get: (obj) => __privateGet(obj, _setJavaScriptEnabled, setJavaScriptEnabled_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata)
      Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a;
})();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Tracing.js
var _client4, _recording, _path;
var Tracing = class {
  /**
   * @internal
   */
  constructor(client) {
    __privateAdd(this, _client4, void 0);
    __privateAdd(this, _recording, false);
    __privateAdd(this, _path, void 0);
    __privateSet(this, _client4, client);
  }
  /**
   * @internal
   */
  updateClient(client) {
    __privateSet(this, _client4, client);
  }
  /**
   * Starts a trace for the current page.
   * @remarks
   * Only one trace can be active at a time per browser.
   *
   * @param options - Optional `TracingOptions`.
   */
  async start(options = {}) {
    assert(!__privateGet(this, _recording), "Cannot start recording trace while already recording trace.");
    const defaultCategories = [
      "-*",
      "devtools.timeline",
      "v8.execute",
      "disabled-by-default-devtools.timeline",
      "disabled-by-default-devtools.timeline.frame",
      "toplevel",
      "blink.console",
      "blink.user_timing",
      "latencyInfo",
      "disabled-by-default-devtools.timeline.stack",
      "disabled-by-default-v8.cpu_profiler"
    ];
    const { path, screenshots = false, categories = defaultCategories } = options;
    if (screenshots) {
      categories.push("disabled-by-default-devtools.screenshot");
    }
    const excludedCategories = categories.filter((cat) => {
      return cat.startsWith("-");
    }).map((cat) => {
      return cat.slice(1);
    });
    const includedCategories = categories.filter((cat) => {
      return !cat.startsWith("-");
    });
    __privateSet(this, _path, path);
    __privateSet(this, _recording, true);
    await __privateGet(this, _client4).send("Tracing.start", {
      transferMode: "ReturnAsStream",
      traceConfig: {
        excludedCategories,
        includedCategories
      }
    });
  }
  /**
   * Stops a trace started with the `start` method.
   * @returns Promise which resolves to buffer with trace data.
   */
  async stop() {
    const contentDeferred = Deferred.create();
    __privateGet(this, _client4).once("Tracing.tracingComplete", async (event) => {
      try {
        assert(event.stream, 'Missing "stream"');
        const readable = await getReadableFromProtocolStream(__privateGet(this, _client4), event.stream);
        const buffer = await getReadableAsBuffer(readable, __privateGet(this, _path));
        contentDeferred.resolve(buffer ?? void 0);
      } catch (error) {
        if (isErrorLike(error)) {
          contentDeferred.reject(error);
        } else {
          contentDeferred.reject(new Error(`Unknown error: ${error}`));
        }
      }
    });
    await __privateGet(this, _client4).send("Tracing.end");
    __privateSet(this, _recording, false);
    return await contentDeferred.valueOrThrow();
  }
};
_client4 = new WeakMap();
_recording = new WeakMap();
_path = new WeakMap();

export {
  WEB_PERMISSION_TO_PROTOCOL_PERMISSION,
  Browser,
  BrowserContext,
  Dialog,
  isErrorLike,
  isErrnoException,
  rewriteError,
  createProtocolErrorMessage,
  stringifyFunction,
  interpolateFunction,
  transposeIterableHandle,
  LazyArg,
  QueryHandler,
  AsyncIterableUtil,
  ARIAQueryHandler,
  ScriptInjector,
  scriptInjector,
  CustomQueryHandlerRegistry,
  customQueryHandlers,
  registerCustomQueryHandler,
  unregisterCustomQueryHandler,
  customQueryHandlerNames,
  clearCustomQueryHandlers,
  PierceQueryHandler,
  PQueryHandler,
  TextQueryHandler,
  XPathQueryHandler,
  getQueryHandlerAndSelector,
  JSHandle,
  ElementHandle,
  LocatorEvent,
  Locator,
  FunctionLocator,
  DelegatedLocator,
  FilteredLocator,
  MappedLocator,
  NodeLocator,
  RaceLocator,
  RETRY_DELAY,
  FrameEvent,
  throwIfDetached,
  Frame,
  DEFAULT_INTERCEPT_RESOLUTION_PRIORITY,
  HTTPRequest,
  InterceptResolutionAction,
  headersArray,
  STATUS_TEXTS,
  handleError,
  HTTPResponse,
  Keyboard,
  MouseButton,
  Mouse,
  Touchscreen,
  TimeoutSettings,
  setDefaultScreenshotOptions,
  Page,
  supportedMetrics,
  WaitTask,
  TaskManager,
  Realm,
  TargetType,
  Target,
  WebWorker,
  Accessibility,
  CallbackRegistry,
  Callback,
  createIncrementalIdGenerator,
  ConsoleMessage,
  Coverage,
  JSCoverage,
  CSSCoverage,
  EmulatedState,
  EmulationManager,
  Tracing
};
/*! Bundled license information:

puppeteer-core/lib/esm/puppeteer/api/Browser.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/BrowserContext.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Dialog.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/ErrorLike.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/HandleIterator.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/LazyArg.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/ElementHandleSymbol.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/Function.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/QueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/AriaQueryHandler.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/ScriptInjector.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/CustomQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/PierceQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/PQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/TextQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/XPathQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/GetQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/JSHandle.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/ElementHandle.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Frame.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/HTTPResponse.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Input.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/TimeoutSettings.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Page.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/WaitTask.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Realm.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Target.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/WebWorker.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Accessibility.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/CallbackRegistry.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/ConsoleMessage.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Coverage.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=chunk-YQ6DKOIU.js.map
