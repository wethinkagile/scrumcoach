{"version":3,"file":"index.cjs","sources":["../../src/interpreter/environment/ecma/ecma-globals.ts","../../src/interpreter/util/descriptor/merge-descriptors.ts","../../src/interpreter/util/object/subtract.ts","../../src/interpreter/util/loader/require-module.ts","../../src/interpreter/environment/node/node-cjs-globals.ts","../../src/interpreter/environment/browser/lib/raf.ts","../../src/interpreter/util/loader/optional-peer-dependency-loader.ts","../../src/interpreter/environment/browser/browser-globals.ts","../../src/interpreter/util/return/return-symbol.ts","../../src/interpreter/util/break/break-symbol.ts","../../src/interpreter/util/continue/continue-symbol.ts","../../src/interpreter/util/this/this-symbol.ts","../../src/interpreter/util/super/super-symbol.ts","../../src/interpreter/environment/node/node-esm-globals.ts","../../src/interpreter/util/declaration/is-declaration.ts","../../src/interpreter/util/flags/is-var-declaration.ts","../../src/interpreter/error/evaluation-error/evaluation-error.ts","../../src/interpreter/error/module-not-found-error/module-not-found-error.ts","../../src/interpreter/error/unexpected-node-error/unexpected-node-error.ts","../../src/interpreter/util/declaration/get-declaration-name.ts","../../src/interpreter/util/module/get-resolved-module-name.ts","../../src/interpreter/util/module/get-implementation-for-declaration-within-declaration-file.ts","../../src/interpreter/util/node/find-nearest-parent-node-of-kind.ts","../../src/interpreter/util/proxy/can-be-observed.ts","../../src/interpreter/util/function/is-bind-call-apply.ts","../../src/interpreter/policy/policy-trap-kind.ts","../../src/interpreter/error/evaluation-error/evaluation-error-intent.ts","../../src/interpreter/proxy/create-policy-proxy.ts","../../src/interpreter/policy/network/network-map.ts","../../src/interpreter/policy/nondeterministic/nondeterministic-map.ts","../../src/interpreter/policy/trap-condition-map.ts","../../src/interpreter/policy/is-trap-condition-met.ts","../../src/interpreter/policy/nondeterministic/is-nondeterministic.ts","../../src/interpreter/error/policy-error/policy-error.ts","../../src/interpreter/error/policy-error/non-deterministic-error/non-deterministic-error.ts","../../src/interpreter/policy/io/io-map.ts","../../src/interpreter/policy/io/is-io-read.ts","../../src/interpreter/error/policy-error/io-error/io-error.ts","../../src/interpreter/policy/io/is-io-write.ts","../../src/interpreter/policy/network/is-network-operation.ts","../../src/interpreter/error/policy-error/network-error/network-error.ts","../../src/interpreter/policy/process/process-map.ts","../../src/interpreter/policy/process/is-process-exit-operation.ts","../../src/interpreter/error/policy-error/process-error/process-error.ts","../../src/interpreter/policy/process/is-process-spawn-child-operation.ts","../../src/interpreter/policy/console/console-map.ts","../../src/interpreter/policy/console/is-console-operation.ts","../../src/interpreter/environment/create-sanitized-environment.ts","../../src/interpreter/lexical-environment/lexical-environment.ts","../../src/interpreter/util/node/is-boolean-literal.ts","../../src/interpreter/util/node/is-null-literal.ts","../../src/interpreter/evaluator/simple/evaluate-simple-literal.ts","../../src/interpreter/error/policy-error/max-ops-exceeded-error/max-ops-exceeded-error.ts","../../src/interpreter/evaluator/evaluate-variable-declaration.ts","../../src/interpreter/util/node/is-this-expression.ts","../../src/interpreter/util/node/is-super-expression.ts","../../src/interpreter/lexical-environment/get-dot-path-from-node.ts","../../src/interpreter/error/undefined-left-value-error/undefined-left-value-error.ts","../../src/interpreter/util/node/get-inner-node.ts","../../src/interpreter/util/node/is-node.ts","../../src/interpreter/evaluator/evaluate-binary-expression.ts","../../src/interpreter/literal/literal.ts","../../src/interpreter/error/not-callable-error/not-callable-error.ts","../../src/interpreter/util/expression/expression-contains-super-keyword.ts","../../src/interpreter/evaluator/evaluate-call-expression.ts","../../src/interpreter/evaluator/evaluate-parenthesized-expression.ts","../../src/interpreter/lexical-environment/clone-lexical-environment.ts","../../src/interpreter/util/modifier/has-modifier.ts","../../src/interpreter/evaluator/evaluate-parameter-declarations.ts","../../src/interpreter/evaluator/evaluate-arrow-function-expression.ts","../../src/interpreter/evaluator/evaluate-string-literal.ts","../../src/interpreter/evaluator/evaluate-numeric-literal.ts","../../src/interpreter/evaluator/evaluate-boolean-literal.ts","../../src/interpreter/evaluator/evaluate-regular-expression-literal.ts","../../src/interpreter/evaluator/evaluate-object-literal-expression.ts","../../src/interpreter/util/iterable/is-iterable.ts","../../src/interpreter/evaluator/evaluate-array-literal-expression.ts","../../src/interpreter/error/undefined-identifier-error/undefined-identifier-error.ts","../../src/interpreter/evaluator/evaluate-identifier.ts","../../src/interpreter/evaluator/evaluate-block.ts","../../src/interpreter/evaluator/evaluate-return-statement.ts","../../src/interpreter/evaluator/evaluate-variable-declaration-list.ts","../../src/interpreter/evaluator/evaluate-variable-statement.ts","../../src/interpreter/evaluator/evaluate-prefix-unary-expression.ts","../../src/interpreter/evaluator/evaluate-property-access-expression.ts","../../src/interpreter/evaluator/evaluate-element-access-expression.ts","../../src/interpreter/evaluator/evaluate-computed-property-name.ts","../../src/interpreter/evaluator/evaluate-function-declaration.ts","../../src/interpreter/evaluator/evaluate-if-statement.ts","../../src/interpreter/evaluator/evaluate-expression-statement.ts","../../src/interpreter/evaluator/evaluate-template-expression.ts","../../src/interpreter/evaluator/evaluate-type-assertion-expression.ts","../../src/interpreter/evaluator/evaluate-postfix-unary-expression.ts","../../src/interpreter/evaluator/evaluate-new-expression.ts","../../src/interpreter/evaluator/evaluate-non-null-expression.ts","../../src/interpreter/evaluator/evaluate-as-expression.ts","../../src/interpreter/evaluator/evaluate-switch-statement.ts","../../src/interpreter/error/async-iterator-not-supported-error/async-iterator-not-supported-error.ts","../../src/interpreter/evaluator/evaluate-for-of-statement.ts","../../src/interpreter/evaluator/evaluate-this-expression.ts","../../src/interpreter/evaluator/evaluate-break-statement.ts","../../src/interpreter/evaluator/evaluate-continue-statement.ts","../../src/interpreter/evaluator/evaluate-for-statement.ts","../../src/interpreter/evaluator/evaluate-while-statement.ts","../../src/interpreter/evaluator/evaluate-for-in-statement.ts","../../src/interpreter/evaluator/evaluate-function-expression.ts","../../src/interpreter/error/missing-catch-or-finally-after-try-error/missing-catch-or-finally-after-try-error.ts","../../src/interpreter/evaluator/evaluate-try-statement.ts","../../src/interpreter/util/class/generate-class-declaration.ts","../../src/interpreter/util/node/modifier-util.ts","../../src/interpreter/evaluator/evaluate-class-declaration.ts","../../src/interpreter/evaluator/evaluate-constructor-declaration.ts","../../src/interpreter/evaluator/evaluate-super-expression.ts","../../src/interpreter/evaluator/evaluate-spread-element.ts","../../src/interpreter/evaluator/evaluate-class-expression.ts","../../src/interpreter/evaluator/evaluate-null-literal.ts","../../src/interpreter/evaluator/evaluate-void-expression.ts","../../src/interpreter/evaluator/evaluate-type-of-expression.ts","../../src/interpreter/evaluator/evaluate-big-int-literal.ts","../../src/interpreter/evaluator/evaluate-enum-declaration.ts","../../src/interpreter/evaluator/evaluate-source-file-as-namespace-object.ts","../../src/interpreter/evaluator/evaluate-module-declaration.ts","../../src/interpreter/evaluator/evaluate-import-declaration.ts","../../src/interpreter/evaluator/evaluate-throw-statement.ts","../../src/interpreter/evaluator/evaluate-import-equals-declaration.ts","../../src/interpreter/error/policy-error/max-op-duration-exceeded-error/max-op-duration-exceeded-error.ts","../../src/interpreter/evaluator/evaluate-await-expression.ts","../../src/interpreter/evaluator/evaluate-conditional-expression.ts","../../src/interpreter/util/static/in-static-context.ts","../../src/interpreter/evaluator/evaluate-method-declaration.ts","../../src/interpreter/evaluator/evaluate-property-declaration.ts","../../src/interpreter/evaluator/evaluate-get-accessor-declaration.ts","../../src/interpreter/evaluator/evaluate-type-alias-declaration.ts","../../src/interpreter/evaluator/evaluate-interface-declaration.ts","../../src/interpreter/evaluator/evaluate-import-clause.ts","../../src/interpreter/evaluator/evaluate-import-specifier.ts","../../src/interpreter/evaluator/evaluate-namespace-import.ts","../../src/interpreter/error/unexpected-syntax-error/unexpected-syntax-error.ts","../../src/interpreter/evaluator/evaluate-meta-property.ts","../../src/interpreter/evaluator/evaluate-node.ts","../../src/interpreter/stack/traversal-stack/statement-traversal-stack.ts","../../src/interpreter/evaluator/evaluate-statement.ts","../../src/interpreter/evaluator/evaluate-expression.ts","../../src/interpreter/evaluator/evaluate-declaration.ts","../../src/interpreter/evaluator/evaluate-binding-name.ts","../../src/interpreter/evaluator/evaluate-set-accessor-declaration.ts","../../src/interpreter/evaluator/evaluate-property-assignment.ts","../../src/interpreter/evaluator/evaluate-parameter-declaration.ts","../../src/interpreter/evaluator/evaluate-shorthand-property-assignment.ts","../../src/interpreter/evaluator/evaluate-spread-assignment.ts","../../src/interpreter/evaluator/evaluate-array-binding-pattern.ts","../../src/interpreter/evaluator/evaluate-binding-element.ts","../../src/interpreter/evaluator/evaluate-object-binding-pattern.ts","../../src/interpreter/evaluator/evaluate-case-block.ts","../../src/interpreter/evaluator/evaluate-case-clause.ts","../../src/interpreter/evaluator/evaluate-default-clause.ts","../../src/interpreter/evaluator/evaluate-catch-clause.ts","../../src/interpreter/evaluator/evaluate-omitted-expression.ts","../../src/interpreter/util/tslib/tslib-util.ts","../../src/interpreter/evaluator/evaluate-decorator.ts","../../src/interpreter/evaluator/evaluate-enum-member.ts","../../src/interpreter/evaluator/evaluate-node-with-argument.ts","../../src/interpreter/evaluator/evaluate-property-name.ts","../../src/interpreter/evaluator/evaluate-node-with-value.ts","../../src/interpreter/evaluator/node-evaluator/create-node-evaluator.ts","../../src/interpreter/logger/log-level.ts","../../src/interpreter/util/syntax-kind/stringify-syntax-kind.ts","../../src/interpreter/logger/logger.ts","../../src/interpreter/util/expression/is-expression.ts","../../src/interpreter/util/statement/is-statement.ts","../../src/interpreter/stack/stack.ts","../../src/interpreter/util/reporting/report-error.ts","../../src/interpreter/reporting/reported-error-set.ts","../../src/interpreter/evaluate.ts"],"sourcesContent":["import type {IndexLiteral} from \"../../literal/literal.js\";\n\nexport const ECMA_GLOBALS = () => {\n\t/* eslint-disable @typescript-eslint/naming-convention */\n\tconst base: IndexLiteral = {\n\t\tInfinity,\n\t\tNaN,\n\t\tundefined,\n\t\tisNaN,\n\t\tparseFloat,\n\t\tparseInt,\n\t\tdecodeURI,\n\t\tdecodeURIComponent,\n\t\tencodeURI,\n\t\tencodeURIComponent,\n\t\tArray,\n\t\tBoolean,\n\t\tDate,\n\t\tError,\n\t\tEvalError,\n\t\tNumber,\n\t\tObject,\n\t\tRangeError,\n\t\tReferenceError,\n\t\tRegExp,\n\t\tString,\n\t\tSyntaxError,\n\t\tTypeError,\n\t\tURIError,\n\t\tJSON,\n\t\tMath,\n\t\tescape,\n\t\tunescape,\n\t\t// eslint-disable-next-line no-eval\n\t\teval,\n\t\tFunction\n\t\t/* eslint-enable @typescript-eslint/naming-convention */\n\t};\n\n\ttry {\n\t\tbase.AggregateError = AggregateError;\n\t} catch {}\n\n\ttry {\n\t\tbase.FinalizationRegistry = FinalizationRegistry;\n\t} catch {}\n\n\ttry {\n\t\tbase.WeakRef = WeakRef;\n\t} catch {}\n\n\ttry {\n\t\tbase.BigInt = BigInt;\n\t} catch {}\n\n\ttry {\n\t\tbase.Reflect = Reflect;\n\t} catch {}\n\n\ttry {\n\t\tbase.WeakMap = WeakMap;\n\t} catch {}\n\n\ttry {\n\t\tbase.WeakSet = WeakSet;\n\t} catch {}\n\n\ttry {\n\t\tbase.Set = Set;\n\t} catch {}\n\n\ttry {\n\t\tbase.Map = Map;\n\t} catch {}\n\n\ttry {\n\t\tbase.Uint8Array = Uint8Array;\n\t} catch {}\n\n\ttry {\n\t\tbase.BigUint64Array = BigUint64Array;\n\t} catch {}\n\n\ttry {\n\t\tbase.BigInt64Array = BigInt64Array;\n\t} catch {}\n\n\ttry {\n\t\tbase.Atomics = Atomics;\n\t} catch {}\n\n\ttry {\n\t\tbase.SharedArrayBuffer = SharedArrayBuffer;\n\t} catch {}\n\n\ttry {\n\t\tbase.WebAssembly = WebAssembly;\n\t} catch {}\n\n\ttry {\n\t\tbase.Uint8ClampedArray = Uint8ClampedArray;\n\t} catch {}\n\n\ttry {\n\t\tbase.Uint16Array = Uint16Array;\n\t} catch {}\n\n\ttry {\n\t\tbase.Uint32Array = Uint32Array;\n\t} catch {}\n\n\ttry {\n\t\tbase.Intl = Intl;\n\t} catch {}\n\n\ttry {\n\t\tbase.Int8Array = Int8Array;\n\t} catch {}\n\n\ttry {\n\t\tbase.Int16Array = Int16Array;\n\t} catch {}\n\n\ttry {\n\t\tbase.Int32Array = Int32Array;\n\t} catch {}\n\n\ttry {\n\t\tbase.Float32Array = Float32Array;\n\t} catch {}\n\n\ttry {\n\t\tbase.Float64Array = Float64Array;\n\t} catch {}\n\n\ttry {\n\t\tbase.ArrayBuffer = ArrayBuffer;\n\t} catch {}\n\n\ttry {\n\t\tbase.DataView = DataView;\n\t} catch {}\n\n\ttry {\n\t\tbase.isFinite = isFinite;\n\t} catch {}\n\n\ttry {\n\t\tbase.Promise = Promise;\n\t} catch {}\n\n\ttry {\n\t\tbase.Proxy = Proxy;\n\t} catch {}\n\n\ttry {\n\t\tbase.Symbol = Symbol;\n\t} catch {}\n\n\treturn base;\n};\n","/* eslint-disable @typescript-eslint/ban-types */\n\n/**\n * Merges all of the given descriptors\n */\nexport function mergeDescriptors<A extends object>(a: A): A;\nexport function mergeDescriptors<A extends object, B extends object>(a: A, b: B): A & B;\nexport function mergeDescriptors<A extends object, B extends object, C extends object>(a: A, b: B, c: C): A & B & C;\nexport function mergeDescriptors<A extends object, B extends object, C extends object>(a: A, b?: B, c?: C): A & B & C {\n\tconst newObj = {} as A & B & C;\n\tconst normalizedB = b == null ? {} : b;\n\tconst normalizedC = c == null ? {} : c;\n\t[a, normalizedB, normalizedC].forEach(item => Object.defineProperties(newObj, Object.getOwnPropertyDescriptors(item)));\n\treturn newObj;\n}\n","/* eslint-disable @typescript-eslint/ban-types */\n\nexport type Subtract<T, K extends Partial<T>> = {\n\t[Key in Exclude<keyof T, keyof K>]: T[Key];\n};\n\n/**\n * Excludes the properties of B from A\n */\nexport function subtract<A extends object, B extends Partial<A>>(a: A, b: B): Subtract<A, B> {\n\tconst newA = {} as Exclude<A, keyof B>;\n\tObject.getOwnPropertyNames(a).forEach(name => {\n\t\tif (!(name in b)) {\n\t\t\tObject.defineProperty(newA, name, Object.getOwnPropertyDescriptor(a, name)!);\n\t\t}\n\t});\n\treturn newA;\n}\n","import {createRequire} from \"module\";\n\n// Until import.meta.resolve becomes stable, we'll have to do this instead\nexport const requireModule = createRequire(import.meta.url);","/* eslint-disable @typescript-eslint/naming-convention */\nimport {mergeDescriptors} from \"../../util/descriptor/merge-descriptors.js\";\nimport {ECMA_GLOBALS} from \"../ecma/ecma-globals.js\";\nimport {subtract} from \"../../util/object/subtract.js\";\nimport path from \"crosspath\";\nimport {requireModule} from \"../../util/loader/require-module.js\";\n\nexport const NODE_CJS_GLOBALS = () => {\n\tconst ecmaGlobals = ECMA_GLOBALS();\n\tconst merged = mergeDescriptors(subtract(global, ecmaGlobals), ecmaGlobals, {\n\t\trequire: requireModule,\n\t\tprocess,\n\t\t__dirname: (fileName: string) => path.native.normalize(path.native.dirname(fileName)),\n\t\t__filename: (fileName: string) => path.native.normalize(fileName)\n\t});\n\n\tObject.defineProperties(merged, {\n\t\tglobal: {\n\t\t\tget(): typeof merged {\n\t\t\t\treturn merged;\n\t\t\t}\n\t\t},\n\t\tglobalThis: {\n\t\t\tget(): typeof merged {\n\t\t\t\treturn merged;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn merged;\n};\n","export interface IRafImplementationNamespace {\n\trequestAnimationFrame(callback: FrameRequestCallback): number;\n\tcancelAnimationFrame(handle: number): void;\n}\n\n/**\n * Returns an object containing the properties that are relevant to 'requestAnimationFrame' and 'requestIdleCallback'\n */\nexport function rafImplementation(global: typeof window): IRafImplementationNamespace {\n\tlet lastTime = 0;\n\n\tconst _requestAnimationFrame = function requestAnimationFrame(callback: FrameRequestCallback): number {\n\t\tconst currTime = new Date().getTime();\n\n\t\tconst timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\n\t\tconst id = global.setTimeout(function () {\n\t\t\tcallback(currTime + timeToCall);\n\t\t}, timeToCall);\n\n\t\tlastTime = currTime + timeToCall;\n\n\t\treturn id;\n\t};\n\n\tconst _cancelAnimationFrame = function cancelAnimationFrame(id: number): void {\n\t\tclearTimeout(id);\n\t};\n\n\treturn {\n\t\trequestAnimationFrame: _requestAnimationFrame,\n\t\tcancelAnimationFrame: _cancelAnimationFrame\n\t};\n}\n","import type {JSDOM} from \"../../../type/jsdom.js\";\nimport { requireModule } from \"./require-module.js\";\n\n/**\n * The jsdom module is optionally imported on-demand as needed\n */\nlet jsdomModule: typeof JSDOM | undefined;\n\nexport function loadJsdom(required: true): typeof JSDOM;\nexport function loadJsdom(required: false): typeof JSDOM | undefined;\nexport function loadJsdom(required?: boolean): typeof JSDOM | undefined;\nexport function loadJsdom(required = false): typeof JSDOM | undefined {\n\treturn (jsdomModule ??= loadModules(\"evaluate against a browser environment\", required, \"jsdom\"));\n}\n\nfunction loadModules<T = never>(description: string, required: boolean, moduleSpecifier = description): T | undefined {\n\ttry {\n\t\treturn requireModule(moduleSpecifier) as T;\n\t} catch (ex) {\n\t\tif (required) {\n\t\t\tthrow new ReferenceError(`You must install the peer dependency '${moduleSpecifier}' in order to ${description} with ts-evaluator`);\n\t\t}\n\t\treturn undefined;\n\t}\n}\n","import {rafImplementation} from \"./lib/raf.js\";\nimport {loadJsdom} from \"../../util/loader/optional-peer-dependency-loader.js\";\nimport {subtract} from \"../../util/object/subtract.js\";\nimport {ECMA_GLOBALS} from \"../ecma/ecma-globals.js\";\n\nexport const BROWSER_GLOBALS = () => {\n\tconst {JSDOM} = loadJsdom(true);\n\tconst {window} = new JSDOM(\"\", {url: \"https://example.com\"});\n\n\tconst ecmaGlobals = ECMA_GLOBALS();\n\n\t// Add requestAnimationFrame/cancelAnimationFrame if missing\n\tif (window.requestAnimationFrame == null) {\n\t\tconst raf = rafImplementation(window as unknown as Window & typeof globalThis);\n\t\tObject.defineProperties(window, Object.getOwnPropertyDescriptors(raf));\n\t}\n\n\t// Add all missing Ecma Globals to the JSDOM window\n\tconst missingEcmaGlobals = subtract(ecmaGlobals, window);\n\tif (Object.keys(missingEcmaGlobals).length > 0) {\n\t\tObject.defineProperties(window, Object.getOwnPropertyDescriptors(ecmaGlobals));\n\t}\n\n\treturn window;\n};\n","export const RETURN_SYMBOL = \"[return]\";\n","export const BREAK_SYMBOL = \"[break]\";\n","export const CONTINUE_SYMBOL = \"[continue]\";\n","export const THIS_SYMBOL = \"this\";\n","export const SUPER_SYMBOL = \"super\";\n","import {mergeDescriptors} from \"../../util/descriptor/merge-descriptors.js\";\nimport {ECMA_GLOBALS} from \"../ecma/ecma-globals.js\";\nimport {subtract} from \"../../util/object/subtract.js\";\nimport path from \"crosspath\";\nexport const NODE_ESM_GLOBALS = () => {\n\tconst ecmaGlobals = ECMA_GLOBALS();\n\tconst merged = mergeDescriptors(subtract(global, ecmaGlobals), ecmaGlobals, {\n\t\timport: {\n\t\t\tmeta: {\n\t\t\t\turl: (fileName: string) => {\n\t\t\t\t\tconst normalized = path.normalize(fileName);\n\t\t\t\t\treturn `file:///${normalized.startsWith(`/`) ? normalized.slice(1) : normalized}`;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tprocess\n\t});\n\n\tObject.defineProperties(merged, {\n\t\tglobal: {\n\t\t\tget(): typeof merged {\n\t\t\t\treturn merged;\n\t\t\t}\n\t\t},\n\t\tglobalThis: {\n\t\t\tget(): typeof merged {\n\t\t\t\treturn merged;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn merged;\n};\n","import type {TS} from \"../../../type/ts.js\";\n\n/**\n * Returns true if the given Node is a Declaration\n * Uses an internal non-exposed Typescript helper to decide whether or not the Node is a declaration\n */\nexport function isDeclaration(node: TS.Node, typescript: typeof TS): node is TS.Declaration {\n\treturn (typescript as unknown as {isDeclaration(node: TS.Node): boolean}).isDeclaration(node);\n}\n\nexport function isNamedDeclaration(node: TS.Node | TS.NamedDeclaration, typescript: typeof TS): node is TS.NamedDeclaration {\n\tif (typescript.isPropertyAccessExpression(node)) return false;\n\treturn \"name\" in node && node.name != null;\n}\n","import type {TS} from \"../../../type/ts.js\";\n\n/**\n * Returns true if the given VariableDeclarationList is declared with a 'var' keyword\n */\nexport function isVarDeclaration(declarationList: TS.VariableDeclarationList, typescript: typeof TS): boolean {\n\treturn declarationList.flags !== typescript.NodeFlags.Const && declarationList.flags !== typescript.NodeFlags.Let;\n}\n","import type {IEvaluationErrorOptions} from \"./i-evaluation-error-options.js\";\nimport type {TS} from \"../../../type/ts.js\";\nimport type { LexicalEnvironment } from \"../../lexical-environment/lexical-environment.js\";\n\nexport type ThrowError = (error: EvaluationError) => EvaluationError;\n\n/**\n * A Base class for EvaluationErrors\n */\nexport class EvaluationError extends Error {\n\t/**\n\t * The node that caused or thew the error\n\t */\n\treadonly node: TS.Node;\n\treadonly environment: LexicalEnvironment;\n\n\tconstructor({node, environment, message}: IEvaluationErrorOptions) {\n\t\tsuper(message);\n\t\tError.captureStackTrace(this, this.constructor);\n\t\tthis.node = node;\n\t\tthis.environment = environment;\n\t}\n}\n\nexport function isEvaluationError (item: unknown): item is EvaluationError {\n\treturn typeof item === \"object\" && item != null && item instanceof EvaluationError;\n}","import {EvaluationError} from \"../evaluation-error/evaluation-error.js\";\nimport type {IModuleNotFoundErrorOptions} from \"./i-module-not-found-error-options.js\";\n\n/**\n * An Error that can be thrown when a moduleSpecifier couldn't be resolved\n */\nexport class ModuleNotFoundError extends EvaluationError {\n\t/**\n\t * The path/moduleName that could not be resolved\n\t */\n\treadonly path: string;\n\n\tconstructor({path, node, environment, message = `Module '${path}' could not be resolved'`}: IModuleNotFoundErrorOptions) {\n\t\tsuper({message, environment, node});\n\t\tthis.path = path;\n\t}\n}\n","import {EvaluationError} from \"../evaluation-error/evaluation-error.js\";\nimport type {IUnexpectedNodeErrorOptions} from \"./i-unexpected-node-error-options.js\";\n\n/**\n * An Error that can be thrown when an unexpected node is encountered\n */\nexport class UnexpectedNodeError extends EvaluationError {\n\tconstructor({node, environment, typescript, message = `Unexpected Node: '${typescript.SyntaxKind[node.kind]}'`}: IUnexpectedNodeErrorOptions) {\n\t\tsuper({message, node, environment});\n\t}\n}\n","import type {EvaluatorOptions} from \"../../evaluator/evaluator-options.js\";\nimport {UnexpectedNodeError} from \"../../error/unexpected-node-error/unexpected-node-error.js\";\nimport type {TS} from \"../../../type/ts.js\";\nimport type { EvaluationError } from \"../../error/evaluation-error/evaluation-error.js\";\n\n/**\n * Gets the name of the given declaration\n */\nexport function getDeclarationName(options: EvaluatorOptions<TS.Declaration>): string | number | EvaluationError | undefined {\n\tconst {node, evaluate, environment, typescript, throwError} = options;\n\tconst name = typescript.getNameOfDeclaration(node);\n\tif (name == null) return undefined;\n\n\tif (typescript.isIdentifier(name)) {\n\t\treturn name.text;\n\t} else if (typescript.isPrivateIdentifier?.(name)) {\n\t\treturn name.text;\n\t} else if (typescript.isStringLiteralLike(name)) {\n\t\treturn name.text;\n\t} else if (typescript.isNumericLiteral(name)) {\n\t\treturn Number(name.text);\n\t} else if (typescript.isComputedPropertyName(name)) {\n\t\treturn evaluate.expression(name.expression, options) as ReturnType<typeof getDeclarationName>;\n\t} else {\n\t\treturn throwError(new UnexpectedNodeError({node: name, environment, typescript}));\n\t}\n}\n","import path from \"crosspath\";\nimport type { TS } from \"../../../type/ts.js\";\nimport type { EvaluatorOptions } from \"../../evaluator/evaluator-options.js\";\n\nexport function getResolvedModuleName (moduleSpecifier: string, options: EvaluatorOptions<TS.Node>): string {\n    const {node, typescript} = options;\n    if (!typescript.isExternalModuleNameRelative(moduleSpecifier)) {\n        return moduleSpecifier;\n    }\n\n    const parentPath = node.getSourceFile().fileName;\n    return path.join(path.dirname(parentPath), moduleSpecifier);\n}","import {findNearestParentNodeOfKind} from \"../node/find-nearest-parent-node-of-kind.js\";\nimport type {Literal} from \"../../literal/literal.js\";\nimport {ModuleNotFoundError} from \"../../error/module-not-found-error/module-not-found-error.js\";\nimport {UnexpectedNodeError} from \"../../error/unexpected-node-error/unexpected-node-error.js\";\nimport type {EvaluatorOptions} from \"../../evaluator/evaluator-options.js\";\nimport {getDeclarationName} from \"../declaration/get-declaration-name.js\";\nimport {isEvaluationError} from \"../../error/evaluation-error/evaluation-error.js\";\nimport {getFromLexicalEnvironment} from \"../../lexical-environment/lexical-environment.js\";\nimport type {TS} from \"../../../type/ts.js\";\nimport {getResolvedModuleName} from \"./get-resolved-module-name.js\";\n\n/**\n * Gets an implementation for the given declaration that lives within a declaration file\n */\nexport function getImplementationForDeclarationWithinDeclarationFile(options: EvaluatorOptions<TS.Declaration>): Literal {\n\tconst {node, typescript, throwError, environment} = options;\n\tconst name = getDeclarationName(options);\n\n\tif (isEvaluationError(name)) {\n\t\treturn name;\n\t}\n\n\tif (name == null) {\n\t\treturn throwError(new UnexpectedNodeError({node, environment, typescript}));\n\t}\n\n\t// First see if it lives within the lexical environment\n\tconst matchInLexicalEnvironment = getFromLexicalEnvironment(node, options.environment, name as string);\n\t// If so, return it\n\tif (matchInLexicalEnvironment != null && matchInLexicalEnvironment.literal != null) {\n\t\treturn matchInLexicalEnvironment.literal;\n\t}\n\n\t// Otherwise, expect it to be something that is require'd on demand\n\tconst require = getFromLexicalEnvironment(node, options.environment, \"require\")!.literal as NodeRequire;\n\n\tconst moduleDeclaration = typescript.isModuleDeclaration(node)\n\t\t? node\n\t\t: findNearestParentNodeOfKind<TS.ModuleDeclaration>(node, typescript.SyntaxKind.ModuleDeclaration, typescript);\n\tif (moduleDeclaration == null) {\n\t\treturn throwError(new UnexpectedNodeError({node, environment, typescript}));\n\t}\n\tconst moduleSpecifier = moduleDeclaration.name.text;\n\tconst resolvedModuleSpecifier = getResolvedModuleName(moduleSpecifier, options);\n\ttry {\n\n\t\t// eslint-disable-next-line @typescript-eslint/no-require-imports,@typescript-eslint/no-var-requires\n\t\tconst module = options.moduleOverrides?.[moduleSpecifier] ??  options.moduleOverrides?.[resolvedModuleSpecifier] ?? require(resolvedModuleSpecifier);\n\t\treturn typescript.isModuleDeclaration(node) ? module : module[name] ?? module;\n\t} catch (ex) {\n\t\tif (isEvaluationError(ex)) return ex;\n\t\telse return throwError(new ModuleNotFoundError({node: moduleDeclaration, environment, path: resolvedModuleSpecifier}));\n\t}\n}\n\nexport function getImplementationFromExternalFile(name: string, moduleSpecifier: string, options: EvaluatorOptions<TS.Node>): Literal {\n\tconst {node, throwError, environment} = options;\n\n\tconst require = getFromLexicalEnvironment(node, options.environment, \"require\")!.literal as NodeRequire;\n\tconst resolvedModuleSpecifier = getResolvedModuleName(moduleSpecifier, options);\n\n\ttry {\n\t\t// eslint-disable-next-line @typescript-eslint/no-require-imports,@typescript-eslint/no-var-requires\n\t\tconst module = options.moduleOverrides?.[moduleSpecifier] ?? options.moduleOverrides?.[resolvedModuleSpecifier] ?? require(resolvedModuleSpecifier);\n\t\treturn module[name] ?? module.default ?? module;\n\t} catch (ex) {\n\t\tif (isEvaluationError(ex)) return ex;\n\t\telse return throwError(new ModuleNotFoundError({node, environment, path: resolvedModuleSpecifier}));\n\t}\n}\n","import type {TS} from \"../../../type/ts.js\";\nimport type {EvaluatorOptions} from \"../../evaluator/evaluator-options.js\";\nimport type {Literal} from \"../../literal/literal.js\";\nimport {isDeclaration, isNamedDeclaration} from \"../declaration/is-declaration.js\";\nimport {isVarDeclaration} from \"../flags/is-var-declaration.js\";\nimport {getImplementationFromExternalFile} from \"../module/get-implementation-for-declaration-within-declaration-file.js\";\n\n/**\n * Finds the nearest parent node of the given kind from the given Node\n */\nexport function findNearestParentNodeOfKind<T extends TS.Node>(from: TS.Node, kind: TS.SyntaxKind, typescript: typeof TS): T | undefined {\n\tlet currentParent = from;\n\twhile (true) {\n\t\tcurrentParent = currentParent.parent;\n\t\tif (currentParent == null) return undefined;\n\t\tif (currentParent.kind === kind) {\n\t\t\tconst combinedNodeFlags = typescript.getCombinedNodeFlags(currentParent);\n\t\t\tconst isNamespace = (combinedNodeFlags & typescript.NodeFlags.Namespace) !== 0 || (combinedNodeFlags & typescript.NodeFlags.NestedNamespace) !== 0;\n\t\t\tif (!isNamespace) return currentParent as T;\n\t\t}\n\n\t\tif (typescript.isSourceFile(currentParent)) return undefined;\n\t}\n}\n\n/**\n * Finds the nearest parent node with the given name from the given Node\n */\nexport function findNearestParentNodeWithName<T extends TS.Node>(\n\tfrom: TS.Node,\n\tname: string,\n\toptions: EvaluatorOptions<T>,\n\tvisitedRoots = new WeakSet<TS.Node>()\n): T | Literal | undefined {\n\tconst {typescript} = options;\n\tlet result: TS.Node | Literal | undefined;\n\n\tfunction visit(nextNode: TS.Node, nestingLayer = 0): boolean {\n\t\tif (visitedRoots.has(nextNode)) return false;\n\t\tvisitedRoots.add(nextNode);\n\n\t\tif (typescript.isIdentifier(nextNode)) {\n\t\t\tif (nextNode.text === name) {\n\t\t\t\tresult = nextNode;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (typescript.isShorthandPropertyAssignment(nextNode)) {\n\t\t\treturn false;\n\t\t} else if (typescript.isPropertyAssignment(nextNode)) {\n\t\t\treturn false;\n\t\t} else if (typescript.isImportDeclaration(nextNode)) {\n\t\t\tif (nextNode.importClause != null) {\n\t\t\t\tif (nextNode.importClause.name != null && visit(nextNode.importClause.name)) {\n\t\t\t\t\tconst moduleSpecifier = nextNode.moduleSpecifier;\n\t\t\t\t\tif (moduleSpecifier != null && typescript.isStringLiteralLike(moduleSpecifier)) {\n\t\t\t\t\t\tresult = getImplementationFromExternalFile(name, moduleSpecifier.text, options);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (nextNode.importClause.namedBindings != null && visit(nextNode.importClause.namedBindings)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} else if (typescript.isImportEqualsDeclaration(nextNode)) {\n\t\t\tif (nextNode.name != null && visit(nextNode.name)) {\n\t\t\t\tif (typescript.isIdentifier(nextNode.moduleReference)) {\n\t\t\t\t\tresult = findNearestParentNodeWithName(nextNode.parent, nextNode.moduleReference.text, options, visitedRoots);\n\t\t\t\t\treturn result != null;\n\t\t\t\t} else if (typescript.isQualifiedName(nextNode.moduleReference)) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tconst moduleSpecifier = nextNode.moduleReference.expression;\n\t\t\t\t\tif (moduleSpecifier != null && typescript.isStringLiteralLike(moduleSpecifier)) {\n\t\t\t\t\t\tresult = getImplementationFromExternalFile(name, moduleSpecifier.text, options);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} else if (typescript.isNamespaceImport(nextNode)) {\n\t\t\tif (visit(nextNode.name)) {\n\t\t\t\tconst moduleSpecifier = nextNode.parent?.parent?.moduleSpecifier;\n\t\t\t\tif (moduleSpecifier == null || !typescript.isStringLiteralLike(moduleSpecifier)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tresult = getImplementationFromExternalFile(name, moduleSpecifier.text, options);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (typescript.isNamedImports(nextNode)) {\n\t\t\tfor (const importSpecifier of nextNode.elements) {\n\t\t\t\tif (visit(importSpecifier)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (typescript.isImportSpecifier(nextNode)) {\n\t\t\tif (visit(nextNode.name)) {\n\t\t\t\tconst moduleSpecifier = nextNode.parent?.parent?.parent?.moduleSpecifier;\n\t\t\t\tif (moduleSpecifier == null || !typescript.isStringLiteralLike(moduleSpecifier)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tresult = getImplementationFromExternalFile(name, moduleSpecifier.text, options);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (typescript.isSourceFile(nextNode)) {\n\t\t\tfor (const statement of nextNode.statements) {\n\t\t\t\tif (visit(statement)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (typescript.isVariableStatement(nextNode)) {\n\t\t\tfor (const declaration of nextNode.declarationList.declarations) {\n\t\t\t\tif (visit(declaration) && (isVarDeclaration(nextNode.declarationList, typescript) || nestingLayer < 1)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (typescript.isBlock(nextNode)) {\n\t\t\tfor (const statement of nextNode.statements) {\n\t\t\t\tif (visit(statement, nestingLayer + 1)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isNamedDeclaration(nextNode, typescript)) {\n\t\t\tif (nextNode.name != null && visit(nextNode.name)) {\n\t\t\t\tresult = nextNode;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tconst suceeded = typescript.findAncestor<T>(from, (nextNode): nextNode is T => visit(nextNode));\n\treturn !suceeded ? undefined : (result as T | undefined);\n}\n\nexport function getStatementContext<T extends TS.Declaration = TS.Declaration>(from: TS.Node, typescript: typeof TS): T | undefined {\n\tlet currentParent = from;\n\twhile (true) {\n\t\tcurrentParent = currentParent.parent;\n\t\tif (currentParent == null) return undefined;\n\t\tif (isDeclaration(currentParent, typescript) || typescript.isSourceFile(currentParent)) {\n\t\t\treturn currentParent as T;\n\t\t}\n\t}\n}\n","/**\n * Returns true if the provided value is ObjectLike\n *\n * @param value\n * @returns\n */\nexport function isObjectLike<T>(value: T): boolean {\n\treturn value != null && (typeof value === \"function\" || typeof value === \"object\");\n}\n\n/**\n * Returns true if the given value can be observed\n *\n * @param value\n * @returns\n */\nexport function canBeObserved<T>(value: T): boolean {\n\treturn isObjectLike(value);\n}\n","import type { LexicalEnvironment} from \"../../lexical-environment/lexical-environment.js\";\nimport {getFromLexicalEnvironment} from \"../../lexical-environment/lexical-environment.js\";\n\n/**\n * Returns true if the given function is either Function.prototype.bind, Function.prototype.call, or Function.prototype.apply\n *\n * @param func\n * @param [environment]\n * @return\n */\nexport function isBindCallApply(func: CallableFunction, environment?: LexicalEnvironment): boolean {\n\tswitch (func) {\n\t\tcase Function.prototype.bind:\n\t\tcase Function.prototype.call:\n\t\tcase Function.prototype.apply:\n\t\t\treturn true;\n\t}\n\n\tif (environment != null) {\n\t\tconst _Function = getFromLexicalEnvironment(undefined, environment, \"Function\")!.literal as CallableFunction;\n\t\tswitch (func) {\n\t\t\tcase _Function.prototype.bind:\n\t\t\tcase _Function.prototype.call:\n\t\t\tcase _Function.prototype.apply:\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n","export const enum PolicyTrapKind {\n\tGET = \"__$$_PROXY_GET\",\n\tAPPLY = \"__$$_PROXY_APPLY\",\n\tCONSTRUCT = \"__$$_PROXY_CONSTRUCT\"\n}\n\n/**\n * Stringifies the given PolicyTrapKind on the given path\n *\n * @param kind\n * @param path\n * @return\n */\nexport function stringifyPolicyTrapKindOnPath(kind: PolicyTrapKind, path: string): string {\n\tswitch (kind) {\n\t\tcase PolicyTrapKind.GET:\n\t\t\treturn `get ${path}`;\n\n\t\tcase PolicyTrapKind.APPLY:\n\t\t\treturn `${path}(...)`;\n\n\t\tcase PolicyTrapKind.CONSTRUCT:\n\t\t\treturn `new ${path}(...)`;\n\t}\n}\n","import type {TS} from \"../../../type/ts.js\";\nimport type {NextEvaluatorOptions} from \"../../evaluator/evaluator-options.js\";\nimport type {EvaluationError} from \"./evaluation-error.js\";\n\ntype EvaluationErrorIntentCallback<T extends EvaluationError> = (node: TS.Node, options: NextEvaluatorOptions) => T;\n\nexport class EvaluationErrorIntent<T extends EvaluationError = EvaluationError> {\n\tconstructor(private readonly intent: EvaluationErrorIntentCallback<T>) {}\n\tconstruct(node: TS.Node, options: NextEvaluatorOptions): T {\n\t\treturn this.intent(node, options);\n\t}\n}\n\nexport function isEvaluationErrorIntent<T extends EvaluationError = EvaluationError>(item: unknown): item is EvaluationErrorIntent<T> {\n\treturn typeof item === \"object\" && item != null && item instanceof EvaluationErrorIntent;\n}\n\nexport function maybeThrow<Value>(node: TS.Node, options: NextEvaluatorOptions, value: Value | EvaluationErrorIntent): Value | EvaluationError {\n\treturn isEvaluationErrorIntent(value) ? options.throwError(value.construct(node, options)) : value;\n}\n","/* eslint-disable @typescript-eslint/ban-types */\nimport {canBeObserved} from \"../util/proxy/can-be-observed.js\";\nimport type {ICreatePolicyProxyOptions} from \"./i-create-policy-proxy-options.js\";\nimport {isBindCallApply} from \"../util/function/is-bind-call-apply.js\";\nimport {PolicyTrapKind} from \"../policy/policy-trap-kind.js\";\nimport type {EvaluationErrorIntent} from \"../error/evaluation-error/evaluation-error-intent.js\";\nimport { isEvaluationErrorIntent} from \"../error/evaluation-error/evaluation-error-intent.js\";\nimport { isEvaluationError } from \"../error/evaluation-error/evaluation-error.js\";\n\n/**\n * Stringifies the given PropertyKey path\n */\nfunction stringifyPath(path: PropertyKey[]): string {\n\treturn path.map(part => (typeof part === \"symbol\" ? part.description : part)).join(\".\");\n}\n\n/**\n * Creates a proxy with hooks to check the given policy\n */\nexport function createPolicyProxy<T extends object>({hook, item, scope, policy}: ICreatePolicyProxyOptions<T, object>): T {\n\t/**\n\t * Creates a trap that captures function invocation\n\t */\n\tfunction createAccessTrap<U extends object>(inputPath: PropertyKey[], currentItem: U): U {\n\t\tconst handleHookResult = (result: boolean | EvaluationErrorIntent, successCallback: CallableFunction) => {\n\t\t\tif (result === false) return;\n\t\t\tif (isEvaluationErrorIntent(result) || isEvaluationError(result)) return result;\n\t\t\treturn successCallback();\n\t\t};\n\n\t\treturn !canBeObserved(currentItem) || isBindCallApply(currentItem as Function)\n\t\t\t? currentItem\n\t\t\t: new Proxy(currentItem, {\n\t\t\t\t\t/**\n\t\t\t\t\t * Constructs a new instance of the given target\n\t\t\t\t\t */\n\t\t\t\t\tconstruct(target: U, argArray: unknown[], newTarget?: Function): object {\n\t\t\t\t\t\treturn handleHookResult(\n\t\t\t\t\t\t\thook({\n\t\t\t\t\t\t\t\tkind: PolicyTrapKind.CONSTRUCT,\n\t\t\t\t\t\t\t\tpolicy,\n\t\t\t\t\t\t\t\tnewTarget,\n\t\t\t\t\t\t\t\targArray,\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tpath: stringifyPath(inputPath)\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t() => Reflect.construct(target as Function, argArray, newTarget)\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n\t\t\t\t\t * A trap for a function call. Used to create new proxies for methods on the retrieved module objects\n\t\t\t\t\t */\n\t\t\t\t\tapply(target: U, thisArg: unknown, argArray: unknown[] = []): unknown {\n\t\t\t\t\t\treturn handleHookResult(\n\t\t\t\t\t\t\thook({\n\t\t\t\t\t\t\t\tkind: PolicyTrapKind.APPLY,\n\t\t\t\t\t\t\t\tpolicy,\n\t\t\t\t\t\t\t\tthisArg,\n\t\t\t\t\t\t\t\targArray,\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tpath: stringifyPath(inputPath)\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t() => Reflect.apply(target as Function, thisArg, argArray)\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Gets a trap for 'get' accesses\n\t\t\t\t\t */\n\t\t\t\t\tget(target: U, property: string, receiver: unknown): unknown {\n\t\t\t\t\t\tconst newPath = [...inputPath, property];\n\t\t\t\t\t\treturn handleHookResult(\n\t\t\t\t\t\t\thook({\n\t\t\t\t\t\t\t\tkind: PolicyTrapKind.GET,\n\t\t\t\t\t\t\t\tpolicy,\n\t\t\t\t\t\t\t\tpath: stringifyPath(newPath),\n\t\t\t\t\t\t\t\ttarget\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\tconst match = Reflect.get(target, property, receiver);\n\n\t\t\t\t\t\t\t\tconst config = Reflect.getOwnPropertyDescriptor(currentItem, property);\n\t\t\t\t\t\t\t\tif (config != null && config.configurable === false && config.writable === false) {\n\t\t\t\t\t\t\t\t\treturn currentItem[property as keyof U];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn createAccessTrap(newPath, match as object);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t  });\n\t}\n\n\treturn !canBeObserved(item) ? item : createAccessTrap([scope], item);\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\nimport {PolicyTrapKind} from \"../policy-trap-kind.js\";\nimport type {TrapConditionMap} from \"../trap-condition-map.js\";\nimport type {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals.js\";\n\n/**\n * A Map between built-in modules and the kind of IO operations their members performs\n * @type {TrapConditionMap<NodeBuiltInsAndGlobals>}\n */\nexport const NETWORK_MAP: TrapConditionMap<NodeBuiltInsAndGlobals> = {\n\t\"node:http2\": \"http2\",\n\thttp2: {\n\t\tconnect: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tcreateSecureServer: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tcreateServer: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t}\n\t},\n\n\t\"node:https\": \"https\",\n\n\thttps: {\n\t\tcreateServer: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\trequest: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tget: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tServer: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t},\n\t\tglobalAgent: {\n\t\t\tdestroy: {\n\t\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t\t}\n\t\t},\n\t\tAgent: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t}\n\t},\n\n\t\"node:http\": \"http\",\n\n\thttp: {\n\t\tcreateServer: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\trequest: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tget: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tServer: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t},\n\t\tClientRequest: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t},\n\t\tglobalAgent: {\n\t\t\tdestroy: {\n\t\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t\t}\n\t\t},\n\t\tAgent: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t}\n\t},\n\n\t\"node:dgram\": \"dgram\",\n\n\tdgram: {\n\t\tcreateSocket: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t}\n\t},\n\n\t\"node:dns\": \"dns\",\n\n\tdns: {\n\t\tlookup: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tlookupService: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolve: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolve4: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolve6: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveAny: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveCname: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveMx: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveNaptr: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveNs: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolvePtr: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveSoa: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveSrv: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveTxt: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\treverse: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tResolver: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t}\n\t},\n\n\t\"node:net\": \"net\",\n\n\tnet: {\n\t\tcreateServer: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tcreateConnection: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tconnect: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tServer: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t}\n\t},\n\n\t\"node:tls\": \"tls\",\n\n\ttls: {\n\t\tcreateServer: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tcreateSecureContext: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tconnect: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tServer: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t},\n\t\tTLSSocket: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t}\n\t}\n};\n","/* eslint-disable @typescript-eslint/naming-convention */\nimport {PolicyTrapKind} from \"../policy-trap-kind.js\";\nimport type {TrapConditionMap} from \"../trap-condition-map.js\";\nimport {NETWORK_MAP} from \"../network/network-map.js\";\nimport type {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals.js\";\n\n/**\n * A Map between built-in identifiers and the members that produce non-deterministic results.\n */\nexport const NONDETERMINISTIC_MAP: TrapConditionMap<NodeBuiltInsAndGlobals> = {\n\t// Any network operation will always be non-deterministic\n\t...NETWORK_MAP,\n\tMath: {\n\t\trandom: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t}\n\t},\n\tDate: {\n\t\tnow: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\t// Dates that receive no arguments are nondeterministic since they care about \"now\" and will evaluate to a new value for each invocation\n\t\t[PolicyTrapKind.CONSTRUCT]: (...args) => args.length === 0 && !(args[0] instanceof Date)\n\t}\n};\n","import type {PolicyTrapKind} from \"./policy-trap-kind.js\";\n\nexport type TrapConditionFunction<ConditionType> = (...args: unknown[]) => ConditionType;\nexport type TrapCondition<ConditionType> = ConditionType | TrapConditionFunction<ConditionType>;\n\nexport type PolicyTrapKindToTrapConditionMap<ConditionType> = {\n\t[key in PolicyTrapKind]?: TrapCondition<ConditionType>;\n};\n\nexport type TrapConditionMap<T, ConditionType = boolean> = {\n\t[Key in keyof T]?: TrapConditionMapValue<T[Key], ConditionType, T>;\n};\n\nexport type TrapConditionMemberMap<T, ConditionType> = {\n\t[Key in keyof T]?: TrapConditionMapValue<T[Key], ConditionType, T>;\n};\n\nexport type TrapConditionMapValue<T, ConditionType, Parent = never> =\n\t| TrapCondition<ConditionType>\n\t| TrapConditionMemberMap<T, ConditionType>\n\t| PolicyTrapKindToTrapConditionMap<ConditionType>\n\n\t/**\n\t * Useful if two modules are identical and should follow the same rules\n\t */\n\t| keyof Parent\n\t| undefined;\n\n/**\n * Returns true if the given item is a TrapCondition\n */\nexport function isTrapCondition<ConditionType>(item: unknown, condition: ConditionType): item is TrapCondition<ConditionType> {\n\t// noinspection SuspiciousTypeOfGuard\n\treturn typeof item === typeof condition || typeof item === \"function\";\n}\n\n/**\n * Returns true if the given item is a TrapCondition\n */\nexport function isTrapConditionFunction<T, ConditionType = boolean>(item: TrapConditionMapValue<T, ConditionType>): item is TrapConditionFunction<ConditionType> {\n\treturn typeof item === \"function\";\n}\n","/* eslint-disable @typescript-eslint/ban-types */\nimport type { PolicyTrapKindToTrapConditionMap, TrapCondition, TrapConditionMap, TrapConditionMemberMap} from \"./trap-condition-map.js\";\nimport {isTrapCondition, isTrapConditionFunction} from \"./trap-condition-map.js\";\nimport type {IPolicyProxyApplyHookOptions, IPolicyProxyConstructHookOptions, PolicyProxyHookOptions} from \"../proxy/policy-proxy-hook.js\";\n\n/**\n * Returns true if the given path represents something that is nondeterministic.\n */\nexport function isTrapConditionMet<T extends object, ConditionType = boolean>(\n\tmap: TrapConditionMap<T, ConditionType>,\n\tcondition: ConditionType,\n\titem: PolicyProxyHookOptions<T>\n): boolean {\n\tconst atoms = item.path.split(\".\") as (keyof T)[];\n\treturn walkAtoms(map, condition, item, atoms);\n}\n\n/**\n * Walks all atoms of the given item path\n */\nfunction walkAtoms<T extends object, ConditionType = boolean>(\n\tmap: TrapConditionMap<T, ConditionType> | TrapConditionMemberMap<T, ConditionType>,\n\tmatchCondition: ConditionType,\n\titem: PolicyProxyHookOptions<T>,\n\tatoms: (keyof T)[]\n): boolean {\n\tconst [head, ...tail] = atoms;\n\tif (head == null) return false;\n\n\tconst mapEntry = map[head];\n\n\t// If nothing was matched within the namespace, the trap wasn't matched\n\tif (mapEntry == null) return false;\n\n\tif (typeof mapEntry === \"string\") {\n\t\treturn walkAtoms(map, matchCondition, item, [mapEntry as keyof T, ...tail]);\n\t}\n\n\tif (isTrapCondition<ConditionType>(mapEntry, matchCondition)) {\n\t\treturn handleTrapCondition(mapEntry, matchCondition, item);\n\t} else {\n\t\tconst trapMapMatch = (mapEntry as PolicyTrapKindToTrapConditionMap<ConditionType>)[item.kind];\n\t\tif (trapMapMatch != null) {\n\t\t\treturn handleTrapCondition(trapMapMatch, matchCondition, item);\n\t\t} else {\n\t\t\treturn walkAtoms(mapEntry as TrapConditionMap<T, ConditionType> | TrapConditionMemberMap<T, ConditionType>, matchCondition, item, tail);\n\t\t}\n\t}\n}\n\n/**\n * Handles a TrapCondition\n */\nfunction handleTrapCondition<T extends object, ConditionType>(\n\ttrapCondition: TrapCondition<ConditionType>,\n\tmatchCondition: ConditionType,\n\titem: PolicyProxyHookOptions<T>\n): boolean {\n\t// If matching the condition depends on the provided arguments, pass them in\n\tif (isTrapConditionFunction(trapCondition)) {\n\t\tconst castItem = item as IPolicyProxyApplyHookOptions<T> | IPolicyProxyConstructHookOptions<T>;\n\t\treturn castItem.argArray != null && trapCondition(...castItem.argArray) === matchCondition;\n\t}\n\n\t// Otherwise, evaluate the truthiness of the condition\n\telse {\n\t\treturn trapCondition === matchCondition;\n\t}\n}\n","import type {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook.js\";\nimport {NONDETERMINISTIC_MAP} from \"./nondeterministic-map.js\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met.js\";\nimport type {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals.js\";\n\n/**\n * Returns true if the given path represents something that is nondeterministic.\n */\nexport function isNonDeterministic(item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(NONDETERMINISTIC_MAP, true, item);\n}\n","import {EvaluationError} from \"../evaluation-error/evaluation-error.js\";\nimport type {IPolicyErrorOptions} from \"./i-policy-error-options.js\";\nimport type {EvaluatePolicySanitized} from \"../../policy/evaluate-policy.js\";\n\n/**\n * An Error that can be thrown when a policy is violated\n */\nexport class PolicyError extends EvaluationError {\n\t/**\n\t * The kind of policy violation encountered\n\t */\n\treadonly violation: keyof EvaluatePolicySanitized;\n\n\tconstructor({violation, node, environment, message}: IPolicyErrorOptions) {\n\t\tsuper({node, environment, message: `[${violation}]: ${message}`});\n\t\tthis.violation = violation;\n\t}\n}\n","import type {INonDeterministicErrorOptions} from \"./i-non-deterministic-error-options.js\";\nimport {PolicyError} from \"../policy-error.js\";\n\n/**\n * An Error that can be thrown when something nondeterministic is attempted to be evaluated and has been disallowed to be so\n */\nexport class NonDeterministicError extends PolicyError {\n\t/**\n\t * The kind of operation that was attempted to be performed but was in violation of the policy\n\t */\n\treadonly operation: string;\n\n\tconstructor({operation, node, environment, message = `The operation: '${operation}' is nondeterministic. That is in violation of the policy`}: INonDeterministicErrorOptions) {\n\t\tsuper({violation: \"deterministic\", message, node, environment});\n\n\t\tthis.operation = operation;\n\t}\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\nimport type {TrapConditionMap} from \"../trap-condition-map.js\";\nimport {PolicyTrapKind} from \"../policy-trap-kind.js\";\nimport type {EvaluateIOPolicy} from \"../evaluate-policy.js\";\nimport type {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals.js\";\n\n/**\n * A Map between built-in modules and the kind of IO operations their members performs\n * @type {TrapConditionMap<NodeBuiltInsAndGlobals, \"read\"|\"write\">}\n */\nexport const IO_MAP: TrapConditionMap<NodeBuiltInsAndGlobals, keyof EvaluateIOPolicy> = {\n\t\"node:fs\": \"fs\",\n\tfs: {\n\t\treadFile: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\treadFileSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\treaddir: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\treaddirSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tread: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\treadSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\texists: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\texistsSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\taccess: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\taccessSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tclose: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tcloseSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tcreateReadStream: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tstat: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tstatSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\twatch: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\twatchFile: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tunwatchFile: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\trealpath: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\trealpathSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tfstat: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tfstatSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tcreateWriteStream: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tcopyFile: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tcopyFileSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tunlink: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tunlinkSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\trmdir: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\trmdirSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tsymlink: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tsymlinkSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\ttruncate: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\ttruncateSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tutimes: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tutimesSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tappendFile: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tappendFileSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\twrite: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\twriteSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\twriteFile: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\twriteFileSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tchmod: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tchmodSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tchown: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tchownSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tmkdir: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tmkdirSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\trename: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\trenameSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfutimes: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfutimesSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tlink: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tlinkSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tmkdtemp: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\topen: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\topenSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfchmod: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfchmodSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfchown: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfchownSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tftruncate: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tftruncateSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfsync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfsyncSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfdatasync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfdatasyncSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tlchmod: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tlchmodSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t}\n\t}\n};\n","import {IO_MAP} from \"./io-map.js\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met.js\";\nimport type {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook.js\";\nimport type {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals.js\";\n\n/**\n * Returns true if the given member represents a READ operation from IO\n */\nexport function isIoRead(item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(IO_MAP, \"read\", item);\n}\n","import type {IIoErrorOptions} from \"./i-io-error-options.js\";\nimport {PolicyError} from \"../policy-error.js\";\nimport type {EvaluateIOPolicy} from \"../../../policy/evaluate-policy.js\";\n\n/**\n * An Error that can be thrown when an IO operation is attempted to be executed that is in violation of the context policy\n */\nexport class IoError extends PolicyError {\n\t/**\n\t * The kind of IO operation that was violated\n\t */\n\treadonly kind: keyof EvaluateIOPolicy;\n\n\tconstructor({node, environment, kind, message = `${kind} operations are in violation of the policy`}: IIoErrorOptions) {\n\t\tsuper({violation: \"io\", message, environment, node});\n\t\tthis.kind = kind;\n\t}\n}\n","import type {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook.js\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met.js\";\nimport {IO_MAP} from \"./io-map.js\";\nimport type {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals.js\";\n\n/**\n * Returns true if the given member represents a WRITE operation from IO\n */\nexport function isIoWrite(item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(IO_MAP, \"write\", item);\n}\n","import type {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook.js\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met.js\";\nimport {NETWORK_MAP} from \"./network-map.js\";\nimport type {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals.js\";\n\n/**\n * Returns true if the given item represents a network operation\n */\nexport function isNetworkOperation(item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(NETWORK_MAP, true, item);\n}\n","import type {INetworkErrorOptions} from \"./i-network-error-options.js\";\nimport {PolicyError} from \"../policy-error.js\";\n\n/**\n * An Error that can be thrown when a network operation is attempted to be executed that is in violation of the context policy\n */\nexport class NetworkError extends PolicyError {\n\t/**\n\t * The kind of operation that was attempted to be performed but was in violation of the policy\n\t */\n\treadonly operation: string;\n\n\tconstructor({operation, node, environment, message = `The operation: '${operation}' is performing network activity. That is in violation of the policy`}: INetworkErrorOptions) {\n\t\tsuper({violation: \"deterministic\", message, node, environment});\n\n\t\tthis.operation = operation;\n\t}\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\nimport {PolicyTrapKind} from \"../policy-trap-kind.js\";\nimport type {TrapConditionMap} from \"../trap-condition-map.js\";\nimport type {EvaluateProcessPolicy} from \"../evaluate-policy.js\";\nimport type {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals.js\";\n\n/**\n * A Map between built-in modules (as well as 'process' and the kind of IO operations their members performs\n */\nexport const PROCESS_MAP: TrapConditionMap<NodeBuiltInsAndGlobals, keyof EvaluateProcessPolicy> = {\n\t\"node:process\": \"process\",\n\tprocess: {\n\t\texit: {\n\t\t\t[PolicyTrapKind.APPLY]: \"exit\"\n\t\t}\n\t},\n\n\t// Everything inside child_process is just one big violation of this policy\n\t\"node:child_process\": \"child_process\",\n\tchild_process: {\n\t\t[PolicyTrapKind.APPLY]: \"spawnChild\"\n\t},\n\n\t\"node:cluster\": \"cluster\",\n\tcluster: {\n\t\tWorker: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: \"spawnChild\"\n\t\t}\n\t}\n};\n","import type {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook.js\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met.js\";\nimport {PROCESS_MAP} from \"./process-map.js\";\nimport type {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals.js\";\n\n/**\n * Returns true if the given item represents a process operation that exits the process\n */\nexport function isProcessExitOperation(item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(PROCESS_MAP, \"exit\", item);\n}\n","import type {IProcessErrorOptions} from \"./i-process-error-options.js\";\nimport {PolicyError} from \"../policy-error.js\";\nimport type {EvaluateProcessPolicy} from \"../../../policy/evaluate-policy.js\";\n\n/**\n * An Error that can be thrown when a Process operation is attempted to be executed that is in violation of the context policy\n */\nexport class ProcessError extends PolicyError {\n\t/**\n\t * The kind of process operation that was violated\n\t */\n\treadonly kind: keyof EvaluateProcessPolicy;\n\n\tconstructor({kind, node, environment, message = `${kind} operations are in violation of the policy`}: IProcessErrorOptions) {\n\t\tsuper({violation: \"process\", message, node, environment});\n\t\tthis.kind = kind;\n\t}\n}\n","import type {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook.js\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met.js\";\nimport {PROCESS_MAP} from \"./process-map.js\";\nimport type {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals.js\";\n\n/**\n * Returns true if the given item represents a process operation that spawns a child\n */\nexport function isProcessSpawnChildOperation(item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(PROCESS_MAP, \"spawnChild\", item);\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\nimport {PolicyTrapKind} from \"../policy-trap-kind.js\";\nimport type {TrapConditionMap} from \"../trap-condition-map.js\";\nimport type {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals.js\";\n\n/**\n * A Map between built-in modules (as well as 'console' and the operations that print to console\n */\nexport const CONSOLE_MAP: TrapConditionMap<NodeBuiltInsAndGlobals> = {\n\t\"node:console\": \"console\",\n\tconsole: {\n\t\t[PolicyTrapKind.APPLY]: true\n\t}\n};\n","import type {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook.js\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met.js\";\nimport {CONSOLE_MAP} from \"./console-map.js\";\nimport type {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals.js\";\n\n/**\n * Returns true if the given item represents an operation that prints to console\n */\nexport function isConsoleOperation(item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(CONSOLE_MAP, true, item);\n}\n","import type {IndexLiteral} from \"../literal/literal.js\";\nimport {createPolicyProxy} from \"../proxy/create-policy-proxy.js\";\nimport {stringifyPolicyTrapKindOnPath} from \"../policy/policy-trap-kind.js\";\nimport {isNonDeterministic} from \"../policy/nondeterministic/is-nondeterministic.js\";\nimport {NonDeterministicError} from \"../error/policy-error/non-deterministic-error/non-deterministic-error.js\";\nimport type {PolicyProxyHookOptions} from \"../proxy/policy-proxy-hook.js\";\nimport {isIoRead} from \"../policy/io/is-io-read.js\";\nimport {IoError} from \"../error/policy-error/io-error/io-error.js\";\nimport {isIoWrite} from \"../policy/io/is-io-write.js\";\nimport {isNetworkOperation} from \"../policy/network/is-network-operation.js\";\nimport {NetworkError} from \"../error/policy-error/network-error/network-error.js\";\nimport {isProcessExitOperation} from \"../policy/process/is-process-exit-operation.js\";\nimport {ProcessError} from \"../error/policy-error/process-error/process-error.js\";\nimport {isProcessSpawnChildOperation} from \"../policy/process/is-process-spawn-child-operation.js\";\nimport type {ICreateSanitizedEnvironmentOptions} from \"./i-create-sanitized-environment-options.js\";\nimport {isConsoleOperation} from \"../policy/console/is-console-operation.js\";\nimport { EvaluationErrorIntent } from \"../error/evaluation-error/evaluation-error-intent.js\";\n\n/**\n * Creates an environment that provide hooks into policy checks\n */\nexport function createSanitizedEnvironment({policy, env}: ICreateSanitizedEnvironmentOptions): IndexLiteral {\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tconst hook = (item: PolicyProxyHookOptions<any>) => {\n\t\tif (!policy.console && isConsoleOperation(item)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!policy.io.read && isIoRead(item)) {\n            return new EvaluationErrorIntent((node, options) => new IoError({...options, node, kind: \"read\"}));\n\t\t}\n\n\t\tif (!policy.io.write && isIoWrite(item)) {\n            return new EvaluationErrorIntent((node, options) => new IoError({...options, node, kind: \"write\"}));\n\t\t}\n\n\t\tif (!policy.process.exit && isProcessExitOperation(item)) {\n            return new EvaluationErrorIntent((node, options) => new ProcessError({...options, node, kind: \"exit\"}));\n\t\t}\n\n\t\tif (!policy.process.exit && isProcessSpawnChildOperation(item)) {\n            return new EvaluationErrorIntent((node, options) => new ProcessError({...options, node, kind: \"spawnChild\"}));\n\t\t}\n\n\t\tif (!policy.network && isNetworkOperation(item)) {\n            return new EvaluationErrorIntent((node, options) => new NetworkError({...options, node, operation: stringifyPolicyTrapKindOnPath(item.kind, item.path)}));\n\t\t}\n\n\t\tif (policy.deterministic && isNonDeterministic(item)) {\n            return new EvaluationErrorIntent((node, options) => new NonDeterministicError({...options, node, operation: stringifyPolicyTrapKindOnPath(item.kind, item.path)}));\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tconst descriptors = Object.entries(Object.getOwnPropertyDescriptors(env));\n\tconst gettersAndSetters = Object.assign({}, ...descriptors.filter(([, descriptor]) => !(\"value\" in descriptor)).map(([name, descriptor]) => ({[name]: descriptor})));\n\n\tconst values = Object.assign(\n\t\t{},\n\t\t...descriptors\n\t\t\t.filter(([, descriptor]) => \"value\" in descriptor)\n\t\t\t.map(([name, descriptor]) => ({\n\t\t\t\t[name]:\n\t\t\t\t\tname === \"require\"\n\t\t\t\t\t\t? new Proxy(descriptor.value as NodeRequire, {\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * A trap for a function call. Used to create new proxies for methods on the retrieved module objects\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tapply(target: NodeRequire, thisArg: unknown, argArray: unknown[] = []): unknown {\n\t\t\t\t\t\t\t\t\tconst [moduleName] = argArray as string[];\n\n\t\t\t\t\t\t\t\t\treturn createPolicyProxy({\n\t\t\t\t\t\t\t\t\t\tpolicy,\n\t\t\t\t\t\t\t\t\t\titem: Reflect.apply(target, thisArg, argArray),\n\t\t\t\t\t\t\t\t\t\tscope: moduleName,\n\t\t\t\t\t\t\t\t\t\thook\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t  })\n\t\t\t\t\t\t: createPolicyProxy({\n\t\t\t\t\t\t\t\tpolicy,\n\t\t\t\t\t\t\t\titem: descriptor.value,\n\t\t\t\t\t\t\t\tscope: name,\n\t\t\t\t\t\t\t\thook\n\t\t\t\t\t\t  })\n\t\t\t}))\n\t);\n\n\treturn Object.defineProperties(values, {\n\t\t...gettersAndSetters\n\t});\n}\n","import objectPath from \"object-path\";\nimport type {IndexLiteral, Literal, LiteralMatch} from \"../literal/literal.js\";\nimport {ECMA_GLOBALS} from \"../environment/ecma/ecma-globals.js\";\nimport {NODE_CJS_GLOBALS} from \"../environment/node/node-cjs-globals.js\";\nimport type {EnvironmentPresetKind} from \"../environment/environment-preset-kind.js\";\nimport {BROWSER_GLOBALS} from \"../environment/browser/browser-globals.js\";\nimport {mergeDescriptors} from \"../util/descriptor/merge-descriptors.js\";\nimport type {ISetInLexicalEnvironmentOptions} from \"./i-set-in-lexical-environment-options.js\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol.js\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol.js\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol.js\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol.js\";\nimport {SUPER_SYMBOL} from \"../util/super/super-symbol.js\";\nimport type {ICreateLexicalEnvironmentOptions} from \"./i-create-lexical-environment-options.js\";\nimport type {TS} from \"../../type/ts.js\";\nimport {NODE_ESM_GLOBALS} from \"../environment/node/node-esm-globals.js\";\nimport {getStatementContext} from \"../util/node/find-nearest-parent-node-of-kind.js\";\nimport { createSanitizedEnvironment } from \"../environment/create-sanitized-environment.js\";\n\nexport interface LexicalEnvironment {\n\tparentEnv: LexicalEnvironment | undefined;\n\tenv: IndexLiteral;\n\tstartingNode: TS.Node;\n\tpreset?: EnvironmentPresetKind;\n}\n\n/**\n * Gets a value from a Lexical Environment\n */\nexport function getRelevantDictFromLexicalEnvironment(env: LexicalEnvironment, path: string): LexicalEnvironment[\"env\"] | undefined {\n\tconst [firstBinding] = path.split(\".\");\n\tif (objectPath.has(env.env, firstBinding)) return env.env;\n\tif (env.parentEnv != null) return getRelevantDictFromLexicalEnvironment(env.parentEnv, path);\n\treturn undefined;\n}\n\n/**\n * Gets the EnvironmentPresetKind for the given LexicalEnvironment\n */\nexport function getPresetForLexicalEnvironment(env: LexicalEnvironment): EnvironmentPresetKind {\n\tif (env.preset != null) return env.preset;\n\telse if (env.parentEnv != null) return getPresetForLexicalEnvironment(env.parentEnv);\n\telse return \"NONE\";\n}\n\n/**\n * Gets a value from a Lexical Environment\n */\nexport function findLexicalEnvironmentUp(from: LexicalEnvironment, path: string): LexicalEnvironment | undefined {\n\tconst [firstBinding] = path.split(\".\");\n\tif (objectPath.has(from.env, firstBinding)) return from;\n\tif (from.parentEnv != null) return findLexicalEnvironmentUp(from.parentEnv, path);\n\treturn undefined;\n}\n\nexport function findLexicalEnvironmentInSameContext(from: LexicalEnvironment, node: TS.Node, typescript: typeof TS): LexicalEnvironment | undefined {\n\tconst startingNodeContext = getStatementContext(from.startingNode, typescript);\n\tconst nodeContext = getStatementContext(node, typescript);\n\n\tif (startingNodeContext?.pos === nodeContext?.pos) {\n\t\treturn from;\n\t}\n\n\tif (from.parentEnv == null) {\n\t\treturn undefined;\n\t}\n\n\treturn findLexicalEnvironmentInSameContext(from.parentEnv, node, typescript);\n}\n\n/**\n * Gets a value from a Lexical Environment\n */\nexport function getFromLexicalEnvironment(node: TS.Node | undefined, env: LexicalEnvironment, path: string): LiteralMatch | undefined {\n\tconst [firstBinding] = path.split(\".\");\n\tif (objectPath.has(env.env, firstBinding)) {\n\t\tconst literal = objectPath.get(env.env, path);\n\t\tswitch (path) {\n\t\t\t// If we're in a Node environment, the \"__dirname\" and \"__filename\" meta-properties should report the current directory or file of the SourceFile and not the parent process\n\t\t\tcase \"__dirname\":\n\t\t\tcase \"__filename\": {\n\t\t\t\tconst preset = getPresetForLexicalEnvironment(env);\n\t\t\t\treturn (preset === \"NODE\" || preset === \"NODE_CJS\") && typeof literal === \"function\" && node != null ? {literal: literal(node.getSourceFile().fileName)} : {literal};\n\t\t\t}\n\t\t\tcase \"import.meta\": {\n\t\t\t\tconst preset = getPresetForLexicalEnvironment(env);\n\t\t\t\treturn (preset === \"NODE_ESM\" || preset === \"BROWSER\" || preset === \"ECMA\") &&\n\t\t\t\t\ttypeof literal === \"object\" &&\n\t\t\t\t\tliteral != null &&\n\t\t\t\t\ttypeof literal.url === \"function\" &&\n\t\t\t\t\tnode != null\n\t\t\t\t\t? {literal: {url: literal.url(node.getSourceFile().fileName)}}\n\t\t\t\t\t: {literal};\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn {literal};\n\t\t}\n\t}\n\n\tif (env.parentEnv != null) return getFromLexicalEnvironment(node, env.parentEnv, path);\n\treturn undefined;\n}\n\n/**\n * Returns true if a path maps to an identifier that has been declared within the Lexical Environment\n */\nexport function hasInLexicalEnvironment(node: TS.Node | undefined, env: LexicalEnvironment, path: string): boolean {\n\tconst [firstBinding] = path.split(\".\");\n\tif (objectPath.has(env.env, firstBinding)) {\n\t\treturn true;\n\t}\n\n\tif (env.parentEnv != null) {\n\t\treturn hasInLexicalEnvironment(node, env.parentEnv, path);\n\t}\n\treturn false;\n}\n\n/**\n * Returns true if the given lexical environment contains a value on the given path that equals the given literal\n */\nexport function pathInLexicalEnvironmentEquals(node: TS.Node, env: LexicalEnvironment, equals: Literal, ...matchPaths: string[]): boolean {\n\treturn matchPaths.some(path => {\n\t\tconst match = getFromLexicalEnvironment(node, env, path);\n\t\treturn match == null ? false : match.literal === equals;\n\t});\n}\n\n/**\n * Returns true if the given value represents an internal symbol\n */\nexport function isInternalSymbol(value: Literal): boolean {\n\tswitch (value) {\n\t\tcase RETURN_SYMBOL:\n\t\tcase BREAK_SYMBOL:\n\t\tcase CONTINUE_SYMBOL:\n\t\tcase THIS_SYMBOL:\n\t\tcase SUPER_SYMBOL:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n/**\n * Gets a value from a Lexical Environment\n */\nexport function setInLexicalEnvironment({environment, path, value, reporting, node, newBinding = false}: ISetInLexicalEnvironmentOptions): void {\n\tconst [firstBinding] = path.split(\".\");\n\n\tif (objectPath.has(environment.env, firstBinding) || newBinding || environment.parentEnv == null) {\n\t\t// If the value didn't change, do no more\n\t\tif (objectPath.has(environment.env, path) && objectPath.get(environment.env, path) === value) return;\n\n\t\t// Otherwise, mutate it\n\t\tobjectPath.set(environment.env, path, value);\n\n\t\t// Inform reporting hooks if any is given\n\t\tif (reporting.reportBindings != null && !isInternalSymbol(path)) {\n\t\t\treporting.reportBindings({path, value, node});\n\t\t}\n\t} else {\n\t\tlet currentParentEnv: LexicalEnvironment | undefined = environment.parentEnv;\n\t\twhile (currentParentEnv != null) {\n\t\t\tif (objectPath.has(currentParentEnv.env, firstBinding)) {\n\t\t\t\t// If the value didn't change, do no more\n\t\t\t\tif (objectPath.has(currentParentEnv.env, path) && objectPath.get(currentParentEnv.env, path) === value) return;\n\n\t\t\t\t// Otherwise, mutate it\n\t\t\t\tobjectPath.set(currentParentEnv.env, path, value);\n\n\t\t\t\t// Inform reporting hooks if any is given\n\t\t\t\tif (reporting.reportBindings != null && !isInternalSymbol(path)) {\n\t\t\t\t\treporting.reportBindings({path, value, node});\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tif (currentParentEnv.parentEnv == null) {\n\t\t\t\t\t// Otherwise, mutate it\n\t\t\t\t\tobjectPath.set(currentParentEnv.env, path, value);\n\n\t\t\t\t\t// Inform reporting hooks if any is given\n\t\t\t\t\tif (reporting.reportBindings != null && !isInternalSymbol(path)) {\n\t\t\t\t\t\treporting.reportBindings({path, value, node});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcurrentParentEnv = currentParentEnv.parentEnv;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Clears a binding from a Lexical Environment\n */\nexport function clearBindingFromLexicalEnvironment(env: LexicalEnvironment, path: string): void {\n\tconst [firstBinding] = path.split(\".\");\n\tif (objectPath.has(env.env, firstBinding)) {\n\t\tobjectPath.del(env.env, path);\n\t} else {\n\t\tlet currentParentEnv: LexicalEnvironment | undefined = env.parentEnv;\n\t\twhile (currentParentEnv != null) {\n\t\t\tif (objectPath.has(currentParentEnv.env, firstBinding)) {\n\t\t\t\tobjectPath.del(currentParentEnv.env, path);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tcurrentParentEnv = currentParentEnv.parentEnv;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function simplifyEnvironment(environment: LexicalEnvironment, typescript: typeof TS): Record<string, unknown> {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst {arguments: _arguments, ...rest} = environment.env;\n\n\tconst strippedEnv = Object.fromEntries(Object.entries(rest).filter(([key]) => !(key in globalThis)));\n\n\treturn {\n\t\t...(environment.preset == null ? {} : {preset: environment.preset}),\n\t\tparentEnv: environment.parentEnv == null ? undefined : simplifyEnvironment(environment.parentEnv, typescript),\n\t\tenv: environment.preset != null ? strippedEnv : rest,\n\t\tstartingNode: typescript.SyntaxKind[environment.startingNode.kind]\n\t};\n}\n\n/**\n * Creates a Lexical Environment\n */\nexport function createLexicalEnvironment({\n\tinputEnvironment: {extra, preset},\n\tstartingNode,\n\tpolicy,\n}: ICreateLexicalEnvironmentOptions): LexicalEnvironment {\n\tlet env: IndexLiteral;\n\n\tswitch (preset) {\n\t\tcase \"NONE\":\n\t\t\tenv = mergeDescriptors(extra);\n\t\t\tbreak;\n\n\t\tcase \"ECMA\":\n\t\t\tenv = mergeDescriptors(ECMA_GLOBALS(), extra);\n\t\t\tbreak;\n\n\t\tcase \"NODE\":\n\t\tcase \"NODE_CJS\":\n\t\t\tenv = mergeDescriptors(NODE_CJS_GLOBALS(), extra);\n\t\t\tbreak;\n\n\t\tcase \"NODE_ESM\":\n\t\t\tenv = mergeDescriptors(NODE_ESM_GLOBALS(), extra);\n\t\t\tbreak;\n\n\t\tcase \"BROWSER\":\n\t\t\tenv = mergeDescriptors(BROWSER_GLOBALS(), extra);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tenv = {};\n\t\t\tbreak;\n\t}\n\n\treturn {\n\t\tparentEnv: undefined,\n\t\tpreset,\n\t\tstartingNode,\n\t\tenv: createSanitizedEnvironment({\n\t\t\tpolicy,\n\t\t\tenv\n\t\t})\n\t};\n}\n","import type {TS} from \"../../../type/ts.js\";\n\n/**\n * Returns true if the given node is a BooleanLiteral\n */\nexport function isBooleanLiteral(node: {kind: TS.SyntaxKind}, typescript: typeof TS): node is TS.Token<TS.SyntaxKind.TrueKeyword | TS.SyntaxKind.FalseKeyword> {\n\treturn node.kind === typescript.SyntaxKind.TrueKeyword || node.kind === typescript.SyntaxKind.FalseKeyword;\n}\n","import type {TS} from \"../../../type/ts.js\";\n\n/**\n * Returns true if the given node is a NullLiteral\n */\nexport function isNullLiteral(node: TS.Node, typescript: typeof TS): node is TS.NullLiteral {\n\treturn node.kind === typescript.SyntaxKind.NullKeyword;\n}\n","import type {EvaluateSimpleLiteralResult} from \"./evaluate-simple-literal-result.js\";\nimport {isBooleanLiteral} from \"../../util/node/is-boolean-literal.js\";\nimport {isNullLiteral} from \"../../util/node/is-null-literal.js\";\nimport type {TS} from \"../../../type/ts.js\";\n\n/**\n * This is a tiny function that avoids the costs of building up an evaluation environment\n * for the interpreter. If the node is a simple literal, it will return its' value.\n */\nexport function evaluateSimpleLiteral(node: TS.Node, typescript: typeof TS): EvaluateSimpleLiteralResult {\n\tif (typescript.isStringLiteralLike(node)) return {success: true, value: node.text};\n\telse if (isBooleanLiteral(node, typescript)) return {success: true, value: node.kind === typescript.SyntaxKind.TrueKeyword};\n\telse if (typescript.isRegularExpressionLiteral(node)) return {success: true, value: new Function(`return ${node.text}`)()};\n\telse if (typescript.isNumericLiteral(node)) return {success: true, value: Number(node.text)};\n\telse if (typescript.isBigIntLiteral?.(node)) return {success: true, value: BigInt(node.text)};\n\telse if (typescript.isIdentifier(node) && node.text === \"Infinity\") return {success: true, value: Infinity};\n\telse if (typescript.isIdentifier(node) && node.text === \"NaN\") return {success: true, value: NaN};\n\telse if (typescript.isIdentifier(node) && node.text === \"null\") return {success: true, value: null};\n\telse if (typescript.isIdentifier(node) && node.text === \"undefined\") return {success: true, value: undefined};\n\telse if (isNullLiteral(node, typescript)) return {success: true, value: null};\n\telse return {success: false};\n}\n","import type {IMaxOpsExceededErrorOptions} from \"./i-max-ops-exceeded-error-options.js\";\nimport {PolicyError} from \"../policy-error.js\";\n\n/**\n * An Error that can be thrown when the maximum amount of operations dictated by the policy is exceeded\n */\nexport class MaxOpsExceededError extends PolicyError {\n\t/**\n\t * The amount of operations performed before creating this error instance\n\t */\n\treadonly ops: number;\n\n\tconstructor({ops, node, environment, message = `Maximum ops exceeded: ${ops}`}: IMaxOpsExceededErrorOptions) {\n\t\tsuper({violation: \"maxOps\", message, node, environment});\n\t\tthis.ops = ops;\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {EvaluationError} from \"../error/evaluation-error/evaluation-error.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a VariableDeclaration\n */\nexport function evaluateVariableDeclaration(options: EvaluatorOptions<TS.VariableDeclaration>, initializer?: Literal): void | EvaluationError {\n\tconst {node, environment, evaluate, stack, typescript, throwError, getCurrentError} = options;\n\tconst initializerResult =\n\t\tinitializer != null\n\t\t\t? initializer\n\t\t\t: node.initializer == null\n\t\t\t? // A VariableDeclaration with no initializer is implicitly bound to 'undefined'\n\t\t\t  undefined\n\t\t\t: evaluate.expression(node.initializer, options);\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\t// There's no way of destructuring a nullish value\n\tif (initializerResult == null && !typescript.isIdentifier(node.name)) {\n\t\treturn throwError(new EvaluationError({node, environment}));\n\t}\n\n\t// Evaluate the binding name\n\tevaluate.nodeWithArgument(node.name, initializerResult, options);\n\t\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\t\n\tstack.push(initializerResult);\n}\n","import type {TS} from \"../../../type/ts.js\";\n\n/**\n * Returns true if the given node is a ThisExpression\n */\nexport function isThisExpression(node: TS.Node, typescript: typeof TS): node is TS.ThisExpression {\n\treturn node.kind === typescript.SyntaxKind.ThisKeyword;\n}\n","import type {TS} from \"../../../type/ts.js\";\n\n/**\n * Returns true if the given node is a SuperExpression\n */\nexport function isSuperExpression(node: TS.Node, typescript: typeof TS): node is TS.SuperExpression {\n\treturn node.kind === typescript.SyntaxKind.SuperKeyword;\n}\n","import {isThisExpression} from \"../util/node/is-this-expression.js\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol.js\";\nimport {isSuperExpression} from \"../util/node/is-super-expression.js\";\nimport {SUPER_SYMBOL} from \"../util/super/super-symbol.js\";\nimport type {EvaluatorOptions} from \"../evaluator/evaluator-options.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Gets the path to \"dot\" into an object with based on the node. For example, if the node is a simple identifier, say, 'foo', the dot path is simply \"foo\".\n * And, if it is a PropertyAccessExpression, that path may be \"console.log\" for example\n */\nexport function getDotPathFromNode<T extends TS.Node>(options: EvaluatorOptions<T>): string | undefined {\n\tconst {node, evaluate, typescript} = options;\n\tif (typescript.isIdentifier(node)) {\n\t\treturn node.text;\n\t} else if (typescript.isPrivateIdentifier?.(node)) {\n\t\treturn node.text;\n\t} else if (isThisExpression(node, typescript)) {\n\t\treturn THIS_SYMBOL;\n\t} else if (isSuperExpression(node, typescript)) {\n\t\treturn SUPER_SYMBOL;\n\t} else if (typescript.isParenthesizedExpression(node)) {\n\t\treturn getDotPathFromNode({...options, node: node.expression});\n\t} else if (\n\t\ttypescript.isTypeAssertionExpression?.(node) ||\n\t\t(!(\"isTypeAssertionExpression\" in typescript) && (typescript as {isTypeAssertion: typeof TS.isTypeAssertionExpression}).isTypeAssertion(node))\n\t) {\n\t\treturn getDotPathFromNode({...options, node: node.expression});\n\t} else if (typescript.isPropertyAccessExpression(node)) {\n\t\tlet leftHand = getDotPathFromNode({...options, node: node.expression});\n\t\tif (leftHand == null) leftHand = evaluate.expression(node.expression, options) as string;\n\t\tlet rightHand = getDotPathFromNode({...options, node: node.name});\n\t\tif (rightHand == null) rightHand = evaluate.expression(node.name, options) as string;\n\n\t\tif (leftHand == null || rightHand == null) return undefined;\n\t\treturn `${leftHand}.${rightHand}`;\n\t} else if (typescript.isElementAccessExpression(node)) {\n\t\tlet leftHand = getDotPathFromNode({...options, node: node.expression});\n\t\tif (leftHand == null) leftHand = evaluate.expression(node.expression, options) as string;\n\t\tconst rightHand = evaluate.expression(node.argumentExpression, options) as string;\n\n\t\tif (leftHand == null || rightHand == null) return undefined;\n\t\treturn `${leftHand}.${rightHand}`;\n\t} else if (typescript.isFunctionDeclaration(node)) {\n\t\tif (node.name == null) return undefined;\n\t\treturn node.name.text;\n\t}\n\n\treturn undefined;\n}\n","import {EvaluationError} from \"../evaluation-error/evaluation-error.js\";\nimport type {IUndefinedLeftValueErrorOptions} from \"./i-undefined-left-value-error-options.js\";\n\n/**\n * An Error that can be thrown when an undefined leftValue is encountered\n */\nexport class UndefinedLeftValueError extends EvaluationError {\n\tconstructor({node, environment, message = `'No leftValue could be determined'`}: IUndefinedLeftValueErrorOptions) {\n\t\tsuper({message, environment, node});\n\t}\n}\n","import type {TS} from \"../../../type/ts.js\";\n\nexport function getInnerNode<T extends TS.Node>(node: TS.Node, typescript: typeof TS): T {\n\tif (typescript.isParenthesizedExpression(node)) return getInnerNode(node.expression, typescript);\n\telse if (typescript.isAsExpression(node)) return getInnerNode(node.expression, typescript);\n\telse if (\n\t\ttypescript.isTypeAssertionExpression?.(node) ||\n\t\t(!(\"isTypeAssertionExpression\" in typescript) && (typescript as {isTypeAssertion: typeof TS.isTypeAssertionExpression}).isTypeAssertion(node))\n\t) {\n\t\treturn getInnerNode(node.expression, typescript);\n\t} else {\n\t\treturn node as T;\n\t}\n}\n","import type { TS } from \"../../../type/ts.js\";\n\n export function isTypescriptNode<T extends TS.Node>(node: T|unknown): node is T {\n    return node != null && typeof node === \"object\" && \"kind\" in node && \"flags\" in node && \"pos\" in node && \"end\" in node;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {getDotPathFromNode} from \"../lexical-environment/get-dot-path-from-node.js\";\nimport {findLexicalEnvironmentInSameContext, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error.js\";\nimport {UndefinedLeftValueError} from \"../error/undefined-left-value-error/undefined-left-value-error.js\";\nimport type {TS} from \"../../type/ts.js\";\nimport {getInnerNode} from \"../util/node/get-inner-node.js\";\nimport {findNearestParentNodeWithName} from \"../util/node/find-nearest-parent-node-of-kind.js\";\nimport {isTypescriptNode} from \"../util/node/is-node.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a BinaryExpression\n */\nexport function evaluateBinaryExpression(options: EvaluatorOptions<TS.BinaryExpression>): Literal {\n\tconst {node, environment, evaluate, logger, throwError, typeChecker, typescript, getCurrentError} = options;\n\n\tconst leftValue = evaluate.expression(node.left, options) as number;\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\tconst rightValue = evaluate.expression(node.right, options) as number;\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\tconst leftIdentifier = getDotPathFromNode({...options, node: node.left});\n\n\tconst operator = node.operatorToken.kind;\n\tswitch (operator) {\n\t\tcase typescript.SyntaxKind.AmpersandToken: {\n\t\t\treturn leftValue & rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.AmpersandAmpersandToken: {\n\t\t\t// eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\t\t\treturn leftValue && rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.AmpersandEqualsToken:\n\t\tcase typescript.SyntaxKind.CaretEqualsToken:\n\t\tcase typescript.SyntaxKind.BarEqualsToken:\n\t\tcase typescript.SyntaxKind.MinusEqualsToken:\n\t\tcase typescript.SyntaxKind.PlusEqualsToken:\n\t\tcase typescript.SyntaxKind.PercentEqualsToken:\n\t\tcase typescript.SyntaxKind.SlashEqualsToken:\n\t\tcase typescript.SyntaxKind.AsteriskEqualsToken:\n\t\tcase typescript.SyntaxKind.AsteriskAsteriskEqualsToken:\n\t\tcase typescript.SyntaxKind.LessThanLessThanEqualsToken:\n\t\tcase typescript.SyntaxKind.GreaterThanGreaterThanEqualsToken:\n\t\tcase typescript.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:\n\t\tcase typescript.SyntaxKind.QuestionQuestionEqualsToken:\n\t\tcase typescript.SyntaxKind.BarBarEqualsToken:\n\t\tcase typescript.SyntaxKind.AmpersandAmpersandEqualsToken: {\n\t\t\t// There's nothing in the engine restricting you from applying this kind of arithmetic operation on non-numeric data types\n\t\t\tlet computedValue = leftValue;\n\t\t\tswitch (operator) {\n\t\t\t\tcase typescript.SyntaxKind.AmpersandEqualsToken:\n\t\t\t\t\tcomputedValue &= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.CaretEqualsToken:\n\t\t\t\t\tcomputedValue ^= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.BarEqualsToken:\n\t\t\t\t\tcomputedValue |= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.AsteriskEqualsToken:\n\t\t\t\t\tcomputedValue *= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.AsteriskAsteriskEqualsToken:\n\t\t\t\t\tcomputedValue **= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.LessThanLessThanEqualsToken:\n\t\t\t\t\tcomputedValue <<= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.GreaterThanGreaterThanEqualsToken:\n\t\t\t\t\tcomputedValue >>= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:\n\t\t\t\t\tcomputedValue >>>= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.MinusEqualsToken:\n\t\t\t\t\tcomputedValue -= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.PlusEqualsToken:\n\t\t\t\t\tcomputedValue += rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.PercentEqualsToken:\n\t\t\t\t\tcomputedValue %= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.SlashEqualsToken:\n\t\t\t\t\tcomputedValue /= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.QuestionQuestionEqualsToken:\n\t\t\t\t\tcomputedValue = leftValue == null ? rightValue : leftValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.BarBarEqualsToken:\n\t\t\t\t\tif (!leftValue) {\n\t\t\t\t\t\tcomputedValue = rightValue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.AmpersandAmpersandEqualsToken:\n\t\t\t\t\tif (leftValue) {\n\t\t\t\t\t\tcomputedValue = rightValue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Update to the left-value within the environment if it exists there and has been updated\n\t\t\tif (leftIdentifier != null) {\n\t\t\t\tsetInLexicalEnvironment({...options, path: leftIdentifier, value: computedValue});\n\t\t\t}\n\n\t\t\t// Return the computed value\n\t\t\treturn computedValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.AsteriskToken: {\n\t\t\treturn leftValue * rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.AsteriskAsteriskToken: {\n\t\t\treturn leftValue ** rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.BarToken: {\n\t\t\treturn leftValue | rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.BarBarToken: {\n\t\t\t// eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\t\t\treturn leftValue || rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.CaretToken: {\n\t\t\treturn leftValue ^ rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.CommaToken: {\n\t\t\treturn rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.MinusToken:\n\t\t\treturn leftValue - rightValue;\n\n\t\tcase typescript.SyntaxKind.PlusToken:\n\t\t\tlogger.logResult(leftValue + rightValue, \"BinaryExpression (PlusToken)\");\n\t\t\treturn leftValue + rightValue;\n\n\t\tcase typescript.SyntaxKind.PercentToken:\n\t\t\treturn leftValue % rightValue;\n\n\t\tcase typescript.SyntaxKind.SlashToken:\n\t\t\treturn leftValue / rightValue;\n\n\t\tcase typescript.SyntaxKind.EqualsToken: {\n\t\t\t// Update to the left-value within the environment if it exists there and has been updated\n\t\t\tif (leftIdentifier != null) {\n\t\t\t\tconst innerLeftIdentifier = getInnerNode(node.left, typescript);\n\t\t\t\tconst leftIdentifierSymbol = typeChecker?.getSymbolAtLocation(innerLeftIdentifier);\n\t\t\t\tlet leftIdentifierValueDeclaration = leftIdentifierSymbol?.valueDeclaration;\n\n\t\t\t\t// If we don't have a typechecker to work it, try parsing the SourceFile in order to locate the declaration\n\t\t\t\tif (leftIdentifierValueDeclaration == null && typeChecker == null && typescript.isIdentifier(innerLeftIdentifier)) {\n\t\t\t\t\tconst result = findNearestParentNodeWithName<TS.Declaration>(innerLeftIdentifier.parent, innerLeftIdentifier.text, options as EvaluatorOptions<TS.Declaration>);\n\n\t\t\t\t\tif (isTypescriptNode(result)) {\n\t\t\t\t\t\tleftIdentifierValueDeclaration = result as TS.Declaration;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst bestLexicalEnvironment =\n\t\t\t\t\tleftIdentifierValueDeclaration == null ? environment : findLexicalEnvironmentInSameContext(environment, leftIdentifierValueDeclaration, typescript) ?? environment;\n\n\t\t\t\tsetInLexicalEnvironment({...options, environment: bestLexicalEnvironment, path: leftIdentifier, value: rightValue});\n\t\t\t\tlogger.logBinding(leftIdentifier, rightValue, \"Assignment\");\n\t\t\t} else {\n\t\t\t\treturn throwError(new UndefinedLeftValueError({node: node.left, environment}));\n\t\t\t}\n\n\t\t\t// The return value of an assignment is always the assigned value\n\t\t\treturn rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.EqualsEqualsToken: {\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\treturn leftValue == rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.EqualsEqualsEqualsToken: {\n\t\t\treturn leftValue === rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.ExclamationEqualsToken: {\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\treturn leftValue != rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.ExclamationEqualsEqualsToken: {\n\t\t\treturn leftValue !== rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.GreaterThanToken:\n\t\t\treturn leftValue > rightValue;\n\n\t\tcase typescript.SyntaxKind.GreaterThanEqualsToken:\n\t\t\treturn leftValue >= rightValue;\n\n\t\tcase typescript.SyntaxKind.LessThanToken:\n\t\t\treturn leftValue < rightValue;\n\n\t\tcase typescript.SyntaxKind.LessThanEqualsToken:\n\t\t\treturn leftValue <= rightValue;\n\n\t\tcase typescript.SyntaxKind.InKeyword: {\n\t\t\treturn leftValue in (rightValue as unknown as Record<string, unknown>);\n\t\t}\n\n\t\t// Nullish coalescing (A ?? B)\n\t\tcase typescript.SyntaxKind.QuestionQuestionToken:\n\t\t\treturn leftValue != null ? leftValue : rightValue;\n\n\t\tcase typescript.SyntaxKind.InstanceOfKeyword: {\n\t\t\treturn (leftValue as unknown as Record<string, unknown>) instanceof (rightValue as unknown as CallableFunction);\n\t\t}\n\t}\n\n\t// Throw if the operator couldn't be handled\n\treturn throwError(new UnexpectedNodeError({node: node.operatorToken, typescript, environment}));\n}\n","// tslint:disable:no-any\n\nexport const enum LiteralFlagKind {\n\tCALL\n}\n\nexport const LAZY_CALL_FLAG = \"___lazyCallFlag\";\n\nexport interface LazyCall {\n\t[LAZY_CALL_FLAG]: LiteralFlagKind;\n\tinvoke(...args: Literal[]): Literal;\n}\n\n/**\n * Returns true if the given literal is a lazy call\n */\nexport function isLazyCall(literal: Literal): literal is LazyCall {\n\treturn literal != null && typeof literal === \"object\" && LAZY_CALL_FLAG in literal;\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type Literal = object | Function | string | number | boolean | symbol | bigint | null | undefined;\nexport interface LiteralMatch {\n\tliteral: Literal;\n}\nexport type IndexLiteralKey = string;\nexport interface IndexLiteral {\n\t[key: string]: Literal;\n}\n\n/**\n * Stringifies the given literal\n */\nexport function stringifyLiteral(literal: Literal): string {\n\tif (literal === undefined) return \"undefined\";\n\telse if (literal === null) return \"null\";\n\telse if (typeof literal === \"string\") return `\"${literal}\"`;\n\treturn literal.toString();\n}\n","import {EvaluationError} from \"../evaluation-error/evaluation-error.js\";\nimport type {INotCallableErrorOptions} from \"./i-not-callable-error-options.js\";\nimport type {Literal} from \"../../literal/literal.js\";\nimport { stringifyLiteral} from \"../../literal/literal.js\";\n\n/**\n * An Error that can be thrown when a value is attempted to be called, but isn't callable\n */\nexport class NotCallableError extends EvaluationError {\n\t/**\n\t * The non-callable value\n\t */\n\treadonly value: Literal;\n\n\tconstructor({value, node, environment, message = `${stringifyLiteral(value)} is not a function'`}: INotCallableErrorOptions) {\n\t\tsuper({message, environment, node});\n\t\tthis.value = value;\n\t}\n}\n","import {isSuperExpression} from \"../node/is-super-expression.js\";\nimport type {TS} from \"../../../type/ts.js\";\n\n/**\n * Returns true if the given expression contains a 'super' keyword\n */\nexport function expressionContainsSuperKeyword(expression: TS.Expression | TS.PrivateIdentifier, typescript: typeof TS): boolean {\n\tif (isSuperExpression(expression, typescript)) return true;\n\telse if (typescript.isPropertyAccessExpression(expression)) {\n\t\treturn expressionContainsSuperKeyword(expression.expression, typescript) || expressionContainsSuperKeyword(expression.name, typescript);\n\t} else if (typescript.isElementAccessExpression(expression)) {\n\t\treturn expressionContainsSuperKeyword(expression.expression, typescript) || expressionContainsSuperKeyword(expression.argumentExpression, typescript);\n\t} else if (typescript.isParenthesizedExpression(expression)) return expressionContainsSuperKeyword(expression.expression, typescript);\n\telse if (typescript.isAsExpression(expression)) return expressionContainsSuperKeyword(expression.expression, typescript);\n\telse if (\n\t\ttypescript.isTypeAssertionExpression?.(expression) ||\n\t\t(!(\"isTypeAssertionExpression\" in typescript) && (typescript as {isTypeAssertion: typeof TS.isTypeAssertionExpression}).isTypeAssertion(expression))\n\t) {\n\t\treturn expressionContainsSuperKeyword(expression.expression, typescript);\n\t} else {\n\t\treturn false;\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type { Literal} from \"../literal/literal.js\";\nimport {isLazyCall} from \"../literal/literal.js\";\nimport {NotCallableError} from \"../error/not-callable-error/not-callable-error.js\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol.js\";\nimport {expressionContainsSuperKeyword} from \"../util/expression/expression-contains-super-keyword.js\";\nimport type {TS} from \"../../type/ts.js\";\nimport {maybeThrow} from \"../error/evaluation-error/evaluation-error-intent.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a CallExpression\n */\nexport function evaluateCallExpression(options: EvaluatorOptions<TS.CallExpression>): Literal {\n\tconst {node, environment, evaluate, throwError, typescript, logger, getCurrentError} = options;\n\tconst evaluatedArgs: Literal[] = [];\n\n\tfor (let i = 0; i < node.arguments.length; i++) {\n\t\tevaluatedArgs[i] = evaluate.expression(node.arguments[i], options);\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Evaluate the expression\n\tconst expressionResult = evaluate.expression(node.expression, options) as CallableFunction | undefined;\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\tif (isLazyCall(expressionResult)) {\n\t\tconst currentThisBinding = expressionContainsSuperKeyword(node.expression, typescript) ? getFromLexicalEnvironment(node, environment, THIS_SYMBOL) : undefined;\n\t\tconst value = expressionResult.invoke(currentThisBinding != null ? currentThisBinding.literal : undefined, ...evaluatedArgs);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.logResult(value, \"CallExpression\");\n\n\t\treturn value;\n\t}\n\n\t// Otherwise, assume that the expression still needs calling\n\telse {\n\t\t// Unless optional chaining is being used, throw a NotCallableError\n\t\tif (node.questionDotToken == null && typeof expressionResult !== \"function\") {\n\t\t\treturn throwError(new NotCallableError({value: expressionResult, node: node.expression, environment}));\n\t\t}\n\n\t\tconst value = typeof expressionResult !== \"function\" ? undefined : maybeThrow(node, options, expressionResult(...evaluatedArgs));\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.logResult(value, \"CallExpression\");\n\t\treturn value;\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a ParenthesizedExpression\n */\nexport function evaluateParenthesizedExpression({node, evaluate, ...options}: EvaluatorOptions<TS.ParenthesizedExpression>): Literal {\n\treturn evaluate.expression(node.expression, options);\n}\n","import type { TS } from \"../../type/ts.js\";\nimport type {LexicalEnvironment} from \"./lexical-environment.js\";\n\n/**\n * Clones the given LexicalEnvironment\n */\nexport function cloneLexicalEnvironment(environment: LexicalEnvironment, startingNode: TS.Node): LexicalEnvironment {\n\treturn {\n\t\tparentEnv: environment,\n\t\tstartingNode,\t\t\n\t\tenv: {}\n\t};\n}\n","import type {TS} from \"../../../type/ts.js\";\n\n/**\n * Returns true if the given Node has the given kind of Modifier\n */\nexport function hasModifier(node: TS.Node | TS.ModifierLike[], modifier: TS.Modifier[\"kind\"]): boolean {\n\tconst modifiers = Array.isArray(node) ? node : \"modifiers\" in node && Array.isArray(node.modifiers) ? (node.modifiers as readonly TS.ModifierLike[]) : undefined;\n\treturn modifiers != null && modifiers.some(m => m.kind === modifier);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {IndexLiteral, Literal} from \"../literal/literal.js\";\nimport {hasModifier} from \"../util/modifier/has-modifier.js\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a NodeArray of ParameterDeclarations\n */\nexport function evaluateParameterDeclarations(options: EvaluatorOptions<TS.NodeArray<TS.ParameterDeclaration>>, boundArguments: Literal[], context?: IndexLiteral): void {\n\tconst {node, evaluate, environment, typescript, getCurrentError} = options;\n\t// 'this' is a special parameter which is removed from the emitted results\n\tconst parameters = node.filter(param => !(typescript.isIdentifier(param.name) && param.name.text === \"this\"));\n\n\tfor (let i = 0; i < parameters.length; i++) {\n\t\tconst parameter = parameters[i];\n\n\t\t// It it is a spread element, it should receive all arguments from the current index.\n\t\tif (parameter.dotDotDotToken != null) {\n\t\t\tevaluate.nodeWithArgument(parameter, boundArguments.slice(i), options);\n\n\t\t\tif (getCurrentError() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Spread elements must always be the last parameter\n\t\t\tbreak;\n\t\t} else {\n\t\t\tevaluate.nodeWithArgument(parameter, boundArguments[i], options);\n\n\t\t\tif (getCurrentError() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a context is given, and if a [public|protected|private] keyword is in front of the parameter, the initialized value should be\n\t\t\t// set on the context as an instance property\n\t\t\tif (\n\t\t\t\tcontext != null &&\n\t\t\t\ttypescript.isIdentifier(parameter.name) &&\n\t\t\t\t(hasModifier(parameter, typescript.SyntaxKind.PublicKeyword) ||\n\t\t\t\t\thasModifier(parameter, typescript.SyntaxKind.ProtectedKeyword) ||\n\t\t\t\t\thasModifier(parameter, typescript.SyntaxKind.PrivateKeyword))\n\t\t\t) {\n\t\t\t\tconst value = getFromLexicalEnvironment(parameter, environment, parameter.name.text);\n\t\t\t\tif (value != null) {\n\t\t\t\t\tcontext[parameter.name.text] = value.literal;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type { LexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {getFromLexicalEnvironment, pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport {evaluateParameterDeclarations} from \"./evaluate-parameter-declarations.js\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol.js\";\nimport {hasModifier} from \"../util/modifier/has-modifier.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, an ArrowFunction\n */\nexport function evaluateArrowFunctionExpression(options: EvaluatorOptions<TS.ArrowFunction>): Literal {\n\tconst {node, environment, evaluate, stack, typescript, getCurrentError} = options;\n\n\tconst arrowFunctionExpression = hasModifier(node, typescript.SyntaxKind.AsyncKeyword)\n\t\t? async (...args: Literal[]) => {\n\t\t\t\t// Prepare a lexical environment for the function context\n\t\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment, node);\n\t\t\t\tconst nextOptions = {...options, environment: localLexicalEnvironment};\n\n\t\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: RETURN_SYMBOL, value: false, newBinding: true});\n\n\t\t\t\t// Define a new binding for the arguments given to the function\n\t\t\t\t// eslint-disable-next-line prefer-rest-params\n\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: \"arguments\", value: arguments, newBinding: true});\n\n\t\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\t\tevaluateParameterDeclarations(\n\t\t\t\t\t{\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\t\tenvironment: localLexicalEnvironment\n\t\t\t\t\t},\n\t\t\t\t\targs\n\t\t\t\t);\n\n\t\t\t\tif (getCurrentError() != null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\t\tif (typescript.isBlock(node.body)) {\n\t\t\t\t\tevaluate.statement(node.body, nextOptions);\n\n\t\t\t\t\tif (getCurrentError() != null) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\t\t\treturn stack.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\t\t\telse return undefined;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, the body is itself an expression\n\t\t\t\telse {\n\t\t\t\t\treturn evaluate.expression(node.body, nextOptions);\n\t\t\t\t}\n\t\t  }\n\t\t: (...args: Literal[]) => {\n\t\t\t\t// Prepare a lexical environment for the function context\n\t\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment, node);\n\t\t\t\tconst nextOptions = {...options, environment: localLexicalEnvironment};\n\n\t\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: RETURN_SYMBOL, value: false, newBinding: true});\n\n\t\t\t\t// Define a new binding for the arguments given to the function\n\t\t\t\t// eslint-disable-next-line prefer-rest-params\n\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: \"arguments\", value: arguments, newBinding: true});\n\n\t\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\t\tevaluateParameterDeclarations(\n\t\t\t\t\t{\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\t\tenvironment: localLexicalEnvironment\n\t\t\t\t\t},\n\t\t\t\t\targs\n\t\t\t\t);\n\n\t\t\t\tif (getCurrentError() != null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\t\tif (typescript.isBlock(node.body)) {\n\t\t\t\t\tevaluate.statement(node.body, nextOptions);\n\n\t\t\t\t\tif (getCurrentError() != null) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\t\t\treturn stack.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\t\t\telse return undefined;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, the body is itself an expression\n\t\t\t\telse {\n\t\t\t\t\treturn evaluate.expression(node.body, nextOptions);\n\t\t\t\t}\n\t\t  };\n\n\tarrowFunctionExpression.toString = () => `[Function: anonymous]`;\n\n\t// Make sure to use the Function that is contained within the Realm. Otherwise, 'instanceof' checks may fail\n\t// since this particular function comes from the executing context.\n\tObject.setPrototypeOf(arrowFunctionExpression, getFromLexicalEnvironment(node, environment, \"Function\")!.literal as CallableFunction);\n\n\treturn arrowFunctionExpression;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a StringLiteralLike\n */\nexport function evaluateStringLiteral({node}: EvaluatorOptions<TS.StringLiteralLike>): Literal {\n\treturn node.text;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a NumericLiteral\n */\nexport function evaluateNumericLiteral({node}: EvaluatorOptions<TS.NumericLiteral>): Literal {\n\treturn Number(node.text);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a BooleanLiteral\n */\nexport function evaluateBooleanLiteral({node, typescript}: EvaluatorOptions<TS.Token<TS.SyntaxKind.TrueKeyword | TS.SyntaxKind.FalseKeyword>>): Literal {\n\treturn node.kind === typescript.SyntaxKind.TrueKeyword;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a RegularExpressionLiteral\n */\nexport function evaluateRegularExpressionLiteral({node, environment}: EvaluatorOptions<TS.RegularExpressionLiteral>): Literal {\n\tconst functionCtor = getFromLexicalEnvironment(node, environment, \"Function\")!.literal as FunctionConstructor;\n\treturn new functionCtor(`return ${node.text}`)();\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {IndexLiteral, Literal} from \"../literal/literal.js\";\nimport {getFromLexicalEnvironment, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a ObjectLiteralExpression\n */\nexport function evaluateObjectLiteralExpression(options: EvaluatorOptions<TS.ObjectLiteralExpression>): Literal {\n\tconst {node, evaluate, environment, getCurrentError} = options;\n\t// Create a new ObjectLiteral based on the Object implementation from the Realm since this must not be the same as in the parent executing context\n\t// Otherwise, instanceof checks would fail\n\tconst objectCtor = getFromLexicalEnvironment(node, environment, \"Object\")!.literal as ObjectConstructor;\n\tconst value: IndexLiteral = objectCtor.create(objectCtor.prototype);\n\n\t// Mark the object as the 'this' value of the scope\n\tsetInLexicalEnvironment({...options, path: THIS_SYMBOL, value, newBinding: true});\n\n\tfor (const property of node.properties) {\n\t\tevaluate.nodeWithArgument(property, value, options);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\treturn value;\n}\n","import type {Literal} from \"../../literal/literal.js\";\n\n/**\n * Returns true if the given item is an Iterable\n *\n * @param item\n * @return\n */\nexport function isIterable(item: Literal): item is Iterable<Literal> {\n\treturn item != null && (item as Iterable<Literal>)[Symbol.iterator] != null;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {isIterable} from \"../util/iterable/is-iterable.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a ArrayLiteralExpression\n */\nexport function evaluateArrayLiteralExpression(options: EvaluatorOptions<TS.ArrayLiteralExpression>): Literal {\n\tconst {node, environment, evaluate, typescript, getCurrentError} = options;\n\t// Get the Array constructor from the realm - not that of the executing context. Otherwise, instanceof checks would fail\n\tconst arrayCtor = getFromLexicalEnvironment(node, environment, \"Array\")!.literal as ArrayConstructor;\n\tconst value: Literal[] = arrayCtor.of();\n\n\tfor (const element of node.elements) {\n\t\tconst nextValue = evaluate.expression(element, options);\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (typescript.isSpreadElement(element) && isIterable(nextValue)) {\n\t\t\tvalue.push(...nextValue);\n\t\t} else {\n\t\t\tvalue.push(nextValue);\n\t\t}\n\t}\n\n\treturn value;\n}\n","import {EvaluationError} from \"../evaluation-error/evaluation-error.js\";\nimport type {IUndefinedIdentifierErrorOptions} from \"./i-undefined-identifier-error-options.js\";\nimport type {TS} from \"../../../type/ts.js\";\n\n/**\n * An Error that can be thrown when an undefined identifier is encountered\n */\nexport class UndefinedIdentifierError extends EvaluationError {\n\t/**\n\t * The identifier that is undefined in the context that created this error\n\t */\n\treadonly node!: TS.Identifier | TS.PrivateIdentifier;\n\n\tconstructor({node, environment, message = `'${node.text}' is not defined'`}: IUndefinedIdentifierErrorOptions) {\n\t\tsuper({message, environment, node});\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {getFromLexicalEnvironment, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport {UndefinedIdentifierError} from \"../error/undefined-identifier-error/undefined-identifier-error.js\";\nimport {isVarDeclaration} from \"../util/flags/is-var-declaration.js\";\nimport {getImplementationForDeclarationWithinDeclarationFile} from \"../util/module/get-implementation-for-declaration-within-declaration-file.js\";\nimport type {TS} from \"../../type/ts.js\";\nimport {findNearestParentNodeWithName} from \"../util/node/find-nearest-parent-node-of-kind.js\";\nimport {isTypescriptNode} from \"../util/node/is-node.js\";\n\n/**\n * Evaluates, or attempts to evaluate, an Identifier or a PrivateIdentifier\n */\n\nexport function evaluateIdentifier(options: EvaluatorOptions<TS.Identifier | TS.PrivateIdentifier>): Literal {\n\tconst {node, environment, typeChecker, evaluate, stack, logger, reporting, typescript, throwError, getCurrentError} = options;\n\n\t// Otherwise, try to resolve it. Maybe it exists in the environment already?\n\tconst environmentMatch = getFromLexicalEnvironment(node, environment, node.text);\n\n\tif (environmentMatch != null) {\n\t\tlogger.logBinding(node.text, environmentMatch.literal, \"Lexical Environment match\");\n\t\t// Return the existing evaluated value from the environment\n\t\treturn environmentMatch.literal;\n\t}\n\n\t// Try to get a symbol for whatever the identifier points to and take its value declaration.\n\t// It may not have a symbol, for example if it is an inlined expression such as an initializer or a Block\n\tconst symbol = typescript.isShorthandPropertyAssignment(node.parent) ? typeChecker?.getShorthandAssignmentValueSymbol(node.parent) : typeChecker?.getSymbolAtLocation(node);\n\tlet valueDeclaration: TS.Declaration | undefined = symbol == null ? undefined : symbol.valueDeclaration;\n\n\tif (symbol != null && valueDeclaration == null) {\n\t\ttry {\n\t\t\t// The symbol may be aliasing another one - which may have a value declaration\n\t\t\tconst aliasedSymbol = typeChecker?.getAliasedSymbol(symbol);\n\t\t\tvalueDeclaration = aliasedSymbol?.valueDeclaration;\n\t\t} catch {\n\t\t\t// OK, it didn't alias anything\n\t\t}\n\t}\n\n\t// If we weren't able to resolve a SourceFile still, try parsing the SourceFile manually\n\tif (valueDeclaration == null) {\n\t\tconst result = findNearestParentNodeWithName<TS.Declaration>(node.parent, node.text, options as EvaluatorOptions<TS.Declaration>);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (isTypescriptNode(result) && !typescript.isIdentifier(result)) {\n\t\t\tvalueDeclaration = result as TS.Declaration;\n\t\t} else if (result != null) {\n\t\t\t// Bind the value placed on the top of the stack to the local environment\n\t\t\tsetInLexicalEnvironment({...options, path: node.text, value: result});\n\t\t\tlogger.logBinding(node.text, result, `Discovered declaration value`);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// If it has a value declaration, go forward with that one\n\tif (valueDeclaration != null) {\n\t\tif (valueDeclaration.getSourceFile().isDeclarationFile) {\n\t\t\tconst implementation = getImplementationForDeclarationWithinDeclarationFile({...options, node: valueDeclaration});\n\n\t\t\tif (getCurrentError() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Bind the value placed on the top of the stack to the local environment\n\t\t\tsetInLexicalEnvironment({environment, path: node.text, value: implementation, reporting, node: valueDeclaration});\n\t\t\tlogger.logBinding(\n\t\t\t\tnode.text,\n\t\t\t\timplementation,\n\t\t\t\t`Discovered declaration value${\n\t\t\t\t\tvalueDeclaration.getSourceFile() === node.getSourceFile() ? \"\" : ` (imported into '${node.getSourceFile().fileName}' from '${valueDeclaration.getSourceFile().fileName}')`\n\t\t\t\t}`\n\t\t\t);\n\t\t\treturn implementation;\n\t\t}\n\n\t\t// If the value is a variable declaration and is located *after* the current node within the SourceFile\n\t\t// It is potentially a SyntaxError unless it is hoisted (if the 'var' keyword is being used) in which case the variable is defined, but initialized to 'undefined'\n\t\tif (typescript.isVariableDeclaration(valueDeclaration) && valueDeclaration.getSourceFile().fileName === node.getSourceFile().fileName && valueDeclaration.pos > node.pos) {\n\t\t\t// The 'var' keyword declares a variable that is defined, but which rvalue is still undefined\n\t\t\tif (typescript.isVariableDeclarationList(valueDeclaration.parent) && isVarDeclaration(valueDeclaration.parent, typescript)) {\n\t\t\t\tconst returnValue = undefined;\n\t\t\t\tsetInLexicalEnvironment({...options, path: node.text, value: returnValue, newBinding: true, node: valueDeclaration});\n\t\t\t\tlogger.logBinding(node.text, returnValue, \"Hoisted var declaration\");\n\t\t\t\treturn returnValue;\n\t\t\t}\n\n\t\t\t// In all other cases, both the identifier and the rvalue is still undefined\n\t\t\telse {\n\t\t\t\treturn throwError(new UndefinedIdentifierError({node, environment}));\n\t\t\t}\n\t\t}\n\n\t\tevaluate.declaration(valueDeclaration, options);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst stackValue = stack.pop();\n\n\t\t// Bind the value placed on the top of the stack to the local environment\n\t\tsetInLexicalEnvironment({...options, path: node.text, value: stackValue, node: valueDeclaration});\n\t\tlogger.logBinding(\n\t\t\tnode.text,\n\t\t\tstackValue,\n\t\t\t`Discovered declaration value${\n\t\t\t\tvalueDeclaration.getSourceFile() === node.getSourceFile() ? \"\" : ` (imported into '${node.getSourceFile().fileName}' from '${valueDeclaration.getSourceFile().fileName}')`\n\t\t\t}`\n\t\t);\n\t\treturn stackValue;\n\t}\n\n\t// Otherwise throw. The identifier is unknown\n\treturn throwError(new UndefinedIdentifierError({node, environment}));\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {LexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport { pathInLexicalEnvironmentEquals} from \"../lexical-environment/lexical-environment.js\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment.js\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol.js\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol.js\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol.js\";\nimport {isSuperExpression} from \"../util/node/is-super-expression.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a Block\n */\nexport function evaluateBlock(options: EvaluatorOptions<TS.Block>): void {\n\tconst {node, environment, typescript, evaluate, getCurrentError} = options;\n\t// Prepare a lexical environment for the Block context\n\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment, node);\n\n\tfor (let i = 0; i < node.statements.length; i++) {\n\t\tconst statement = node.statements[i];\n\n\t\t// Don't execute 'super()' within Constructor Blocks since this is handled in another level\n\t\tif (\n\t\t\ttypescript.isConstructorDeclaration(node.parent) &&\n\t\t\ti === 0 &&\n\t\t\ttypescript.isExpressionStatement(statement) &&\n\t\t\ttypescript.isCallExpression(statement.expression) &&\n\t\t\tisSuperExpression(statement.expression.expression, typescript)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tevaluate.statement(statement, {...options, environment: localLexicalEnvironment});\n\t\tif (getCurrentError() != null) break;\n\n\t\t// Check if a 'break', 'continue', or 'return' statement has been encountered, break the block\n\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, BREAK_SYMBOL, CONTINUE_SYMBOL, RETURN_SYMBOL)) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a ReturnStatement\n */\nexport function evaluateReturnStatement({node, evaluate, stack, ...options}: EvaluatorOptions<TS.ReturnStatement>): void {\n\tconst {getCurrentError} = options;\n\tsetInLexicalEnvironment({...options, environment: options.environment, path: RETURN_SYMBOL, value: true, node});\n\n\t// If it is a simple 'return', return undefined\n\tif (node.expression == null) {\n\t\tstack.push(undefined);\n\t} else {\n\t\tconst result = evaluate.expression(node.expression, options);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\t\tstack.push(result);\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a VariableDeclarationList\n */\nexport function evaluateVariableDeclarationList({node, evaluate, ...options}: EvaluatorOptions<TS.VariableDeclarationList>): void {\n\tfor (const declaration of node.declarations) {\n\t\tevaluate.declaration(declaration, options);\n\n\t\tif (options.getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {evaluateVariableDeclarationList} from \"./evaluate-variable-declaration-list.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a VariableStatement\n */\nexport function evaluateVariableStatement({node, ...rest}: EvaluatorOptions<TS.VariableStatement>): void {\n\tevaluateVariableDeclarationList({node: node.declarationList, ...rest});\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {getRelevantDictFromLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a PrefixUnaryExpression\n */\nexport function evaluatePrefixUnaryExpression(options: EvaluatorOptions<TS.PrefixUnaryExpression>): Literal {\n\tconst {node, environment, evaluate, reporting, typescript, throwError, getCurrentError} = options;\n\tconst operandValue = evaluate.expression(node.operand, options) as number;\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\tswitch (node.operator) {\n\t\tcase typescript.SyntaxKind.PlusToken: {\n\t\t\treturn +operandValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.MinusToken: {\n\t\t\treturn -operandValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.TildeToken: {\n\t\t\treturn ~operandValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.ExclamationToken: {\n\t\t\t// eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\t\t\treturn !operandValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.PlusPlusToken: {\n\t\t\t// If the Operand isn't an identifier, this will be a SyntaxError\n\t\t\tif (!typescript.isIdentifier(node.operand) && !typescript.isPrivateIdentifier?.(node.operand)) {\n\t\t\t\treturn throwError(new UnexpectedNodeError({node: node.operand, environment, typescript}));\n\t\t\t}\n\n\t\t\t// Find the value associated with the identifier within the environment.\n\t\t\tconst dict = getRelevantDictFromLexicalEnvironment(environment, node.operand.text)!;\n\t\t\tconst value = ++(dict[node.operand.text]! as number);\n\n\t\t\t// Inform reporting hooks if any is given\n\t\t\tif (reporting.reportBindings != null) {\n\t\t\t\treporting.reportBindings({path: node.operand.text, value, node});\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.MinusMinusToken: {\n\t\t\t// If the Operand isn't an identifier, this will be a SyntaxError\n\t\t\tif (!typescript.isIdentifier(node.operand) && !typescript.isPrivateIdentifier?.(node.operand)) {\n\t\t\t\treturn throwError(new UnexpectedNodeError({node: node.operand, environment, typescript}));\n\t\t\t}\n\n\t\t\t// Find the value associated with the identifier within the environment.\n\t\t\tconst dict = getRelevantDictFromLexicalEnvironment(environment, node.operand.text)!;\n\t\t\tconst value = --(dict[node.operand.text]! as number);\n\n\t\t\t// Inform reporting hooks if any is given\n\t\t\tif (reporting.reportBindings != null) {\n\t\t\t\treporting.reportBindings({path: node.operand.text, value, node});\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {IndexLiteral, LazyCall, Literal} from \"../literal/literal.js\";\nimport { LAZY_CALL_FLAG, LiteralFlagKind} from \"../literal/literal.js\";\nimport {isBindCallApply} from \"../util/function/is-bind-call-apply.js\";\nimport type {TS} from \"../../type/ts.js\";\nimport {maybeThrow} from \"../error/evaluation-error/evaluation-error-intent.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a PropertyAccessExpression\n */\nexport function evaluatePropertyAccessExpression(options: EvaluatorOptions<TS.PropertyAccessExpression>): Literal {\n\tconst {evaluate, node, statementTraversalStack, environment, typescript, getCurrentError} = options;\n\tconst expressionResult = evaluate.expression(node.expression, options) as IndexLiteral;\n\n\tif (expressionResult == null || getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\tconst match =\n\t\tnode.questionDotToken != null && expressionResult == null\n\t\t\t? // If optional chaining are being used and the expressionResult is undefined or null, assign undefined to 'match'\n\t\t\t  undefined\n\t\t\t: expressionResult[node.name.text];\n\n\t// If it is a function, wrap it in a lazy call to preserve implicit 'this' bindings. This is to avoid losing the 'this' binding or having to\n\t// explicitly bind a 'this' value\n\tif (typeof match === \"function\" && statementTraversalStack.includes(typescript.SyntaxKind.CallExpression)) {\n\t\treturn {\n\t\t\t[LAZY_CALL_FLAG]: LiteralFlagKind.CALL,\n\t\t\tinvoke: (overriddenThis: Record<string, unknown> | CallableFunction | undefined, ...args: Literal[]) =>\n\t\t\t\tmaybeThrow(\n\t\t\t\t\tnode,\n\t\t\t\t\toptions,\n\t\t\t\t\toverriddenThis != null && !isBindCallApply(match, environment)\n\t\t\t\t\t\t? // eslint-disable-next-line @typescript-eslint/ban-types\n\t\t\t\t\t\t  (expressionResult[node.name.text] as Function).call(overriddenThis, ...args)\n\t\t\t\t\t\t: (expressionResult[node.name.text] as CallableFunction)(...args)\n\t\t\t\t)\n\t\t} as LazyCall;\n\t} else return match;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {IndexLiteral, IndexLiteralKey, LazyCall, Literal} from \"../literal/literal.js\";\nimport { LAZY_CALL_FLAG, LiteralFlagKind} from \"../literal/literal.js\";\nimport {isBindCallApply} from \"../util/function/is-bind-call-apply.js\";\nimport type {TS} from \"../../type/ts.js\";\nimport {maybeThrow} from \"../error/evaluation-error/evaluation-error-intent.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a ElementAccessExpression\n */\nexport function evaluateElementAccessExpression(options: EvaluatorOptions<TS.ElementAccessExpression>): Literal {\n\tconst {node, environment, evaluate, statementTraversalStack, typescript, getCurrentError} = options;\n\tconst expressionResult = evaluate.expression(node.expression, options) as IndexLiteral;\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\tconst argumentExpressionResult = evaluate.expression(node.argumentExpression, options) as IndexLiteralKey;\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\tconst match =\n\t\tnode.questionDotToken != null && expressionResult == null\n\t\t\t? // If optional chaining are being used and the expressionResult is undefined or null, assign undefined to 'match'\n\t\t\t  undefined\n\t\t\t: expressionResult[argumentExpressionResult];\n\n\t// If it is a function, wrap it in a lazy call to preserve implicit this bindings. This is to avoid losing the this binding or having to\n\t// explicitly bind a 'this' value\n\tif (typeof match === \"function\" && statementTraversalStack.includes(typescript.SyntaxKind.CallExpression)) {\n\t\treturn {\n\t\t\t[LAZY_CALL_FLAG]: LiteralFlagKind.CALL,\n\t\t\tinvoke: (overriddenThis: Record<string, unknown> | CallableFunction | undefined, ...args: Literal[]) =>\n\t\t\t\tmaybeThrow(\n\t\t\t\t\tnode,\n\t\t\t\t\toptions,\n\t\t\t\t\toverriddenThis != null && !isBindCallApply(match, environment)\n\t\t\t\t\t\t? // eslint-disable-next-line @typescript-eslint/ban-types\n\t\t\t\t\t\t  (expressionResult[argumentExpressionResult] as Function).call(overriddenThis, ...args)\n\t\t\t\t\t\t: (expressionResult[argumentExpressionResult] as CallableFunction)(...args)\n\t\t\t\t)\n\t\t} as LazyCall;\n\t} else return match;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a ComputedPropertyName\n */\nexport function evaluateComputedPropertyName({node, evaluate, ...options}: EvaluatorOptions<TS.ComputedPropertyName>): Literal {\n\treturn evaluate.expression(node.expression, options);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type { LexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {getFromLexicalEnvironment, pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport {evaluateParameterDeclarations} from \"./evaluate-parameter-declarations.js\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol.js\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol.js\";\nimport {getImplementationForDeclarationWithinDeclarationFile} from \"../util/module/get-implementation-for-declaration-within-declaration-file.js\";\nimport {hasModifier} from \"../util/modifier/has-modifier.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a FunctionDeclaration\n */\nexport function evaluateFunctionDeclaration(options: EvaluatorOptions<TS.FunctionDeclaration>): void {\n\tconst {node, environment, evaluate, stack, typescript, getCurrentError} = options;\n\n\tconst nameResult = node.name == null ? undefined : node.name.text;\n\n\tconst _functionDeclaration = hasModifier(node, typescript.SyntaxKind.AsyncKeyword)\n\t\t? async function functionDeclaration(this: Literal, ...args: Literal[]) {\n\t\t\t\t// Prepare a lexical environment for the function context\n\t\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment, node);\n\t\t\t\tconst nextOptions = {...options, environment: localLexicalEnvironment};\n\n\t\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: RETURN_SYMBOL, value: false, newBinding: true});\n\n\t\t\t\t// Define a new binding for the arguments given to the function\n\t\t\t\t// eslint-disable-next-line prefer-rest-params\n\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: \"arguments\", value: arguments, newBinding: true});\n\n\t\t\t\tif (this != null) {\n\t\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: THIS_SYMBOL, value: this, newBinding: true});\n\t\t\t\t}\n\n\t\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\t\tevaluateParameterDeclarations(\n\t\t\t\t\t{\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\t\tenvironment: localLexicalEnvironment\n\t\t\t\t\t},\n\t\t\t\t\targs\n\t\t\t\t);\n\n\t\t\t\tif (getCurrentError() != null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst sourceFile = node.getSourceFile();\n\t\t\t\tif (nameResult != null && sourceFile.isDeclarationFile) {\n\t\t\t\t\tconst implementation = getImplementationForDeclarationWithinDeclarationFile(options);\n\t\t\t\t\treturn (implementation as CallableFunction)(...args);\n\t\t\t\t}\n\n\t\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\t\tif (node.body == null) return;\n\t\t\t\tevaluate.statement(node.body, nextOptions);\n\n\t\t\t\tif (getCurrentError() != null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\t\treturn stack.pop();\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\t\telse {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t  }\n\t\t: function functionDeclaration(this: Literal, ...args: Literal[]) {\n\t\t\t\t// Prepare a lexical environment for the function context\n\t\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment, node);\n\t\t\t\tconst nextOptions = {...options, environment: localLexicalEnvironment};\n\n\t\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: RETURN_SYMBOL, value: false, newBinding: true});\n\n\t\t\t\t// Define a new binding for the arguments given to the function\n\t\t\t\t// eslint-disable-next-line prefer-rest-params\n\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: \"arguments\", value: arguments, newBinding: true});\n\n\t\t\t\tif (this != null) {\n\t\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: THIS_SYMBOL, value: this, newBinding: true});\n\t\t\t\t}\n\n\t\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\t\tevaluateParameterDeclarations(\n\t\t\t\t\t{\n\t\t\t\t\t\t...nextOptions,\n\t\t\t\t\t\tnode: node.parameters\n\t\t\t\t\t},\n\t\t\t\t\targs\n\t\t\t\t);\n\n\t\t\t\tif (getCurrentError() != null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst sourceFile = node.getSourceFile();\n\t\t\t\tif (nameResult != null && sourceFile.isDeclarationFile) {\n\t\t\t\t\tconst implementation = getImplementationForDeclarationWithinDeclarationFile(options);\n\t\t\t\t\treturn (implementation as CallableFunction)(...args);\n\t\t\t\t}\n\n\t\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\t\tif (node.body == null) return;\n\t\t\t\tevaluate.statement(node.body, nextOptions);\n\n\t\t\t\tif (getCurrentError() != null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\t\treturn stack.pop();\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\t\telse return undefined;\n\t\t  };\n\n\tif (nameResult != null) {\n\t\tsetInLexicalEnvironment({...options, path: nameResult, value: _functionDeclaration.bind(_functionDeclaration)});\n\t}\n\n\t_functionDeclaration.toString = () => `[Function${nameResult == null ? \"\" : `: ${nameResult}`}]`;\n\n\t// Make sure to use the Function that is contained within the Realm. Otherwise, 'instanceof' checks may fail\n\t// since this particular function comes from the executing context.\n\tObject.setPrototypeOf(_functionDeclaration, getFromLexicalEnvironment(node, environment, \"Function\")!.literal as CallableFunction);\n\n\tstack.push(_functionDeclaration);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {TS} from \"../../type/ts.js\";\nimport type {EvaluationError} from \"../error/evaluation-error/evaluation-error.js\";\n\n/**\n * Evaluates, or attempts to evaluate, an IfStatement\n */\nexport function evaluateIfStatement({node, evaluate, ...options}: EvaluatorOptions<TS.IfStatement>): void | EvaluationError {\n\tconst {getCurrentError} = options;\n\n\tconst expressionValue = evaluate.expression(node.expression, options);\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\t// We have to perform a loose boolean expression here to conform with actual spec behavior\n\t// eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\tif (expressionValue) {\n\t\t// Proceed with the truthy branch\n\t\tevaluate.statement(node.thenStatement, options);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Proceed with the falsy branch\n\telse if (node.elseStatement != null) {\n\t\treturn evaluate.statement(node.elseStatement, options);\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, an ExpressionStatement\n */\nexport function evaluateExpressionStatement({node, evaluate, stack, ...options}: EvaluatorOptions<TS.ExpressionStatement>): void {\n\tconst result = evaluate.expression(node.expression, options);\n\tif (options.getCurrentError() != null) {\n\t\treturn;\n\t}\n\tstack.push(result);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a TemplateExpression\n */\nexport function evaluateTemplateExpression({node, evaluate, ...options}: EvaluatorOptions<TS.TemplateExpression>): Literal {\n\tlet str = \"\";\n\tstr += node.head.text;\n\tfor (const span of node.templateSpans) {\n\t\tconst expression = evaluate.expression(span.expression, options) as string;\n\n\t\tif (options.getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\tstr += expression;\n\t\tstr += span.literal.text;\n\t}\n\treturn str;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a TypeAssertion\n */\nexport function evaluateTypeAssertion({node, evaluate, ...options}: EvaluatorOptions<TS.TypeAssertion>): Literal {\n\treturn evaluate.expression(node.expression, options);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport {getRelevantDictFromLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a PostfixUnaryExpression\n */\nexport function evaluatePostfixUnaryExpression(options: EvaluatorOptions<TS.PostfixUnaryExpression>): Literal {\n\tconst {evaluate, node, environment, typescript, throwError, reporting} = options;\n\n\t// Make sure to evaluate the operand to ensure that it is found in the lexical environment\n\tevaluate.expression(node.operand, options);\n\n\tswitch (node.operator) {\n\t\tcase typescript.SyntaxKind.PlusPlusToken: {\n\t\t\t// If the Operand isn't an identifier, this will be a SyntaxError\n\t\t\tif (!typescript.isIdentifier(node.operand) && !typescript.isPrivateIdentifier?.(node.operand)) {\n\t\t\t\treturn throwError(new UnexpectedNodeError({node: node.operand, environment, typescript}));\n\t\t\t}\n\n\t\t\t// Find the value associated with the identifier within the environment.\n\t\t\tconst value = (getRelevantDictFromLexicalEnvironment(environment, node.operand.text)![node.operand.text]! as number)++;\n\n\t\t\t// Inform reporting hooks if any is given\n\t\t\tif (reporting.reportBindings != null) {\n\t\t\t\treporting.reportBindings({path: node.operand.text, value, node});\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.MinusMinusToken: {\n\t\t\t// If the Operand isn't an identifier, this will be a SyntaxError\n\t\t\tif (!typescript.isIdentifier(node.operand) && !typescript.isPrivateIdentifier?.(node.operand)) {\n\t\t\t\treturn throwError(new UnexpectedNodeError({node: node.operand, environment, typescript}));\n\t\t\t}\n\n\t\t\t// Find the value associated with the identifier within the environment.\n\t\t\tconst value = (getRelevantDictFromLexicalEnvironment(environment, node.operand.text)![node.operand.text]! as number)--;\n\n\t\t\t// Inform reporting hooks if any is given\n\t\t\tif (reporting.reportBindings != null) {\n\t\t\t\treporting.reportBindings({path: node.operand.text, value, node});\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {maybeThrow} from \"../error/evaluation-error/evaluation-error-intent.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a NewExpression\n */\nexport function evaluateNewExpression({node, evaluate, ...options}: EvaluatorOptions<TS.NewExpression>): Literal {\n\tconst {getCurrentError} = options;\n\tconst evaluatedArgs: Literal[] = [];\n\n\tif (node.arguments != null) {\n\t\tfor (let i = 0; i < node.arguments.length; i++) {\n\t\t\tevaluatedArgs[i] = evaluate.expression(node.arguments[i], options);\n\t\t\tif (getCurrentError() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Evaluate the expression\n\tconst expressionResult = evaluate.expression(node.expression, options) as new (...args: Literal[]) => Literal;\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\t// If the expression evaluated to a function, mark it as the [[NewTarget]], as per https://tc39.es/ecma262/multipage/executable-code-and-execution-contexts.html#sec-getnewtarget\n\tif (typeof expressionResult === \"function\") {\n\t\tsetInLexicalEnvironment({...options, node, path: \"[[NewTarget]]\", value: expressionResult, newBinding: true});\n\t}\n\n\treturn maybeThrow(node, options, new expressionResult(...evaluatedArgs));\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a NonNullExpression\n */\nexport function evaluateNonNullExpression({node, evaluate, ...options}: EvaluatorOptions<TS.NonNullExpression>): Literal {\n\treturn evaluate.expression(node.expression, options);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, an AsExpression\n */\nexport function evaluateAsExpression({node, evaluate, ...options}: EvaluatorOptions<TS.AsExpression>): Literal {\n\treturn evaluate.expression(node.expression, options);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a SwitchStatement\n */\nexport function evaluateSwitchStatement({node, evaluate, ...options}: EvaluatorOptions<TS.SwitchStatement>): void {\n\tconst expressionResult = evaluate.expression(node.expression, options);\n\n\tif (options.getCurrentError() != null) {\n\t\treturn;\n\t}\n\tevaluate.nodeWithArgument(node.caseBlock, expressionResult, options);\n}\n","import type {TS} from \"../../../type/ts.js\";\nimport {EvaluationError} from \"../evaluation-error/evaluation-error.js\";\nimport type {IAsyncIteratorNotSupportedErrorOptions} from \"./i-async-iterator-not-supported-error-options.js\";\n\n/**\n * An Error that can be thrown when an async iteration operation is attempted\n */\nexport class AsyncIteratorNotSupportedError extends EvaluationError {\n\tconstructor({message = `It is not possible to evaluate an async iterator'`, typescript, environment}: IAsyncIteratorNotSupportedErrorOptions) {\n\t\tsuper({\n\t\t\tmessage,\n\t\t\tenvironment,\n\t\t\tnode: typescript.factory?.createEmptyStatement() ?? (typescript as unknown as TS.NodeFactory).createEmptyStatement()\n\t\t});\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment.js\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error.js\";\nimport {pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol.js\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol.js\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol.js\";\nimport type {TS} from \"../../type/ts.js\";\nimport {AsyncIteratorNotSupportedError} from \"../error/async-iterator-not-supported-error/async-iterator-not-supported-error.js\";\nimport type {EvaluationError} from \"../error/evaluation-error/evaluation-error.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a ForOfStatement\n */\nexport function evaluateForOfStatement(options: EvaluatorOptions<TS.ForOfStatement>): void | EvaluationError {\n\tconst {node, environment, evaluate, logger, typescript, throwError, getCurrentError} = options;\n\t// Compute the 'of' part\n\tconst expressionResult = evaluate.expression(node.expression, options) as Iterable<Literal>;\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\t// Ensure that the initializer is a proper VariableDeclarationList\n\tif (!typescript.isVariableDeclarationList(node.initializer)) {\n\t\treturn throwError(new UnexpectedNodeError({node: node.initializer, environment, typescript}));\n\t}\n\n\t// Only 1 declaration is allowed in a ForOfStatement\n\telse if (node.initializer.declarations.length > 1) {\n\t\treturn throwError(new UnexpectedNodeError({node: node.initializer.declarations[1], environment, typescript}));\n\t}\n\n\t// As long as we only offer a synchronous API, there's no way to evaluate an async iterator in a synchronous fashion\n\tif (node.awaitModifier != null) {\n\t\treturn throwError(new AsyncIteratorNotSupportedError({typescript, environment}));\n\t} else {\n\t\tfor (const literal of expressionResult) {\n\t\t\t// Prepare a lexical environment for the current iteration\n\t\t\tconst localEnvironment = cloneLexicalEnvironment(environment, node);\n\t\t\tconst nextOptions = {...options, environment: localEnvironment};\n\n\t\t\t// Define a new binding for a break symbol within the environment\n\t\t\tsetInLexicalEnvironment({...nextOptions, path: BREAK_SYMBOL, value: false, newBinding: true});\n\n\t\t\t// Define a new binding for a continue symbol within the environment\n\t\t\tsetInLexicalEnvironment({...nextOptions, path: CONTINUE_SYMBOL, value: false, newBinding: true});\n\n\t\t\t// Evaluate the VariableDeclaration and manually pass in the current literal as the initializer for the variable assignment\n\t\t\tevaluate.nodeWithArgument(node.initializer.declarations[0], literal, nextOptions);\n\n\t\t\tif (getCurrentError() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Evaluate the Statement\n\t\t\tevaluate.statement(node.statement, nextOptions);\n\n\t\t\tif (getCurrentError() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if a 'break' statement has been encountered and break if so\n\t\t\tif (pathInLexicalEnvironmentEquals(node, localEnvironment, true, BREAK_SYMBOL)) {\n\t\t\t\tlogger.logBreak(node, typescript);\n\t\t\t\tbreak;\n\t\t\t} else if (pathInLexicalEnvironmentEquals(node, localEnvironment, true, CONTINUE_SYMBOL)) {\n\t\t\t\tlogger.logContinue(node, typescript);\n\t\t\t\t// noinspection UnnecessaryContinueJS\n\t\t\t\tcontinue;\n\t\t\t} else if (pathInLexicalEnvironmentEquals(node, localEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\tlogger.logReturn(node, typescript);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a ThisExpression\n */\nexport function evaluateThisExpression({node, environment}: EvaluatorOptions<TS.ThisExpression>): Literal {\n\tconst match = getFromLexicalEnvironment(node, environment, THIS_SYMBOL);\n\treturn match == null ? undefined : match.literal;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a BreakStatement\n */\nexport function evaluateBreakStatement(options: EvaluatorOptions<TS.BreakStatement>): void {\n\tsetInLexicalEnvironment({...options, path: BREAK_SYMBOL, value: true});\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a ContinueStatement\n */\nexport function evaluateContinueStatement(options: EvaluatorOptions<TS.ContinueStatement>): void {\n\tsetInLexicalEnvironment({...options, path: CONTINUE_SYMBOL, value: true});\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment.js\";\nimport {pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol.js\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol.js\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a ForStatement\n */\nexport function evaluateForStatement({environment, evaluate, typescript, ...options}: EvaluatorOptions<TS.ForStatement>): void {\n\tconst {node, getCurrentError} = options;\n\t// Prepare a lexical environment for the ForStatement\n\tconst forEnvironment = cloneLexicalEnvironment(environment, node);\n\tconst forOptions = {...options, environment: forEnvironment};\n\n\t// Evaluate the initializer if it is given\n\tif (node.initializer !== undefined) {\n\t\tif (typescript.isVariableDeclarationList(node.initializer)) {\n\t\t\tfor (const declaration of node.initializer.declarations) {\n\t\t\t\tevaluate.declaration(declaration, forOptions);\n\n\t\t\t\tif (getCurrentError() != null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tevaluate.expression(node.initializer, forOptions);\n\n\t\t\tif (getCurrentError() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\t// Prepare a lexical environment for the current iteration\n\t\tconst iterationEnvironment = cloneLexicalEnvironment(forEnvironment, node);\n\t\tconst iterationOptions = {...options, environment: iterationEnvironment};\n\n\t\t// Define a new binding for a break symbol within the environment\n\t\tsetInLexicalEnvironment({...iterationOptions, path: BREAK_SYMBOL, value: false, newBinding: true});\n\n\t\t// Define a new binding for a continue symbol within the environment\n\t\tsetInLexicalEnvironment({...iterationOptions, path: CONTINUE_SYMBOL, value: false, newBinding: true});\n\n\t\t// Evaluate the condition. It may be truthy always\n\t\tconst conditionResult = node.condition == null ? true : (evaluate.expression(node.condition, forOptions) as boolean);\n\n\t\t// If the condition doesn't hold, return immediately\n\t\tif (!conditionResult || getCurrentError() != null) return;\n\n\t\t// Execute the Statement\n\t\tevaluate.statement(node.statement, iterationOptions);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if a 'break' statement has been encountered and break if so\n\t\tif (pathInLexicalEnvironmentEquals(node, iterationEnvironment, true, BREAK_SYMBOL)) {\n\t\t\tbreak;\n\t\t} else if (pathInLexicalEnvironmentEquals(node, iterationEnvironment, true, RETURN_SYMBOL)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Run the incrementor\n\t\tif (node.incrementor != null) {\n\t\t\tevaluate.expression(node.incrementor, forOptions);\n\n\t\t\tif (getCurrentError() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Always run the incrementor before continuing\n\t\telse if (pathInLexicalEnvironmentEquals(node, iterationEnvironment, true, CONTINUE_SYMBOL)) {\n\t\t\t// noinspection UnnecessaryContinueJS\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment.js\";\nimport {pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol.js\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol.js\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a WhileStatement\n */\nexport function evaluateWhileStatement(options: EvaluatorOptions<TS.WhileStatement>): void {\n\tconst {node, environment, evaluate, logger, typescript, getCurrentError} = options;\n\tlet condition = evaluate.expression(node.expression, options) as boolean;\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\twhile (condition) {\n\t\t// Prepare a lexical environment for the current iteration\n\t\tconst iterationEnvironment = cloneLexicalEnvironment(environment, node);\n\t\tconst iterationOptions = {...options, environment: iterationEnvironment};\n\n\t\t// Define a new binding for a break symbol within the environment\n\t\tsetInLexicalEnvironment({...iterationOptions, path: BREAK_SYMBOL, value: false, newBinding: true});\n\n\t\t// Define a new binding for a continue symbol within the environment\n\t\tsetInLexicalEnvironment({...iterationOptions, path: CONTINUE_SYMBOL, value: false, newBinding: true});\n\n\t\t// Execute the Statement\n\t\tevaluate.statement(node.statement, iterationOptions);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if a 'break' statement has been encountered and break if so\n\t\tif (pathInLexicalEnvironmentEquals(node, iterationEnvironment, true, BREAK_SYMBOL)) {\n\t\t\tlogger.logBreak(node, typescript);\n\t\t\tbreak;\n\t\t} else if (pathInLexicalEnvironmentEquals(node, iterationEnvironment, true, RETURN_SYMBOL)) {\n\t\t\tlogger.logReturn(node, typescript);\n\t\t\treturn;\n\t\t}\n\n\t\tcondition = evaluate.expression(node.expression, options) as boolean;\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Always re-evaluate the condition before continuing\n\t\tif (pathInLexicalEnvironmentEquals(node, iterationEnvironment, true, CONTINUE_SYMBOL)) {\n\t\t\tlogger.logContinue(node, typescript);\n\t\t\t// noinspection UnnecessaryContinueJS\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {IndexLiteral} from \"../literal/literal.js\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment.js\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error.js\";\nimport {pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol.js\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol.js\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol.js\";\nimport type {TS} from \"../../type/ts.js\";\nimport type {EvaluationError} from \"../error/evaluation-error/evaluation-error.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a ForInStatement\n */\nexport function evaluateForInStatement(options: EvaluatorOptions<TS.ForInStatement>): void | EvaluationError {\n\tconst {node, environment, evaluate, logger, typescript, throwError, getCurrentError} = options;\n\t// Compute the 'of' part\n\tconst expressionResult = evaluate.expression(node.expression, options) as IndexLiteral;\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\t// Ensure that the initializer is a proper VariableDeclarationList\n\tif (!typescript.isVariableDeclarationList(node.initializer)) {\n\t\treturn throwError(new UnexpectedNodeError({node: node.initializer, environment, typescript}));\n\t}\n\n\t// Only 1 declaration is allowed in a ForOfStatement\n\telse if (node.initializer.declarations.length > 1) {\n\t\treturn throwError(new UnexpectedNodeError({node: node.initializer.declarations[1], environment, typescript}));\n\t}\n\n\tfor (const literal in expressionResult) {\n\t\t// Prepare a lexical environment for the current iteration\n\t\tconst localEnvironment = cloneLexicalEnvironment(environment, node);\n\t\tconst nextOptions = {...options, environment: localEnvironment};\n\n\t\t// Define a new binding for a break symbol within the environment\n\t\tsetInLexicalEnvironment({...nextOptions, path: BREAK_SYMBOL, value: false, newBinding: true});\n\n\t\t// Define a new binding for a continue symbol within the environment\n\t\tsetInLexicalEnvironment({...nextOptions, path: CONTINUE_SYMBOL, value: false, newBinding: true});\n\n\t\t// Evaluate the VariableDeclaration and manually pass in the current literal as the initializer for the variable assignment\n\t\tevaluate.nodeWithArgument(node.initializer.declarations[0], literal, nextOptions);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Evaluate the Statement\n\t\tevaluate.statement(node.statement, nextOptions);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if a 'break' statement has been encountered and break if so\n\t\tif (pathInLexicalEnvironmentEquals(node, localEnvironment, true, BREAK_SYMBOL)) {\n\t\t\tlogger.logBreak(node, typescript);\n\t\t\tbreak;\n\t\t} else if (pathInLexicalEnvironmentEquals(node, localEnvironment, true, CONTINUE_SYMBOL)) {\n\t\t\tlogger.logContinue(node, typescript);\n\t\t\t// noinspection UnnecessaryContinueJS\n\t\t\tcontinue;\n\t\t} else if (pathInLexicalEnvironmentEquals(node, localEnvironment, true, RETURN_SYMBOL)) {\n\t\t\tlogger.logReturn(node, typescript);\n\t\t\treturn;\n\t\t}\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type { LexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {getFromLexicalEnvironment, pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport {evaluateParameterDeclarations} from \"./evaluate-parameter-declarations.js\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol.js\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol.js\";\nimport {hasModifier} from \"../util/modifier/has-modifier.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a FunctionExpression\n */\nexport function evaluateFunctionExpression(options: EvaluatorOptions<TS.FunctionExpression>): Literal {\n\tconst {node, environment, evaluate, stack, typescript, getCurrentError} = options;\n\tconst nameResult = node.name == null ? undefined : node.name.text;\n\n\tconst _functionExpression = hasModifier(node, typescript.SyntaxKind.AsyncKeyword)\n\t\t? async function functionExpression(this: Literal, ...args: Literal[]) {\n\t\t\t\t// Prepare a lexical environment for the function context\n\t\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment, node);\n\t\t\t\tconst nextOptions = {...options, environment: localLexicalEnvironment};\n\n\t\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: RETURN_SYMBOL, value: false, newBinding: true});\n\n\t\t\t\t// Define a new binding for the arguments given to the function\n\t\t\t\t// eslint-disable-next-line prefer-rest-params\n\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: \"arguments\", value: arguments, newBinding: true});\n\n\t\t\t\tif (this != null) {\n\t\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: THIS_SYMBOL, value: this, newBinding: true});\n\t\t\t\t}\n\n\t\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\t\tevaluateParameterDeclarations(\n\t\t\t\t\t{\n\t\t\t\t\t\t...nextOptions,\n\t\t\t\t\t\tnode: node.parameters\n\t\t\t\t\t},\n\t\t\t\t\targs\n\t\t\t\t);\n\n\t\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\t\tif (node.body == null || getCurrentError() != null) return;\n\t\t\t\tevaluate.statement(node.body, nextOptions);\n\n\t\t\t\tif (getCurrentError() != null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\t\treturn stack.pop();\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\t\telse return undefined;\n\t\t  }\n\t\t: function functionExpression(this: Literal, ...args: Literal[]) {\n\t\t\t\t// Prepare a lexical environment for the function context\n\t\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment, node);\n\t\t\t\tconst nextOptions = {...options, environment: localLexicalEnvironment};\n\n\t\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: RETURN_SYMBOL, value: false, newBinding: true});\n\n\t\t\t\t// Define a new binding for the arguments given to the function\n\t\t\t\t// eslint-disable-next-line prefer-rest-params\n\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: \"arguments\", value: arguments, newBinding: true});\n\n\t\t\t\tif (this != null) {\n\t\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: THIS_SYMBOL, value: this, newBinding: true});\n\t\t\t\t}\n\n\t\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\t\tevaluateParameterDeclarations(\n\t\t\t\t\t{\n\t\t\t\t\t\t...nextOptions,\n\t\t\t\t\t\tnode: node.parameters\n\t\t\t\t\t},\n\t\t\t\t\targs\n\t\t\t\t);\n\n\t\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\t\tif (node.body == null || getCurrentError() != null) return;\n\t\t\t\tevaluate.statement(node.body, nextOptions);\n\n\t\t\t\tif (getCurrentError() != null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\t\treturn stack.pop();\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\t\telse return undefined;\n\t\t  };\n\n\tif (nameResult != null) {\n\t\tsetInLexicalEnvironment({...options, path: nameResult, value: _functionExpression.bind(_functionExpression)});\n\t}\n\n\t_functionExpression.toString = () => `[Function${nameResult == null ? \"\" : `: ${nameResult}`}]`;\n\n\t// Make sure to use the Function that is contained within the Realm. Otherwise, 'instanceof' checks may fail\n\t// since this particular function comes from the executing context.\n\tObject.setPrototypeOf(_functionExpression, getFromLexicalEnvironment(node, environment, \"Function\")!.literal as CallableFunction);\n\n\treturn _functionExpression;\n}\n","import {EvaluationError} from \"../evaluation-error/evaluation-error.js\";\nimport type {IMissingCatchOrFinallyAfterTryErrorOptions} from \"./i-missing-catch-or-finally-after-try-error-options.js\";\nimport type {TS} from \"../../../type/ts.js\";\n\n/**\n * An Error that can be thrown when a TryStatement is encountered without neither a catch {...} nor a finally {...} block\n */\nexport class MissingCatchOrFinallyAfterTryError extends EvaluationError {\n\t/**\n\t * The TryStatement that lacks a catch/finally block\n\t */\n\treadonly node!: TS.TryStatement;\n\n\tconstructor({node, environment, message = `Missing catch or finally after try`}: IMissingCatchOrFinallyAfterTryErrorOptions) {\n\t\tsuper({node, environment, message});\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {MissingCatchOrFinallyAfterTryError} from \"../error/missing-catch-or-finally-after-try-error/missing-catch-or-finally-after-try-error.js\";\nimport type {TS} from \"../../type/ts.js\";\nimport type {EvaluationError} from \"../error/evaluation-error/evaluation-error.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a TryStatement\n */\nexport function evaluateTryStatement(options: EvaluatorOptions<TS.TryStatement>): void | EvaluationError {\n\tconst {node, evaluate, environment, throwError} = options;\n\n\tlet error: EvaluationError | undefined;\n\n\tconst executeTry = () => {\n\t\ttry {\n\t\t\treturn evaluate.statement(node.tryBlock, {\n\t\t\t\t...options,\n\t\t\t\tthrowError: ex => {\n\t\t\t\t\terror = ex;\n\t\t\t\t\treturn ex;\n\t\t\t\t},\n\t\t\t\tgetCurrentError: () => error\n\t\t\t});\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t} catch (ex: any) {\n\t\t\terror = ex;\n\t\t}\n\t};\n\n\tconst executeCatch = (ex: Error) => {\n\t\t// The CatchClause will declare an environment of its own\n\t\tevaluate.nodeWithArgument(node.catchClause!, ex, options);\n\t};\n\n\tconst executeFinally = () => {\n\t\tlet finallyError: EvaluationError | undefined;\n\n\t\t// The Block will declare an environment of its own\n\t\tevaluate.statement(node.finallyBlock!, {\n\t\t\t...options,\n\t\t\tthrowError: ex => {\n\t\t\t\tfinallyError = ex;\n\t\t\t\t// Also set it on the upper context\n\t\t\t\toptions.throwError(ex);\n\t\t\t\treturn ex;\n\t\t\t},\n\t\t\tgetCurrentError: () => finallyError\n\t\t});\n\t};\n\n\t// A TryStatement must have either a catch or a finally block\n\tif (node.catchClause == null && node.finallyBlock == null) {\n\t\treturn throwError(new MissingCatchOrFinallyAfterTryError({node, environment}));\n\t}\n\n\t// Follows the form: try {...} catch {...}\n\telse if (node.catchClause != null && node.finallyBlock == null) {\n\t\texecuteTry();\n\t\tif (error != null) {\n\t\t\texecuteCatch(error);\n\t\t}\n\t}\n\n\t// Follows the form: try {...} catch {...} finally {...}\n\telse if (node.catchClause != null && node.finallyBlock != null) {\n\t\texecuteTry();\n\t\tif (error != null) {\n\t\t\texecuteCatch(error);\n\t\t}\n\t\texecuteFinally();\n\t}\n\n\t// Follows the form: try {...} finally {...}\n\telse if (node.catchClause == null && node.finallyBlock != null) {\n\t\texecuteTry();\n\t\tif (error != null) {\n\t\t\tthrowError(error);\n\t\t}\n\n\t\texecuteFinally();\n\t}\n}\n","import type {IGenerateClassDeclarationOptions} from \"./i-generate-class-declaration-options.js\";\n\n/**\n * A function that uses 'new Function' to auto-generate a class with a dynamic name and extended type\n */\nexport function generateClassDeclaration({\n\tname,\n\textendedType,\n\tctor = () => {\n\t\t// Noop\n\t}\n}: Partial<IGenerateClassDeclarationOptions>): CallableFunction {\n\tif (extendedType == null) {\n\t\treturn new Function(\n\t\t\t\"ctor\",\n\t\t\t`return class ${name == null ? \"\" : name} {constructor () {const ctorReturnValue = ctor.call(this, ...arguments); if (ctorReturnValue != null) return ctorReturnValue;}}`\n\t\t)(ctor);\n\t} else {\n\t\treturn new Function(\n\t\t\t\"extendedType\",\n\t\t\t\"ctor\",\n\t\t\t`return class ${\n\t\t\t\tname == null ? \"\" : name\n\t\t\t} extends extendedType {constructor () {super(...arguments); const ctorReturnValue = ctor.call(this, ...arguments); if (ctorReturnValue != null) return ctorReturnValue;}}`\n\t\t)(extendedType, ctor);\n\t}\n}\n","import type {TS} from \"../../../type/ts.js\";\n\nexport function canHaveModifiers(node: TS.Node, typescript: typeof TS): node is TS.HasModifiers {\n\tif (\"canHaveModifiers\" in typescript) {\n\t\treturn typescript.canHaveModifiers(node);\n\t} else {\n\t\treturn true;\n\t}\n}\nexport function getModifiers(node: TS.HasModifiers, typescript: typeof TS): readonly TS.Modifier[] | undefined {\n\tif (\"getModifiers\" in typescript) {\n\t\treturn typescript.getModifiers(node);\n\t} else {\n\t\treturn node.modifiers?.filter(modifier => !(\"expression\" in modifier)) as readonly TS.Modifier[] | undefined;\n\t}\n}\n\nexport function canHaveDecorators(node: TS.Node, typescript: typeof TS): node is TS.HasDecorators {\n\tif (\"canHaveDecorators\" in typescript) {\n\t\treturn typescript.canHaveDecorators(node);\n\t} else {\n\t\treturn true;\n\t}\n}\nexport function getDecorators(node: TS.HasDecorators, typescript: typeof TS): readonly TS.Decorator[] | undefined {\n\tif (\"getDecorators\" in typescript) {\n\t\treturn typescript.getDecorators(node);\n\t} else {\n\t\tconst legacyDecorators = \"decorators\" in node && Array.isArray(node.decorators) ? node.decorators : undefined;\n\t\tconst decoratorModifierLikes = node.modifiers?.filter(modifier => \"expression\" in modifier) as readonly TS.Decorator[] | undefined;\n\t\treturn [...(legacyDecorators ?? []), ...(decoratorModifierLikes ?? [])];\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {generateClassDeclaration} from \"../util/class/generate-class-declaration.js\";\nimport {hasModifier} from \"../util/modifier/has-modifier.js\";\nimport type {TS} from \"../../type/ts.js\";\nimport {canHaveDecorators, getDecorators} from \"../util/node/modifier-util.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a ClassDeclaration\n */\nexport function evaluateClassDeclaration(options: EvaluatorOptions<TS.ClassDeclaration>): void {\n\tconst {node, evaluate, stack, logger, typescript, getCurrentError} = options;\n\tlet extendedType: CallableFunction | undefined;\n\tconst ctorMember = node.members.find(typescript.isConstructorDeclaration);\n\tconst otherMembers = node.members.filter(member => !typescript.isConstructorDeclaration(member));\n\n\tlet ctor: CallableFunction | undefined;\n\tif (ctorMember != null) {\n\t\tevaluate.declaration(ctorMember, options);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\tctor = stack.pop() as CallableFunction;\n\t}\n\n\tif (node.heritageClauses != null) {\n\t\tconst extendsClause = node.heritageClauses.find(clause => clause.token === typescript.SyntaxKind.ExtendsKeyword);\n\t\tif (extendsClause != null) {\n\t\t\tconst [firstExtendedType] = extendsClause.types;\n\t\t\tif (firstExtendedType != null) {\n\t\t\t\textendedType = evaluate.expression(firstExtendedType.expression, options) as CallableFunction;\n\n\t\t\t\tif (getCurrentError() != null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tconst name = node.name == null ? undefined : node.name.text;\n\tlet classDeclaration = generateClassDeclaration({name, extendedType, ctor});\n\n\tif (canHaveDecorators(node, typescript)) {\n\t\tfor (const decorator of getDecorators(node, typescript) ?? []) {\n\t\t\tevaluate.nodeWithArgument(decorator, [classDeclaration], options);\n\n\t\t\tif (getCurrentError() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclassDeclaration = stack.pop() as CallableFunction;\n\t\t}\n\t}\n\n\tclassDeclaration.toString = () => `[Class${name == null ? \"\" : `: ${name}`}]`;\n\n\tif (name != null) {\n\t\tsetInLexicalEnvironment({...options, path: name, value: classDeclaration, newBinding: true});\n\t}\n\n\t// Walk through all of the class members\n\tfor (const member of otherMembers) {\n\t\tevaluate.nodeWithArgument(member, hasModifier(member, typescript.SyntaxKind.StaticKeyword) ? classDeclaration : classDeclaration.prototype, options);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlogger.logHeritage(classDeclaration);\n\tstack.push(classDeclaration);\n\tlogger.logStack(stack);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {LexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport { pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment.js\";\nimport type {IndexLiteral, Literal} from \"../literal/literal.js\";\nimport {evaluateParameterDeclarations} from \"./evaluate-parameter-declarations.js\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol.js\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a ConstructorDeclaration\n */\nexport function evaluateConstructorDeclaration(options: EvaluatorOptions<TS.ConstructorDeclaration>): void {\n\tconst {node, environment, evaluate, stack, getCurrentError} = options;\n\n\t/**\n\t * An implementation of a constructor function\n\t */\n\tfunction constructor(this: IndexLiteral, ...args: Literal[]) {\n\t\t// Don't concern yourself with calling super here as this constructor is called immediately after calling super() in another memory representation of a class\n\n\t\t// Prepare a lexical environment for the function context\n\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment, node);\n\t\tconst nextOptions = {...options, environment: localLexicalEnvironment};\n\n\t\t// Define a new binding for a return symbol within the environment\n\t\tsetInLexicalEnvironment({...nextOptions, path: RETURN_SYMBOL, value: false, newBinding: true});\n\n\t\t// Define a new binding for the arguments given to the function\n\t\t// eslint-disable-next-line prefer-rest-params\n\t\tsetInLexicalEnvironment({...nextOptions, path: \"arguments\", value: arguments, newBinding: true});\n\n\t\tif (this != null) {\n\t\t\tsetInLexicalEnvironment({...nextOptions, path: THIS_SYMBOL, value: this, newBinding: true});\n\t\t}\n\n\t\t// Evaluate the parameters based on the given arguments\n\t\tevaluateParameterDeclarations(\n\t\t\t{\n\t\t\t\t...nextOptions,\n\t\t\t\tnode: node.parameters\n\t\t\t},\n\t\t\targs,\n\t\t\tthis\n\t\t);\n\n\t\t// If the body is a block, evaluate it as a statement\n\t\tif (node.body == null || getCurrentError() != null) return;\n\n\t\tevaluate.statement(node.body, nextOptions);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\treturn stack.pop();\n\t\t}\n\n\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\telse return undefined;\n\t}\n\n\tconstructor.toString = () => \"[Function: constructor]\";\n\tstack.push(constructor);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {SUPER_SYMBOL} from \"../util/super/super-symbol.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a SuperExpression\n */\nexport function evaluateSuperExpression({node, environment}: EvaluatorOptions<TS.SuperExpression>): Literal {\n\tconst match = getFromLexicalEnvironment(node, environment, SUPER_SYMBOL);\n\treturn match == null ? undefined : match.literal;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a SpreadElement, before applying it on the given parent\n */\nexport function evaluateSpreadElement({node, evaluate, ...options}: EvaluatorOptions<TS.SpreadElement>): Literal[] {\n\treturn evaluate.expression(node.expression, options) as Literal[];\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {generateClassDeclaration} from \"../util/class/generate-class-declaration.js\";\nimport {hasModifier} from \"../util/modifier/has-modifier.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\nimport {canHaveDecorators, getDecorators} from \"../util/node/modifier-util.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a ClassExpression\n */\nexport function evaluateClassExpression(options: EvaluatorOptions<TS.ClassExpression>): Literal {\n\tconst {node, evaluate, stack, logger, typescript, getCurrentError} = options;\n\n\tlet extendedType: CallableFunction | undefined;\n\tconst ctorMember = node.members.find(typescript.isConstructorDeclaration);\n\tconst otherMembers = node.members.filter(member => !typescript.isConstructorDeclaration(member));\n\n\tlet ctor: CallableFunction | undefined;\n\tif (ctorMember != null) {\n\t\tevaluate.declaration(ctorMember, options);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\tctor = stack.pop() as CallableFunction;\n\t}\n\n\tif (node.heritageClauses != null) {\n\t\tconst extendsClause = node.heritageClauses.find(clause => clause.token === typescript.SyntaxKind.ExtendsKeyword);\n\t\tif (extendsClause != null) {\n\t\t\tconst [firstExtendedType] = extendsClause.types;\n\t\t\tif (firstExtendedType != null) {\n\t\t\t\textendedType = evaluate.expression(firstExtendedType.expression, options) as CallableFunction;\n\n\t\t\t\tif (getCurrentError() != null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tconst name = node.name == null ? undefined : node.name.text;\n\tlet classExpression = generateClassDeclaration({name, extendedType, ctor});\n\n\tif (canHaveDecorators(node, typescript)) {\n\t\tfor (const decorator of getDecorators(node, typescript) ?? []) {\n\t\t\tevaluate.nodeWithArgument(decorator, [classExpression], options);\n\n\t\t\tif (getCurrentError() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclassExpression = stack.pop() as CallableFunction;\n\t\t}\n\t}\n\n\tclassExpression.toString = () => `[Class${name == null ? \"\" : `: ${name}`}]`;\n\n\tif (name != null) {\n\t\tsetInLexicalEnvironment({...options, path: name, value: classExpression, newBinding: true});\n\t}\n\n\t// Walk through all of the class members\n\tfor (const member of otherMembers) {\n\t\tevaluate.nodeWithArgument(member, hasModifier(member, typescript.SyntaxKind.StaticKeyword) ? classExpression : classExpression.prototype, options);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlogger.logHeritage(classExpression);\n\treturn classExpression;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a NullLiteral\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function evaluateNullLiteral(_options: EvaluatorOptions<TS.NullLiteral>): Literal {\n\treturn null;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a VoidExpression\n */\nexport function evaluateVoidExpression({node, evaluate, ...options}: EvaluatorOptions<TS.VoidExpression>): Literal {\n\tevaluate.expression(node.expression, options);\n\t// The void operator evaluates the expression and then returns undefined\n\treturn undefined;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a TypeOfExpression\n */\nexport function evaluateTypeOfExpression({evaluate, node, ...options}: EvaluatorOptions<TS.TypeOfExpression>): Literal {\n\tconst result = evaluate.expression(node.expression, options);\n\n\tif (options.getCurrentError() != null) {\n\t\treturn;\n\t}\n\treturn typeof result;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a BigIntLiteral\n */\nexport function evaluateBigIntLiteral({node, environment}: EvaluatorOptions<TS.BigIntLiteral>): Literal {\n\t// Use BigInt from the Realm instead of the executing context such that instanceof checks won't fail, etc.\n\tconst _BigInt = getFromLexicalEnvironment(node, environment, \"BigInt\")!.literal as BigIntConstructor;\n\n\t// BigInt allows taking in strings, but they must appear as BigInt literals (e.g. \"2n\" is not allowed, but \"2\" is)\n\treturn _BigInt(node.text.endsWith(\"n\") ? node.text.slice(0, -1) : node.text);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {IndexLiteral} from \"../literal/literal.js\";\nimport {getFromLexicalEnvironment, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, an EnumDeclaration\n */\nexport function evaluateEnumDeclaration(options: EvaluatorOptions<TS.EnumDeclaration>): void {\n\tconst {node, environment, evaluate, stack, getCurrentError} = options;\n\n\t// Create a new ObjectLiteral based on the Object implementation from the Realm since this must not be the same as in the parent executing context\n\t// Otherwise, instanceof checks would fail\n\tconst objectCtor = getFromLexicalEnvironment(node, environment, \"Object\")!.literal as ObjectConstructor;\n\tconst enumDeclaration: IndexLiteral = objectCtor.create(objectCtor.prototype);\n\tconst name = node.name.text;\n\n\t// Bind the Enum to the lexical environment as a new binding\n\tsetInLexicalEnvironment({...options, path: name, value: enumDeclaration, newBinding: true});\n\n\tfor (const member of node.members) {\n\t\tevaluate.nodeWithArgument(member, enumDeclaration, options);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tenumDeclaration.toString = () => `[Enum: ${name}]`;\n\n\t// Push the Enum declaration on to the Stack\n\tstack.push(enumDeclaration);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {IndexLiteral} from \"../literal/literal.js\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a SourceFile as a namespace object\n */\nexport function evaluateSourceFileAsNamespaceObject(options: EvaluatorOptions<TS.SourceFile>): void {\n\tconst {node, evaluate, environment, typeChecker, stack, getCurrentError} = options;\n\t// Create a new ObjectLiteral based on the Object implementation from the Realm since this must not be the same as in the parent executing context\n\t// Otherwise, instanceof checks would fail\n\tconst objectCtor = getFromLexicalEnvironment(node, environment, \"Object\")!.literal as ObjectConstructor;\n\tconst namespaceObject: IndexLiteral = objectCtor.create(objectCtor.prototype);\n\n\tconst moduleSymbol = typeChecker?.getSymbolAtLocation(node);\n\tif (moduleSymbol != null) {\n\t\tconst exports = moduleSymbol.exports;\n\t\tif (exports != null) {\n\t\t\tfor (const [identifier, symbol] of exports.entries() as IterableIterator<[string, TS.Symbol]>) {\n\t\t\t\tconst valueDeclaration = symbol.valueDeclaration;\n\t\t\t\tif (valueDeclaration == null) return;\n\n\t\t\t\tevaluate.declaration(valueDeclaration, options);\n\n\t\t\t\tif (getCurrentError() != null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tnamespaceObject[identifier] = stack.pop();\n\t\t\t}\n\t\t}\n\t}\n\tstack.push(namespaceObject);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {getImplementationForDeclarationWithinDeclarationFile} from \"../util/module/get-implementation-for-declaration-within-declaration-file.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a ModuleDeclaration\n */\nexport function evaluateModuleDeclaration(options: EvaluatorOptions<TS.ModuleDeclaration>): void {\n\tconst {getCurrentError, stack} = options;\n\tconst result = getImplementationForDeclarationWithinDeclarationFile(options);\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\tstack.push(result);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, an ImportDeclaration (which is actually a Statement).\n */\nexport function evaluateImportDeclaration({node, evaluate, ...options}: EvaluatorOptions<TS.ImportDeclaration>): void {\n\tif (node.importClause == null) return;\n\tevaluate.declaration(node.importClause, options);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {TS} from \"../../type/ts.js\";\nimport type { EvaluationError } from \"../error/evaluation-error/evaluation-error.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a ThrowStatement\n */\nexport function evaluateThrowStatement({node, evaluate, ...options}: EvaluatorOptions<TS.ThrowStatement>): void|EvaluationError {\n\tconst {getCurrentError, throwError} = options;\n\tconst result = evaluate.expression(node.expression, options) as EvaluationError;\n\t\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\treturn throwError(result);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, an ImportEqualsDeclaration (which is actually a Statement).\n * It will be a noop, since we rely on the TypeChecker to resolve symbols across SourceFiles,\n * rather than manually parsing and resolving imports/exports\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function evaluateImportEqualsDeclaration(_options: EvaluatorOptions<TS.ImportEqualsDeclaration>): void {\n\t// Noop\n}\n","import type {IMaxOpDurationExceededErrorOptions} from \"./i-max-op-duration-exceeded-error-options.js\";\nimport {PolicyError} from \"../policy-error.js\";\n\n/**\n * An Error that can be thrown when the maximum amount of operations dictated by the policy is exceeded\n */\nexport class MaxOpDurationExceededError extends PolicyError {\n\t/**\n\t * The total duration of an operation that was being performed before exceeding the limit\n\t */\n\treadonly duration: number;\n\n\tconstructor({duration, environment, node, message = `Maximum operation duration exceeded: ${duration}`}: IMaxOpDurationExceededErrorOptions) {\n\t\tsuper({violation: \"maxOpDuration\", message, node, environment});\n\t\tthis.duration = duration;\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport {MaxOpDurationExceededError} from \"../error/policy-error/max-op-duration-exceeded-error/max-op-duration-exceeded-error.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, an AwaitExpression\n */\nexport async function evaluateAwaitExpression(options: EvaluatorOptions<TS.AwaitExpression>): Promise<Literal> {\n\tconst {node, environment, evaluate, policy, throwError, getCurrentError} = options;\n\t// If a maximum duration for any operation is given, set a timeout that will throw a PolicyError when and if the duration is exceeded.\n\tconst timeout =\n\t\tpolicy.maxOpDuration === Infinity\n\t\t\t? undefined\n\t\t\t: setTimeout(() => {\n\t\t\t\t\tthrowError(new MaxOpDurationExceededError({duration: policy.maxOpDuration, node, environment}));\n\t\t\t  }, policy.maxOpDuration);\n\n\tconst result = evaluate.expression(node.expression, options) as Promise<Literal>;\n\n\t// Make sure to clear the timeout if it exists to avoid throwing unnecessarily\n\tif (timeout != null) clearTimeout(timeout);\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\t// Return the evaluated result\n\treturn result;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a ConditionalExpression\n */\nexport function evaluateConditionalExpression({node, evaluate, ...options}: EvaluatorOptions<TS.ConditionalExpression>): Literal {\n\tconst {getCurrentError} = options;\n\tconst conditionValue = evaluate.expression(node.condition, options);\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\t// We have to perform a loose boolean expression here to conform with actual spec behavior\n\t// eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\tif (conditionValue) {\n\t\t// Proceed with the truthy branch\n\t\treturn evaluate.expression(node.whenTrue, options);\n\t}\n\n\t// Proceed with the falsy branch\n\treturn evaluate.expression(node.whenFalse, options);\n}\n","import {hasModifier} from \"../modifier/has-modifier.js\";\nimport type {TS} from \"../../../type/ts.js\";\n\n/**\n * Returns true if the given Node exists within a static context\n */\nexport function inStaticContext(node: TS.Node, typescript: typeof TS): boolean {\n\tlet currentNode = node;\n\twhile (currentNode != null && !typescript.isSourceFile(currentNode)) {\n\t\tif (hasModifier(currentNode, typescript.SyntaxKind.StaticKeyword)) return true;\n\t\tcurrentNode = currentNode.parent;\n\t}\n\treturn false;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type { LexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {getFromLexicalEnvironment, pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment.js\";\nimport type {IndexLiteral, IndexLiteralKey, Literal} from \"../literal/literal.js\";\nimport {evaluateParameterDeclarations} from \"./evaluate-parameter-declarations.js\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol.js\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol.js\";\nimport {SUPER_SYMBOL} from \"../util/super/super-symbol.js\";\nimport {inStaticContext} from \"../util/static/in-static-context.js\";\nimport {hasModifier} from \"../util/modifier/has-modifier.js\";\nimport type {TS} from \"../../type/ts.js\";\nimport {canHaveDecorators, getDecorators} from \"../util/node/modifier-util.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a MethodDeclaration, before setting it on the given parent\n */\nexport function evaluateMethodDeclaration(options: EvaluatorOptions<TS.MethodDeclaration>, parent?: IndexLiteral): void {\n\tconst {node, environment, evaluate, stack, typescript, getCurrentError} = options;\n\tconst nameResult = evaluate.nodeWithValue(node.name, options) as IndexLiteralKey;\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\tconst isStatic = inStaticContext(node, typescript);\n\n\tif (parent == null) {\n\t\tlet updatedParent: CallableFunction & IndexLiteral;\n\t\tif (typescript.isClassLike(node.parent)) {\n\t\t\tevaluate.declaration(node.parent, options);\n\n\t\t\tif (getCurrentError() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdatedParent = stack.pop() as CallableFunction & IndexLiteral;\n\t\t} else {\n\t\t\tupdatedParent = evaluate.expression(node.parent, options) as CallableFunction & IndexLiteral;\n\n\t\t\tif (getCurrentError() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tstack.push(isStatic ? updatedParent[nameResult] : updatedParent.prototype[nameResult]);\n\t\treturn;\n\t}\n\n\tconst _methodDeclaration = hasModifier(node, typescript.SyntaxKind.AsyncKeyword)\n\t\t? async function methodDeclaration(this: Literal, ...args: Literal[]) {\n\t\t\t\t// Prepare a lexical environment for the function context\n\t\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment, node);\n\t\t\t\tconst nextOptions = {...options, environment: localLexicalEnvironment};\n\n\t\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: RETURN_SYMBOL, value: false, newBinding: true});\n\n\t\t\t\t// Define a new binding for the arguments given to the function\n\t\t\t\t// eslint-disable-next-line prefer-rest-params\n\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: \"arguments\", value: arguments, newBinding: true});\n\n\t\t\t\tif (this != null) {\n\t\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: THIS_SYMBOL, value: this, newBinding: true});\n\n\t\t\t\t\t// Set the 'super' binding, depending on whether or not we're inside a static context\n\t\t\t\t\tsetInLexicalEnvironment({\n\t\t\t\t\t\t...nextOptions,\n\t\t\t\t\t\tpath: SUPER_SYMBOL,\n\t\t\t\t\t\tvalue: isStatic ? Object.getPrototypeOf(this) : Object.getPrototypeOf((this as CallableFunction).constructor).prototype,\n\t\t\t\t\t\tnewBinding: true\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\t\tevaluateParameterDeclarations(\n\t\t\t\t\t{\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\t\tenvironment: localLexicalEnvironment\n\t\t\t\t\t},\n\t\t\t\t\targs\n\t\t\t\t);\n\n\t\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\t\tif (node.body == null || getCurrentError() != null) return;\n\t\t\t\tevaluate.statement(node.body, nextOptions);\n\n\t\t\t\tif (getCurrentError() != null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\t\treturn stack.pop();\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\t\telse return undefined;\n\t\t  }\n\t\t: function methodDeclaration(this: Literal, ...args: Literal[]) {\n\t\t\t\t// Prepare a lexical environment for the function context\n\t\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment, node);\n\t\t\t\tconst nextOptions = {...options, environment: localLexicalEnvironment};\n\n\t\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: RETURN_SYMBOL, value: false, newBinding: true});\n\n\t\t\t\t// Define a new binding for the arguments given to the function\n\t\t\t\t// eslint-disable-next-line prefer-rest-params\n\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: \"arguments\", value: arguments, newBinding: true});\n\n\t\t\t\tif (this != null) {\n\t\t\t\t\tsetInLexicalEnvironment({...nextOptions, path: THIS_SYMBOL, value: this, newBinding: true});\n\n\t\t\t\t\t// Set the 'super' binding, depending on whether or not we're inside a static context\n\t\t\t\t\tsetInLexicalEnvironment({\n\t\t\t\t\t\t...nextOptions,\n\t\t\t\t\t\tpath: SUPER_SYMBOL,\n\t\t\t\t\t\tvalue: isStatic ? Object.getPrototypeOf(this) : Object.getPrototypeOf((this as CallableFunction).constructor).prototype,\n\t\t\t\t\t\tnewBinding: true\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\t\tevaluateParameterDeclarations(\n\t\t\t\t\t{\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\t\tenvironment: localLexicalEnvironment\n\t\t\t\t\t},\n\t\t\t\t\targs\n\t\t\t\t);\n\n\t\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\t\tif (node.body == null || getCurrentError() != null) return;\n\t\t\t\tevaluate.statement(node.body, nextOptions);\n\n\t\t\t\tif (getCurrentError() != null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\t\treturn stack.pop();\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\t\telse return undefined;\n\t\t  };\n\n\t_methodDeclaration.toString = () => `[Method: ${nameResult}]`;\n\n\t// Make sure to use the Function that is contained within the Realm. Otherwise, 'instanceof' checks may fail\n\t// since this particular function comes from the executing context.\n\tObject.setPrototypeOf(_methodDeclaration, getFromLexicalEnvironment(node, environment, \"Function\")!.literal as CallableFunction);\n\n\tparent[nameResult] = _methodDeclaration;\n\n\tif (canHaveDecorators(node, typescript)) {\n\t\tfor (const decorator of getDecorators(node, typescript) ?? []) {\n\t\t\tevaluate.nodeWithArgument(decorator, [parent, nameResult], options);\n\n\t\t\tif (getCurrentError() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Pop the stack. We don't need the value it has left on the Stack\n\t\t\tstack.pop();\n\t\t}\n\t}\n\n\t// Also loop through parameters to use their decorators, if any\n\tif (node.parameters != null) {\n\t\t// 'this' is a special parameter which is removed from the emitted results\n\t\tconst parameters = node.parameters.filter(param => !(typescript.isIdentifier(param.name) && param.name.text === \"this\"));\n\t\tfor (let i = 0; i < parameters.length; i++) {\n\t\t\tconst parameter = parameters[i];\n\n\t\t\tif (canHaveDecorators(parameter, typescript)) {\n\t\t\t\tfor (const decorator of getDecorators(parameter, typescript) ?? []) {\n\t\t\t\t\tevaluate.nodeWithArgument(decorator, [parent, nameResult, i], options);\n\n\t\t\t\t\tif (getCurrentError() != null) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Pop the stack. We don't need the value it has left on the Stack\n\t\t\t\t\tstack.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {IndexLiteral, IndexLiteralKey} from \"../literal/literal.js\";\nimport {inStaticContext} from \"../util/static/in-static-context.js\";\nimport type {TS} from \"../../type/ts.js\";\nimport { canHaveDecorators, getDecorators } from \"../util/node/modifier-util.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a PropertyDeclaration, before applying it on the given parent\n */\nexport function evaluatePropertyDeclaration({node, evaluate, typescript, stack, ...options}: EvaluatorOptions<TS.PropertyDeclaration>, parent?: IndexLiteral): void {\n\tconst {getCurrentError} = options;\n\n\t// Compute the property name\n\tconst propertyNameResult = evaluate.nodeWithValue(node.name, options) as IndexLiteralKey;\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\tif (parent == null) {\n\t\tevaluate.declaration(node.parent, options);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst updatedParent = stack.pop() as CallableFunction & IndexLiteral;\n\t\tconst isStatic = inStaticContext(node, typescript);\n\t\tstack.push(isStatic ? updatedParent[propertyNameResult] : updatedParent.prototype[propertyNameResult]);\n\t\treturn;\n\t}\n\n\tparent[propertyNameResult] = node.initializer == null ? undefined : evaluate.expression(node.initializer, options);\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\tif (canHaveDecorators(node, typescript)) {\n\t\tfor (const decorator of getDecorators(node, typescript) ?? []) {\n\t\t\tevaluate.nodeWithArgument(decorator, [parent, propertyNameResult], options);\n\n\t\t\tif (getCurrentError() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Pop the stack. We don't need the value it has left on the Stack\n\t\t\tstack.pop();\n\t\t}\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {LexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport { pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment.js\";\nimport type {IndexLiteral, IndexLiteralKey, Literal} from \"../literal/literal.js\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol.js\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol.js\";\nimport {SUPER_SYMBOL} from \"../util/super/super-symbol.js\";\nimport {inStaticContext} from \"../util/static/in-static-context.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a GetAccessorDeclaration, before setting it on the given parent\n */\nexport function evaluateGetAccessorDeclaration(options: EvaluatorOptions<TS.GetAccessorDeclaration>, parent?: IndexLiteral): void {\n\tconst {node, environment, evaluate, stack, typescript, getCurrentError} = options;\n\t// We might be attempting to evaluate GetAccessorDeclaration that is placed within an ambient\n\t// context such as an InterfaceDeclaration, in which case there's nothing to evaluate\n\tif (typescript.isTypeLiteralNode(node.parent) || typescript.isInterfaceDeclaration(node.parent)) {\n\t\treturn;\n\t}\n\n\tconst nameResult = evaluate.nodeWithValue(node.name, options) as IndexLiteralKey;\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\tconst isStatic = inStaticContext(node, typescript);\n\n\tif (parent == null) {\n\t\tlet updatedParent: CallableFunction & IndexLiteral;\n\t\tif (typescript.isClassLike(node.parent)) {\n\t\t\tevaluate.declaration(node.parent, options);\n\n\t\t\tif (getCurrentError() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdatedParent = stack.pop() as CallableFunction & IndexLiteral;\n\t\t} else {\n\t\t\tupdatedParent = evaluate.expression(node.parent, options) as CallableFunction & IndexLiteral;\n\n\t\t\tif (getCurrentError() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tstack.push(isStatic ? updatedParent[nameResult] : updatedParent.prototype[nameResult]);\n\t\treturn;\n\t}\n\n\t/**\n\t * An implementation of the get accessor\n\t */\n\tfunction getAccessorDeclaration(this: Literal) {\n\t\t// Prepare a lexical environment for the function context\n\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment, node);\n\t\tconst nextOptions = {...options, environment: localLexicalEnvironment};\n\n\t\t// Define a new binding for a return symbol within the environment\n\t\tsetInLexicalEnvironment({...nextOptions, path: RETURN_SYMBOL, value: false, newBinding: true});\n\n\t\t// Define a new binding for the arguments given to the function\n\t\t// eslint-disable-next-line prefer-rest-params\n\t\tsetInLexicalEnvironment({...nextOptions, path: \"arguments\", value: arguments, newBinding: true});\n\n\t\tif (this != null) {\n\t\t\tsetInLexicalEnvironment({...nextOptions, path: THIS_SYMBOL, value: this, newBinding: true});\n\n\t\t\t// Set the 'super' binding, depending on whether or not we're inside a static context\n\t\t\tsetInLexicalEnvironment({\n\t\t\t\t...nextOptions,\n\t\t\t\tpath: SUPER_SYMBOL,\n\t\t\t\tvalue: isStatic ? Object.getPrototypeOf(this) : Object.getPrototypeOf((this as CallableFunction).constructor).prototype,\n\t\t\t\tnewBinding: true\n\t\t\t});\n\t\t}\n\n\t\t// If the body is a block, evaluate it as a statement\n\t\tif (node.body == null) return;\n\t\tevaluate.statement(node.body, nextOptions);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\treturn stack.pop();\n\t\t}\n\n\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\telse return undefined;\n\t}\n\n\tgetAccessorDeclaration.toString = () => `[Get: ${nameResult}]`;\n\n\tlet currentPropertyDescriptor = Object.getOwnPropertyDescriptor(parent, nameResult);\n\tif (currentPropertyDescriptor == null) currentPropertyDescriptor = {};\n\n\tObject.defineProperty(parent, nameResult, {\n\t\t...currentPropertyDescriptor,\n\t\tconfigurable: true,\n\t\tget: getAccessorDeclaration\n\t});\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a TypeAliasDeclaration\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function evaluateTypeAliasDeclaration(_options: EvaluatorOptions<TS.TypeAliasDeclaration>): void {\n\treturn;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a TypeAliasDeclaration\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function evaluateInterfaceDeclaration(_options: EvaluatorOptions<TS.InterfaceDeclaration>): void {\n\treturn;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, an ImportClause.\n * It will only initialize the bindings inside the lexical environment, but not resolve them, since we rely on the TypeChecker to resolve symbols across SourceFiles,\n * rather than manually parsing and resolving imports/exports\n */\nexport function evaluateImportClause({node, evaluate, ...options}: EvaluatorOptions<TS.ImportClause>): void {\n\tconst {getCurrentError} = options;\n\tif (node.name != null) {\n\t\tevaluate.declaration(node.name, options);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (node.namedBindings != null) {\n\t\tif (\"elements\" in node.namedBindings) {\n\t\t\tfor (const importSpecifier of node.namedBindings.elements) {\n\t\t\t\tevaluate.declaration(importSpecifier, options);\n\n\t\t\t\tif (getCurrentError() != null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tevaluate.declaration(node.namedBindings.name, options);\n\t\t}\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, an ImportSpecifier.\n * It will only initialize the bindings inside the lexical environment, but not resolve them, since we rely on the TypeChecker to resolve symbols across SourceFiles,\n * rather than manually parsing and resolving imports/exports\n */\nexport function evaluateImportSpecifier({node, evaluate, ...options}: EvaluatorOptions<TS.ImportSpecifier>): void {\n\tevaluate.declaration(node.propertyName ?? node.name, options);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a NamespaceImport.\n * It will only initialize the bindings inside the lexical environment, but not resolve them, since we rely on the TypeChecker to resolve symbols across SourceFiles,\n * rather than manually parsing and resolving imports/exports\n */\nexport function evaluateNamespaceImport({node, evaluate, ...options}: EvaluatorOptions<TS.NamespaceImport>): void {\n\tevaluate.declaration(node.name, options);\n}\n","import {EvaluationError} from \"../evaluation-error/evaluation-error.js\";\nimport type {IUnexpectedSyntaxErrorOptions} from \"./i-unexpected-syntax-error-options.js\";\n\n/**\n * An Error that can be thrown when a certain usage is to be considered a SyntaxError\n */\nexport class UnexpectedSyntaxError extends EvaluationError {\n\tconstructor({node, environment, message = `'SyntaxError'`}: IUnexpectedSyntaxErrorOptions) {\n\t\tsuper({message, environment, node});\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {TS} from \"../../type/ts.js\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport {UnexpectedSyntaxError} from \"../error/unexpected-syntax-error/unexpected-syntax-error.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a MetaProperty.\n */\nexport function evaluateMetaProperty({node, typescript, throwError, environment}: EvaluatorOptions<TS.MetaProperty>): Literal | void {\n\tswitch (node.keywordToken) {\n\t\tcase typescript.SyntaxKind.NewKeyword: {\n\t\t\tswitch (node.name.text) {\n\t\t\t\tcase \"target\":\n\t\t\t\t\treturn getFromLexicalEnvironment(node, environment, \"[[NewTarget]]\")?.literal;\n\t\t\t\tdefault:\n\t\t\t\t\treturn throwError(new UnexpectedSyntaxError({node: node.name, environment}));\n\t\t\t}\n\t\t}\n\n\t\tcase typescript.SyntaxKind.ImportKeyword: {\n\t\t\tswitch (node.name.text) {\n\t\t\t\tcase \"meta\":\n\t\t\t\t\treturn getFromLexicalEnvironment(node, environment, \"import.meta\")?.literal;\n\t\t\t\tdefault:\n\t\t\t\t\treturn throwError(new UnexpectedSyntaxError({node: node.name, environment}));\n\t\t\t}\n\t\t}\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {evaluateVariableDeclaration} from \"./evaluate-variable-declaration.js\";\nimport {evaluateBinaryExpression} from \"./evaluate-binary-expression.js\";\nimport {evaluateCallExpression} from \"./evaluate-call-expression.js\";\nimport {evaluateParenthesizedExpression} from \"./evaluate-parenthesized-expression.js\";\nimport {evaluateArrowFunctionExpression} from \"./evaluate-arrow-function-expression.js\";\nimport {evaluateStringLiteral} from \"./evaluate-string-literal.js\";\nimport {evaluateNumericLiteral} from \"./evaluate-numeric-literal.js\";\nimport {evaluateBooleanLiteral} from \"./evaluate-boolean-literal.js\";\nimport {evaluateRegularExpressionLiteral} from \"./evaluate-regular-expression-literal.js\";\nimport {evaluateObjectLiteralExpression} from \"./evaluate-object-literal-expression.js\";\nimport {evaluateArrayLiteralExpression} from \"./evaluate-array-literal-expression.js\";\nimport {evaluateIdentifier} from \"./evaluate-identifier.js\";\nimport {evaluateBlock} from \"./evaluate-block.js\";\nimport {evaluateReturnStatement} from \"./evaluate-return-statement.js\";\nimport {evaluateVariableStatement} from \"./evaluate-variable-statement.js\";\nimport {evaluateVariableDeclarationList} from \"./evaluate-variable-declaration-list.js\";\nimport {evaluatePrefixUnaryExpression} from \"./evaluate-prefix-unary-expression.js\";\nimport {evaluatePropertyAccessExpression} from \"./evaluate-property-access-expression.js\";\nimport {evaluateElementAccessExpression} from \"./evaluate-element-access-expression.js\";\nimport {evaluateComputedPropertyName} from \"./evaluate-computed-property-name.js\";\nimport {evaluateFunctionDeclaration} from \"./evaluate-function-declaration.js\";\nimport {evaluateIfStatement} from \"./evaluate-if-statement.js\";\nimport {evaluateExpressionStatement} from \"./evaluate-expression-statement.js\";\nimport {evaluateTemplateExpression} from \"./evaluate-template-expression.js\";\nimport {evaluateTypeAssertion} from \"./evaluate-type-assertion-expression.js\";\nimport {evaluatePostfixUnaryExpression} from \"./evaluate-postfix-unary-expression.js\";\nimport {evaluateNewExpression} from \"./evaluate-new-expression.js\";\nimport {evaluateNonNullExpression} from \"./evaluate-non-null-expression.js\";\nimport {evaluateAsExpression} from \"./evaluate-as-expression.js\";\nimport {evaluateSwitchStatement} from \"./evaluate-switch-statement.js\";\nimport {evaluateForOfStatement} from \"./evaluate-for-of-statement.js\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error.js\";\nimport {isBooleanLiteral} from \"../util/node/is-boolean-literal.js\";\nimport {isThisExpression} from \"../util/node/is-this-expression.js\";\nimport {evaluateThisExpression} from \"./evaluate-this-expression.js\";\nimport {evaluateBreakStatement} from \"./evaluate-break-statement.js\";\nimport {evaluateContinueStatement} from \"./evaluate-continue-statement.js\";\nimport {evaluateForStatement} from \"./evaluate-for-statement.js\";\nimport {evaluateWhileStatement} from \"./evaluate-while-statement.js\";\nimport {evaluateForInStatement} from \"./evaluate-for-in-statement.js\";\nimport {evaluateFunctionExpression} from \"./evaluate-function-expression.js\";\nimport {evaluateTryStatement} from \"./evaluate-try-statement.js\";\nimport {evaluateClassDeclaration} from \"./evaluate-class-declaration.js\";\nimport {evaluateConstructorDeclaration} from \"./evaluate-constructor-declaration.js\";\nimport {isSuperExpression} from \"../util/node/is-super-expression.js\";\nimport {evaluateSuperExpression} from \"./evaluate-super-expression.js\";\nimport {evaluateSpreadElement} from \"./evaluate-spread-element.js\";\nimport {evaluateClassExpression} from \"./evaluate-class-expression.js\";\nimport {isNullLiteral} from \"../util/node/is-null-literal.js\";\nimport {evaluateNullLiteral} from \"./evaluate-null-literal.js\";\nimport {evaluateVoidExpression} from \"./evaluate-void-expression.js\";\nimport {evaluateTypeOfExpression} from \"./evaluate-type-of-expression.js\";\nimport {evaluateBigIntLiteral} from \"./evaluate-big-int-literal.js\";\nimport {evaluateEnumDeclaration} from \"./evaluate-enum-declaration.js\";\nimport {evaluateSourceFileAsNamespaceObject} from \"./evaluate-source-file-as-namespace-object.js\";\nimport {evaluateModuleDeclaration} from \"./evaluate-module-declaration.js\";\nimport {evaluateImportDeclaration} from \"./evaluate-import-declaration.js\";\nimport {evaluateThrowStatement} from \"./evaluate-throw-statement.js\";\nimport {evaluateImportEqualsDeclaration} from \"./evaluate-import-equals-declaration.js\";\nimport {evaluateAwaitExpression} from \"./evaluate-await-expression.js\";\nimport {evaluateConditionalExpression} from \"./evaluate-conditional-expression.js\";\nimport {evaluateMethodDeclaration} from \"./evaluate-method-declaration.js\";\nimport {evaluatePropertyDeclaration} from \"./evaluate-property-declaration.js\";\nimport {evaluateGetAccessorDeclaration} from \"./evaluate-get-accessor-declaration.js\";\nimport type {TS} from \"../../type/ts.js\";\nimport {evaluateTypeAliasDeclaration} from \"./evaluate-type-alias-declaration.js\";\nimport {evaluateInterfaceDeclaration} from \"./evaluate-interface-declaration.js\";\nimport {evaluateImportClause} from \"./evaluate-import-clause.js\";\nimport {evaluateImportSpecifier} from \"./evaluate-import-specifier.js\";\nimport {evaluateNamespaceImport} from \"./evaluate-namespace-import.js\";\nimport {evaluateMetaProperty} from \"./evaluate-meta-property.js\";\n\n/**\n * Will get a literal value for the given Node. If it doesn't succeed, the value will be 'undefined'\n */\nexport function evaluateNode({node, ...rest}: EvaluatorOptions<TS.Node>): unknown {\n\tif (rest.typescript.isIdentifier(node)) {\n\t\treturn evaluateIdentifier({node, ...rest});\n\t} else if (rest.typescript.isPrivateIdentifier?.(node)) {\n\t\treturn evaluateIdentifier({node, ...rest});\n\t} else if (rest.typescript.isStringLiteralLike(node)) {\n\t\treturn evaluateStringLiteral({node, ...rest});\n\t} else if (rest.typescript.isNumericLiteral(node)) {\n\t\treturn evaluateNumericLiteral({node, ...rest});\n\t} else if (isBooleanLiteral(node, rest.typescript)) {\n\t\treturn evaluateBooleanLiteral({node, ...rest});\n\t} else if (rest.typescript.isForOfStatement(node)) {\n\t\treturn evaluateForOfStatement({node, ...rest});\n\t} else if (rest.typescript.isForInStatement(node)) {\n\t\treturn evaluateForInStatement({node, ...rest});\n\t} else if (rest.typescript.isForStatement(node)) {\n\t\treturn evaluateForStatement({node, ...rest});\n\t} else if (rest.typescript.isWhileStatement(node)) {\n\t\treturn evaluateWhileStatement({node, ...rest});\n\t} else if (rest.typescript.isRegularExpressionLiteral(node)) {\n\t\treturn evaluateRegularExpressionLiteral({node, ...rest});\n\t} else if (rest.typescript.isObjectLiteralExpression(node)) {\n\t\treturn evaluateObjectLiteralExpression({node, ...rest});\n\t} else if (rest.typescript.isAwaitExpression(node)) {\n\t\treturn evaluateAwaitExpression({node, ...rest});\n\t} else if (\n\t\trest.typescript.isTypeAssertionExpression?.(node) ||\n\t\t(!(\"isTypeAssertionExpression\" in rest.typescript) && (rest.typescript as {isTypeAssertion: typeof TS.isTypeAssertionExpression}).isTypeAssertion(node))\n\t) {\n\t\treturn evaluateTypeAssertion({node, ...rest});\n\t} else if (rest.typescript.isTemplateExpression(node)) {\n\t\treturn evaluateTemplateExpression({node, ...rest});\n\t} else if (rest.typescript.isMethodDeclaration(node)) {\n\t\treturn evaluateMethodDeclaration({node, ...rest});\n\t} else if (rest.typescript.isPropertyDeclaration(node)) {\n\t\treturn evaluatePropertyDeclaration({node, ...rest});\n\t} else if (rest.typescript.isGetAccessorDeclaration(node)) {\n\t\treturn evaluateGetAccessorDeclaration({node, ...rest});\n\t} else if (rest.typescript.isArrayLiteralExpression(node)) {\n\t\treturn evaluateArrayLiteralExpression({node, ...rest});\n\t} else if (rest.typescript.isSourceFile(node)) {\n\t\treturn evaluateSourceFileAsNamespaceObject({node, ...rest});\n\t} else if (rest.typescript.isModuleDeclaration(node)) {\n\t\treturn evaluateModuleDeclaration({node, ...rest});\n\t} else if (rest.typescript.isPrefixUnaryExpression(node)) {\n\t\treturn evaluatePrefixUnaryExpression({node, ...rest});\n\t} else if (rest.typescript.isPostfixUnaryExpression(node)) {\n\t\treturn evaluatePostfixUnaryExpression({node, ...rest});\n\t} else if (rest.typescript.isVariableStatement(node)) {\n\t\treturn evaluateVariableStatement({node, ...rest});\n\t} else if (rest.typescript.isComputedPropertyName(node)) {\n\t\treturn evaluateComputedPropertyName({node, ...rest});\n\t} else if (rest.typescript.isVariableDeclarationList(node)) {\n\t\treturn evaluateVariableDeclarationList({node, ...rest});\n\t} else if (rest.typescript.isImportDeclaration(node)) {\n\t\treturn evaluateImportDeclaration({node, ...rest});\n\t} else if (rest.typescript.isImportClause(node)) {\n\t\treturn evaluateImportClause({node, ...rest});\n\t} else if (rest.typescript.isImportSpecifier(node)) {\n\t\treturn evaluateImportSpecifier({node, ...rest});\n\t} else if (rest.typescript.isNamespaceImport(node)) {\n\t\treturn evaluateNamespaceImport({node, ...rest});\n\t} else if (rest.typescript.isImportEqualsDeclaration(node)) {\n\t\treturn evaluateImportEqualsDeclaration({node, ...rest});\n\t} else if (rest.typescript.isMetaProperty(node)) {\n\t\treturn evaluateMetaProperty({node, ...rest});\n\t} else if (rest.typescript.isThrowStatement(node)) {\n\t\treturn evaluateThrowStatement({node, ...rest});\n\t} else if (rest.typescript.isVariableDeclaration(node)) {\n\t\treturn evaluateVariableDeclaration({node, ...rest});\n\t} else if (rest.typescript.isEnumDeclaration(node)) {\n\t\treturn evaluateEnumDeclaration({node, ...rest});\n\t} else if (rest.typescript.isConstructorDeclaration(node)) {\n\t\treturn evaluateConstructorDeclaration({node, ...rest});\n\t} else if (rest.typescript.isBinaryExpression(node)) {\n\t\treturn evaluateBinaryExpression({node, ...rest});\n\t} else if (rest.typescript.isParenthesizedExpression(node)) {\n\t\treturn evaluateParenthesizedExpression({node, ...rest});\n\t} else if (rest.typescript.isExpressionStatement(node)) {\n\t\treturn evaluateExpressionStatement({node, ...rest});\n\t} else if (rest.typescript.isArrowFunction(node)) {\n\t\treturn evaluateArrowFunctionExpression({node, ...rest});\n\t} else if (rest.typescript.isFunctionDeclaration(node)) {\n\t\treturn evaluateFunctionDeclaration({node, ...rest});\n\t} else if (rest.typescript.isFunctionExpression(node)) {\n\t\treturn evaluateFunctionExpression({node, ...rest});\n\t} else if (rest.typescript.isClassDeclaration(node)) {\n\t\treturn evaluateClassDeclaration({node, ...rest});\n\t} else if (rest.typescript.isIfStatement(node)) {\n\t\treturn evaluateIfStatement({node, ...rest});\n\t} else if (rest.typescript.isConditionalExpression(node)) {\n\t\treturn evaluateConditionalExpression({node, ...rest});\n\t} else if (rest.typescript.isPropertyAccessExpression(node)) {\n\t\treturn evaluatePropertyAccessExpression({node, ...rest});\n\t} else if (rest.typescript.isElementAccessExpression(node)) {\n\t\treturn evaluateElementAccessExpression({node, ...rest});\n\t} else if (rest.typescript.isCallExpression(node)) {\n\t\treturn evaluateCallExpression({node, ...rest});\n\t} else if (rest.typescript.isSwitchStatement(node)) {\n\t\treturn evaluateSwitchStatement({node, ...rest});\n\t} else if (rest.typescript.isNewExpression(node)) {\n\t\treturn evaluateNewExpression({node, ...rest});\n\t} else if (rest.typescript.isNonNullExpression(node)) {\n\t\treturn evaluateNonNullExpression({node, ...rest});\n\t} else if (rest.typescript.isAsExpression(node)) {\n\t\treturn evaluateAsExpression({node, ...rest});\n\t} else if (rest.typescript.isBlock(node)) {\n\t\treturn evaluateBlock({node, ...rest});\n\t} else if (rest.typescript.isClassExpression(node)) {\n\t\treturn evaluateClassExpression({node, ...rest});\n\t} else if (rest.typescript.isSpreadElement(node)) {\n\t\treturn evaluateSpreadElement({node, ...rest});\n\t} else if (rest.typescript.isTryStatement(node)) {\n\t\treturn evaluateTryStatement({node, ...rest});\n\t} else if (rest.typescript.isReturnStatement(node)) {\n\t\treturn evaluateReturnStatement({node, ...rest});\n\t} else if (isThisExpression(node, rest.typescript)) {\n\t\treturn evaluateThisExpression({node, ...rest});\n\t} else if (rest.typescript.isVoidExpression(node)) {\n\t\treturn evaluateVoidExpression({node, ...rest});\n\t} else if (rest.typescript.isTypeOfExpression(node)) {\n\t\treturn evaluateTypeOfExpression({node, ...rest});\n\t} else if (isSuperExpression(node, rest.typescript)) {\n\t\treturn evaluateSuperExpression({node, ...rest});\n\t} else if (isNullLiteral(node, rest.typescript)) {\n\t\treturn evaluateNullLiteral({node, ...rest});\n\t} else if (rest.typescript.isBigIntLiteral?.(node)) {\n\t\treturn evaluateBigIntLiteral({node, ...rest});\n\t} else if (rest.typescript.isBreakStatement(node)) {\n\t\treturn evaluateBreakStatement({node, ...rest});\n\t} else if (rest.typescript.isContinueStatement(node)) {\n\t\treturn evaluateContinueStatement({node, ...rest});\n\t} else if (rest.typescript.isTypeAliasDeclaration(node)) {\n\t\treturn evaluateTypeAliasDeclaration({node, ...rest});\n\t} else if (rest.typescript.isInterfaceDeclaration(node)) {\n\t\treturn evaluateInterfaceDeclaration({node, ...rest});\n\t} else if (rest.getCurrentError() != null) {\n\t\treturn;\n\t} else {\n\t\treturn rest.throwError(new UnexpectedNodeError({node, environment: rest.environment, typescript: rest.typescript}));\n\t}\n}\n","import type {TS} from \"../../../type/ts.js\";\n\nexport type StatementTraversalStack = TS.SyntaxKind[];\n\n/**\n * Creates a StatementTraversalStack\n */\nexport function createStatementTraversalStack(): StatementTraversalStack {\n\treturn [];\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {evaluateNode} from \"./evaluate-node.js\";\nimport {createStatementTraversalStack} from \"../stack/traversal-stack/statement-traversal-stack.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Will get a literal value for the given Statement. If it doesn't succeed, the value will be 'undefined'\n */\nexport function evaluateStatement(options: EvaluatorOptions<TS.Statement>): void {\n\toptions.logger.logNode(options.node, options.typescript);\n\n\t// Create a new Statement traversal stack (since this is a new statement)\n\toptions.statementTraversalStack = createStatementTraversalStack();\n\n\tevaluateNode(options);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport {evaluateNode} from \"./evaluate-node.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Will get a literal value for the given Expression. If it doesn't succeed, the value will be 'undefined'\n */\nexport function evaluateExpression(options: EvaluatorOptions<TS.Expression | TS.PrivateIdentifier>): Literal {\n\tconst {getCurrentError} = options;\n\toptions.logger.logNode(options.node, options.typescript);\n\tconst value = evaluateNode(options) as Promise<Literal>;\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\t// Report intermediate results\n\tif (options.reporting.reportIntermediateResults != null) {\n\t\toptions.reporting.reportIntermediateResults({\n\t\t\tnode: options.node,\n\t\t\tvalue\n\t\t});\n\t}\n\n\treturn value;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {evaluateNode} from \"./evaluate-node.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Will get a literal value for the given Declaration. If it doesn't succeed, the value will be 'undefined'\n */\nexport function evaluateDeclaration(options: EvaluatorOptions<TS.Declaration>): void {\n\toptions.logger.logNode(options.node, options.typescript);\n\n\tevaluateNode(options);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a BindingName, based on an initializer\n */\nexport function evaluateBindingName({node, evaluate, typescript, logger, ...options}: EvaluatorOptions<TS.BindingName>, rightHandValue: Literal): void {\n\t// If the declaration binds a simple identifier, bind that text to the environment\n\tif (typescript.isIdentifier(node) || typescript.isPrivateIdentifier?.(node)) {\n\t\tsetInLexicalEnvironment({...options, node, path: node.text, value: rightHandValue, newBinding: true});\n\t\tlogger.logBinding(node.text, rightHandValue, \"evaluateBindingName\");\n\t} else {\n\t\tevaluate.nodeWithArgument(node, rightHandValue, options);\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {LexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport { setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment.js\";\nimport type {IndexLiteral, IndexLiteralKey, Literal} from \"../literal/literal.js\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol.js\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol.js\";\nimport {inStaticContext} from \"../util/static/in-static-context.js\";\nimport {SUPER_SYMBOL} from \"../util/super/super-symbol.js\";\nimport {evaluateParameterDeclarations} from \"./evaluate-parameter-declarations.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a SetAccessorDeclaration, before setting it on the given parent\n */\nexport function evaluateSetAccessorDeclaration(options: EvaluatorOptions<TS.SetAccessorDeclaration>, parent: IndexLiteral): void {\n\tconst {node, environment, evaluate, typescript, getCurrentError} = options;\n\n\tconst nameResult = evaluate.nodeWithValue(node.name, options) as IndexLiteralKey;\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\tconst isStatic = inStaticContext(node, typescript);\n\n\t/**\n\t * An implementation of the set accessor\n\t */\n\tfunction setAccessorDeclaration(this: Literal, ...args: Literal[]) {\n\t\t// Prepare a lexical environment for the function context\n\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment, node);\n\t\tconst nextOptions = {...options, environment: localLexicalEnvironment};\n\n\t\t// Define a new binding for a return symbol within the environment\n\t\tsetInLexicalEnvironment({...nextOptions, path: RETURN_SYMBOL, value: false, newBinding: true});\n\n\t\t// Define a new binding for the arguments given to the function\n\t\t// eslint-disable-next-line prefer-rest-params\n\t\tsetInLexicalEnvironment({...nextOptions, path: \"arguments\", value: arguments, newBinding: true});\n\n\t\tif (this != null) {\n\t\t\tsetInLexicalEnvironment({...nextOptions, path: THIS_SYMBOL, value: this, newBinding: true});\n\n\t\t\t// Set the 'super' binding, depending on whether or not we're inside a static context\n\t\t\tsetInLexicalEnvironment({\n\t\t\t\t...nextOptions,\n\t\t\t\tpath: SUPER_SYMBOL,\n\t\t\t\tvalue: isStatic ? Object.getPrototypeOf(this) : Object.getPrototypeOf((this as CallableFunction).constructor).prototype,\n\t\t\t\tnewBinding: true\n\t\t\t});\n\t\t}\n\n\t\t// Evaluate the parameters based on the given arguments\n\t\tevaluateParameterDeclarations(\n\t\t\t{\n\t\t\t\t...nextOptions,\n\t\t\t\tnode: node.parameters\n\t\t\t},\n\t\t\targs\n\t\t);\n\n\t\t// If the body is a block, evaluate it as a statement\n\t\tif (node.body == null || getCurrentError() != null) return;\n\t\tevaluate.statement(node.body, nextOptions);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tsetAccessorDeclaration.toString = () => `[Set: ${nameResult}]`;\n\n\tlet currentPropertyDescriptor = Object.getOwnPropertyDescriptor(parent, nameResult);\n\tif (currentPropertyDescriptor == null) currentPropertyDescriptor = {};\n\n\tObject.defineProperty(parent, nameResult, {\n\t\t...currentPropertyDescriptor,\n\t\tconfigurable: true,\n\t\tset: setAccessorDeclaration\n\t});\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {IndexLiteral, IndexLiteralKey} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a PropertyAssignment, before applying it on the given parent\n */\nexport function evaluatePropertyAssignment({node, evaluate, ...options}: EvaluatorOptions<TS.PropertyAssignment>, parent: IndexLiteral): void {\n\tconst initializer = evaluate.expression(node.initializer, options);\n\n\tif (options.getCurrentError() != null) {\n\t\treturn;\n\t}\n\t// Compute the property name\n\tconst propertyNameResult = evaluate.nodeWithValue(node.name, options) as IndexLiteralKey;\n\n\tif (options.getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\tparent[propertyNameResult] = initializer;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a ParameterDeclaration\n */\nexport function evaluateParameterDeclaration({node, evaluate, logger, ...options}: EvaluatorOptions<TS.ParameterDeclaration>, boundArgument: Literal): void {\n\t// Use the bound argument if it is given unless it is nullable and the node itself has an initializer\n\tconst boundValue = boundArgument != null || node.initializer === undefined ? boundArgument : evaluate.expression(node.initializer, options);\n\n\tif (options.getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\tlogger.logBinding(node.name.getText(), boundValue, \"evaluateParameterDeclaration\");\n\tevaluate.nodeWithArgument(node.name, boundValue, options);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {IndexLiteral} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a ShorthandPropertyAssignment, before applying it on the given parent\n */\nexport function evaluateShorthandPropertyAssignment({node, evaluate, ...options}: EvaluatorOptions<TS.ShorthandPropertyAssignment>, parent: IndexLiteral): void {\n\tconst {getCurrentError} = options;\n\tconst identifier = node.name.text;\n\tconst initializer = evaluate.expression(node.name, options);\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\tparent[identifier] = initializer;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {IndexLiteral} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a SpreadAssignment, before applying it on the given parent\n */\nexport function evaluateSpreadAssignment({node, evaluate, ...options}: EvaluatorOptions<TS.SpreadAssignment>, parent: IndexLiteral): void {\n\tconst entries = evaluate.expression(node.expression, options) as IndexLiteral;\n\t\n\tif (options.getCurrentError() != null) {\n\t\treturn;\n\t}\n\t\n\tObject.assign(parent, entries);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, an ArrayBindingPattern, based on an initializer\n */\nexport function evaluateArrayBindingPattern({node, evaluate, ...options}: EvaluatorOptions<TS.ArrayBindingPattern>, rightHandValue: Iterable<Literal>): void {\n\tconst iterator = rightHandValue[Symbol.iterator]();\n\tlet elementsCursor = 0;\n\n\twhile (elementsCursor < node.elements.length) {\n\t\tconst {done, value} = iterator.next();\n\t\tif (done === true) break;\n\n\t\tevaluate.nodeWithArgument(node.elements[elementsCursor++], value, options);\n\n\t\tif (options.getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {IndexLiteral, IndexLiteralKey, Literal} from \"../literal/literal.js\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a BindingName, based on an BindingElement\n */\nexport function evaluateBindingElement(options: EvaluatorOptions<TS.BindingElement>, rightHandValue: Literal): void {\n\tconst {node, evaluate, logger, typescript, getCurrentError} = options;\n\n\t// Compute the initializer value of the BindingElement, if it has any, that is\n\tconst bindingElementInitializer = node.initializer == null ? undefined : evaluate.expression(node.initializer, options);\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\t// If the element is directly references a property, but then aliases, store that alias in the environment.\n\tif ((typescript.isIdentifier(node.name) || typescript.isPrivateIdentifier?.(node.name)) && node.propertyName != null) {\n\t\t// An element that is aliased cannot have a name that is anything other than an Identifier\n\t\tconst aliasName = node.name.text;\n\n\t\t// Compute the property name\n\t\tconst propertyNameResult = evaluate.nodeWithValue(node.propertyName, options) as IndexLiteralKey;\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Extract the property value from the initializer. If it is an ArrayBindingPattern, the rightHandValue will be assigned as-is to the identifier\n\t\tconst propertyValue = typescript.isArrayBindingPattern(node.parent) ? rightHandValue : (rightHandValue as IndexLiteral)[propertyNameResult];\n\n\t\t// Fall back to using the initializer of the BindingElement if the property value is null-like and if it has one\n\t\tconst propertyValueWithInitializerFallback = propertyValue != null ? propertyValue : bindingElementInitializer;\n\n\t\tsetInLexicalEnvironment({\n\t\t\t...options,\n\t\t\tpath: aliasName,\n\t\t\tvalue: propertyValueWithInitializerFallback,\n\t\t\tnewBinding: true\n\t\t});\n\t}\n\n\t// If the name is a simple non-aliased identifier, it directly references, a property from the right-hand value\n\telse if ((typescript.isIdentifier(node.name) || typescript.isPrivateIdentifier?.(node.name)) && node.propertyName == null) {\n\t\t// Compute the literal value of the name of the node\n\t\tconst nameResult = node.name.text;\n\n\t\t// Extract the property value from the initializer. If it is an ArrayBindingPattern, the rightHandValue will be assigned as-is to the identifier\n\t\tconst propertyValue = typescript.isArrayBindingPattern(node.parent) ? rightHandValue : (rightHandValue as IndexLiteral)[nameResult];\n\n\t\t// Fall back to using the initializer of the BindingElement if the property value is null-like and if it has one\n\t\tconst propertyValueWithInitializerFallback = propertyValue != null ? propertyValue : bindingElementInitializer;\n\n\t\tlogger.logBinding(node.name.text, propertyValueWithInitializerFallback);\n\n\t\tsetInLexicalEnvironment({\n\t\t\t...options,\n\t\t\tpath: node.name.text,\n\t\t\tvalue: propertyValueWithInitializerFallback,\n\t\t\tnewBinding: true\n\t\t});\n\t}\n\n\t// Otherwise, the name is itself a BindingPattern, and the property it is destructuring will always be defined\n\telse if (!typescript.isIdentifier(node.name) && !typescript.isPrivateIdentifier?.(node.name) && node.propertyName != null) {\n\t\t// Compute the property name\n\t\tconst propertyNameResult = evaluate.nodeWithValue(node.propertyName, options) as IndexLiteralKey;\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Extract the property value from the initializer. If it is an ArrayBindingPattern, the rightHandValue will be assigned as-is to the identifier\n\t\tconst propertyValue = typescript.isArrayBindingPattern(node.parent) ? rightHandValue : (rightHandValue as IndexLiteral)[propertyNameResult];\n\n\t\t// Fall back to using the initializer of the BindingElement if the property value is null-like and if it has one\n\t\tconst propertyValueWithInitializerFallback = propertyValue != null ? propertyValue : bindingElementInitializer;\n\n\t\t// Evaluate the BindingPattern based on the narrowed property value\n\t\tevaluate.nodeWithArgument(node.name, propertyValueWithInitializerFallback, options);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Otherwise, the name itself is a BindingPattern. This will happen for example if an ObjectBindingPattern occurs within an ArrayBindingPattern\n\telse if (!typescript.isIdentifier(node.name) && !typescript.isPrivateIdentifier?.(node.name) && node.propertyName == null) {\n\t\t// Fall back to using the initializer of the BindingElement if the property value is null-like and if it has one\n\t\tconst propertyValueWithInitializerFallback = rightHandValue != null ? rightHandValue : bindingElementInitializer;\n\n\t\tevaluate.nodeWithArgument(node.name, propertyValueWithInitializerFallback, options);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, an ObjectBindingPattern, based on an initializer\n */\nexport function evaluateObjectBindingPattern({node, evaluate, ...options}: EvaluatorOptions<TS.ObjectBindingPattern>, rightHandValue: Literal): void {\n\tfor (const element of node.elements) {\n\t\tevaluate.nodeWithArgument(element, rightHandValue, options);\n\n\t\tif (options.getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment.js\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment.js\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol.js\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol.js\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a CaseBlock, based on a switch expression\n */\nexport function evaluateCaseBlock(options: EvaluatorOptions<TS.CaseBlock>, switchExpression: Literal): void {\n\tconst {node, evaluate, environment, getCurrentError} = options;\n\t// Prepare a lexical environment for the case block\n\tconst localEnvironment = cloneLexicalEnvironment(environment, node);\n\tconst nextOptions = {...options, environment: localEnvironment};\n\t// Define a new binding for a break symbol within the environment\n\tsetInLexicalEnvironment({...nextOptions, path: BREAK_SYMBOL, value: false, newBinding: true});\n\n\tfor (const clause of node.clauses) {\n\t\tevaluate.nodeWithArgument(clause, switchExpression, nextOptions);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if a 'break', 'continue', or 'return' statement has been encountered, break the block\n\t\tif (pathInLexicalEnvironmentEquals(node, localEnvironment, true, BREAK_SYMBOL, CONTINUE_SYMBOL, RETURN_SYMBOL)) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {pathInLexicalEnvironmentEquals} from \"../lexical-environment/lexical-environment.js\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol.js\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol.js\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a CaseClause, based on a switch expression\n */\nexport function evaluateCaseClause({node, evaluate, ...options}: EvaluatorOptions<TS.CaseClause>, switchExpression: Literal): void {\n\tconst {getCurrentError} = options;\n\tconst expressionResult = evaluate.expression(node.expression, options);\n\t// Stop immediately if the expression doesn't match the switch expression\n\tif (expressionResult !== switchExpression || getCurrentError() != null) return;\n\n\tfor (const statement of node.statements) {\n\t\tevaluate.statement(statement, options);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if a 'break', 'continue', or 'return' statement has been encountered, break the block\n\t\tif (pathInLexicalEnvironmentEquals(node, options.environment, true, BREAK_SYMBOL, CONTINUE_SYMBOL, RETURN_SYMBOL)) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {pathInLexicalEnvironmentEquals} from \"../lexical-environment/lexical-environment.js\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol.js\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol.js\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a DefaultClause, based on a switch expression\n */\nexport function evaluateDefaultClause(options: EvaluatorOptions<TS.DefaultClause>): void {\n\tconst {node, evaluate, environment, getCurrentError} = options;\n\tfor (const statement of node.statements) {\n\t\tevaluate.statement(statement, options);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if a 'break', 'continue', or 'return' statement has been encountered, break the block\n\t\tif (pathInLexicalEnvironmentEquals(node, environment, true, BREAK_SYMBOL, CONTINUE_SYMBOL, RETURN_SYMBOL)) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a CatchClause, based on a given Error\n */\nexport function evaluateCatchClause(options: EvaluatorOptions<TS.CatchClause>, ex: Error): void {\n\tconst {node, evaluate, environment, getCurrentError} = options;\n\t// If a catch binding is provided, we must provide a local lexical environment for the CatchBlock\n\tconst catchEnvironment = node.variableDeclaration == null ? environment : cloneLexicalEnvironment(environment, node);\n\tconst nextOptions = {...options, environment: catchEnvironment};\n\n\t// Evaluate the catch binding, if any is provided\n\tif (node.variableDeclaration != null) {\n\t\tevaluate.nodeWithArgument(node.variableDeclaration, ex, nextOptions);\n\n\t\tif (getCurrentError() != null) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Evaluate the block\n\tevaluate.statement(node.block, nextOptions);\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a OmittedExpression\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function evaluateOmittedExpression(_options: EvaluatorOptions<TS.OmittedExpression>): undefined {\n\treturn undefined;\n}\n","/* eslint-disable @typescript-eslint/strict-boolean-expressions */\n/**\n * This is ported over from tslib to avoid having it as a runtime dependency\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function __decorate<T>(decorators: CallableFunction[], target: T, key?: PropertyKey, desc?: PropertyDescriptor) {\n\tconst c = arguments.length;\n\tlet r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key!)) : desc;\n\tlet d;\n\t// eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\tfor (let i = decorators.length - 1; i >= 0; i--) if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t// eslint-disable-next-line no-sequences\n\treturn c > 3 && r && Object.defineProperty(target, key!, r), r;\n}\n\n/**\n * This is ported over from tslib to avoid having it as a runtime dependency\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function __param(paramIndex: number, decorator: CallableFunction): CallableFunction {\n\treturn function <T>(target: T, key: PropertyKey) {\n\t\tdecorator(target, key, paramIndex);\n\t};\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {IndexLiteral} from \"../literal/literal.js\";\nimport { stringifyLiteral} from \"../literal/literal.js\";\nimport {NotCallableError} from \"../error/not-callable-error/not-callable-error.js\";\nimport type {TS} from \"../../type/ts.js\";\nimport {__decorate, __param} from \"../util/tslib/tslib-util.js\";\nimport type {EvaluationError} from \"../error/evaluation-error/evaluation-error.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a Decorator\n */\nexport function evaluateDecorator(options: EvaluatorOptions<TS.Decorator>, [parent, propertyName, index]: [IndexLiteral, string?, number?]): void | EvaluationError {\n\tconst {node, evaluate, environment, throwError, stack, getCurrentError} = options;\n\tconst decoratorImplementation = evaluate.expression(node.expression, options);\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\tif (typeof decoratorImplementation !== \"function\") {\n\t\treturn throwError(\n\t\t\tnew NotCallableError({\n\t\t\t\tnode,\n\t\t\t\tenvironment,\n\t\t\t\tvalue: decoratorImplementation,\n\t\t\t\tmessage: `${stringifyLiteral(decoratorImplementation)} is not a valid decorator implementation'`\n\t\t\t})\n\t\t);\n\t}\n\n\tstack.push(__decorate([index != null ? __param(index, decoratorImplementation) : decoratorImplementation], parent, propertyName));\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {IndexLiteral, IndexLiteralKey} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, an EnumMember\n */\nexport function evaluateEnumMember(options: EvaluatorOptions<TS.EnumMember>, parent: IndexLiteral): void {\n\tconst {node, typeChecker, evaluate, getCurrentError} = options;\n\tlet constantValue = typeChecker?.getConstantValue(node);\n\n\t// If the constant value is not defined, that must be due to the type checker either not being given or functioning incorrectly.\n\t// Calculate it manually instead\n\tif (constantValue == null) {\n\t\tif (node.initializer != null) {\n\t\t\tconstantValue = evaluate.expression(node.initializer, options) as string | number | undefined;\n\n\t\t\tif (getCurrentError() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tconst siblings = node.parent.members;\n\n\t\t\tconst thisIndex = siblings.findIndex(member => member === node);\n\t\t\tconst beforeSiblings = siblings.slice(0, thisIndex);\n\t\t\tlet traversal = 0;\n\n\t\t\tfor (const sibling of [...beforeSiblings].reverse()) {\n\t\t\t\ttraversal++;\n\t\t\t\tif (sibling.initializer != null) {\n\t\t\t\t\tconst siblingConstantValue = evaluate.expression(sibling.initializer, options) as string | number | undefined;\n\n\t\t\t\t\tif (getCurrentError() != null) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof siblingConstantValue === \"number\") {\n\t\t\t\t\t\tconstantValue = siblingConstantValue + traversal;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (constantValue == null) {\n\t\t\t\tconstantValue = thisIndex;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst propertyName = evaluate.nodeWithValue(node.name, options) as IndexLiteralKey;\n\n\tif (getCurrentError() != null) {\n\t\treturn;\n\t}\n\n\t// If it is a String enum, all keys will be initialized to strings\n\tif (typeof constantValue === \"string\") {\n\t\tparent[propertyName] = constantValue;\n\t} else {\n\t\tparent[(parent[propertyName] = constantValue ?? 0)] = propertyName;\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {IndexLiteral, Literal} from \"../literal/literal.js\";\nimport {evaluateBindingName} from \"./evaluate-binding-name.js\";\nimport {evaluateGetAccessorDeclaration} from \"./evaluate-get-accessor-declaration.js\";\nimport {evaluateSetAccessorDeclaration} from \"./evaluate-set-accessor-declaration.js\";\nimport {evaluatePropertyAssignment} from \"./evaluate-property-assignment.js\";\nimport {evaluateParameterDeclaration} from \"./evaluate-parameter-declaration.js\";\nimport {evaluateShorthandPropertyAssignment} from \"./evaluate-shorthand-property-assignment.js\";\nimport {evaluateSpreadAssignment} from \"./evaluate-spread-assignment.js\";\nimport {evaluateMethodDeclaration} from \"./evaluate-method-declaration.js\";\nimport {evaluateArrayBindingPattern} from \"./evaluate-array-binding-pattern.js\";\nimport {evaluateBindingElement} from \"./evaluate-binding-element.js\";\nimport {evaluateObjectBindingPattern} from \"./evaluate-object-binding-pattern.js\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error.js\";\nimport {evaluateCaseBlock} from \"./evaluate-case-block.js\";\nimport {evaluateCaseClause} from \"./evaluate-case-clause.js\";\nimport {evaluateDefaultClause} from \"./evaluate-default-clause.js\";\nimport {evaluateVariableDeclaration} from \"./evaluate-variable-declaration.js\";\nimport {evaluateCatchClause} from \"./evaluate-catch-clause.js\";\nimport {evaluateOmittedExpression} from \"./evaluate-omitted-expression.js\";\nimport {evaluatePropertyDeclaration} from \"./evaluate-property-declaration.js\";\nimport {evaluateDecorator} from \"./evaluate-decorator.js\";\nimport {evaluateEnumMember} from \"./evaluate-enum-member.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates a given node with the provided argument\n */\nexport function evaluateNodeWithArgument(options: EvaluatorOptions<TS.Node>, arg: Literal): void {\n\toptions.logger.logNode(options.node, options.typescript, \"nodeWithArgument\");\n\tconst {node, ...rest} = options;\n\n\tif (rest.typescript.isGetAccessorDeclaration(node)) {\n\t\tevaluateGetAccessorDeclaration({node, ...rest}, arg as IndexLiteral);\n\t} else if (rest.typescript.isSetAccessorDeclaration(node)) {\n\t\tevaluateSetAccessorDeclaration({node, ...rest}, arg as IndexLiteral);\n\t} else if (rest.typescript.isPropertyAssignment(node)) {\n\t\tevaluatePropertyAssignment({node, ...rest}, arg as IndexLiteral);\n\t} else if (rest.typescript.isPropertyDeclaration(node)) {\n\t\tevaluatePropertyDeclaration({node, ...rest}, arg as IndexLiteral);\n\t} else if (rest.typescript.isParameter(node)) {\n\t\tevaluateParameterDeclaration({node, ...rest}, arg);\n\t} else if (rest.typescript.isEnumMember(node)) {\n\t\tevaluateEnumMember({node, ...rest}, arg as IndexLiteral);\n\t} else if (rest.typescript.isShorthandPropertyAssignment(node)) {\n\t\tevaluateShorthandPropertyAssignment({node, ...rest}, arg as IndexLiteral);\n\t} else if (rest.typescript.isDecorator(node)) {\n\t\tevaluateDecorator({node, ...rest}, arg as [IndexLiteral, string?]);\n\t} else if (rest.typescript.isSpreadAssignment(node)) {\n\t\tevaluateSpreadAssignment({node, ...rest}, arg as IndexLiteral);\n\t} else if (rest.typescript.isMethodDeclaration(node)) {\n\t\tevaluateMethodDeclaration({node, ...rest}, arg as IndexLiteral);\n\t} else if (rest.typescript.isArrayBindingPattern(node)) {\n\t\tevaluateArrayBindingPattern({node, ...rest}, arg as Iterable<Literal>);\n\t} else if (rest.typescript.isBindingElement(node)) {\n\t\tevaluateBindingElement({node, ...rest}, arg);\n\t} else if (rest.typescript.isObjectBindingPattern(node)) {\n\t\tevaluateObjectBindingPattern({node, ...rest}, arg);\n\t} else if (rest.typescript.isVariableDeclaration(node)) {\n\t\tevaluateVariableDeclaration({node, ...rest}, arg);\n\t} else if (rest.typescript.isCaseBlock(node)) {\n\t\tevaluateCaseBlock({node, ...rest}, arg);\n\t} else if (rest.typescript.isCaseClause(node)) {\n\t\tevaluateCaseClause({node, ...rest}, arg);\n\t} else if (rest.typescript.isDefaultClause(node)) {\n\t\tevaluateDefaultClause({node, ...rest});\n\t} else if (rest.typescript.isCatchClause(node)) {\n\t\tevaluateCatchClause({node, ...rest}, arg as Error);\n\t} else if (rest.typescript.isBindingName(node)) {\n\t\tevaluateBindingName({node, ...rest}, arg);\n\t} else if (rest.typescript.isOmittedExpression(node)) {\n\t\tevaluateOmittedExpression({node, ...rest});\n\t} else if (options.getCurrentError() != null) {\n\t\treturn;\n\t} else {\n\t\trest.throwError(new UnexpectedNodeError({node, environment: rest.environment, typescript: rest.typescript}));\n\t}\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {IndexLiteralKey, Literal} from \"../literal/literal.js\";\nimport type {TS} from \"../../type/ts.js\";\n\n/**\n * Evaluates, or attempts to evaluate, a PropertyName\n */\nexport function evaluatePropertyName({node, evaluate, typescript, ...options}: EvaluatorOptions<TS.PropertyName>): Literal {\n\treturn (\n\t\ttypescript.isComputedPropertyName(node)\n\t\t\t? evaluate.expression(node.expression, options)\n\t\t\t: typescript.isIdentifier(node) || typescript.isPrivateIdentifier?.(node)\n\t\t\t? node.text\n\t\t\t: evaluate.expression(node as TS.StringLiteral | TS.NumericLiteral, options)\n\t) as IndexLiteralKey;\n}\n","import type {EvaluatorOptions} from \"./evaluator-options.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport type {NodeWithValue} from \"./node-evaluator/node-evaluator.js\";\nimport {evaluatePropertyName} from \"./evaluate-property-name.js\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error.js\";\n\n/**\n * Evaluates a given node with the provided argument\n */\nexport function evaluateNodeWithValue(options: EvaluatorOptions<NodeWithValue>): Literal {\n\toptions.logger.logNode(options.node, options.typescript, \"nodeWithValue\");\n\tconst {node, ...rest} = options;\n\n\t// Until #37135 is resolved, isPropertyName will return false for PrivateIdentifiers (even though they are actually PropertyNames)\n\tif (options.typescript.isPropertyName(node) || options.typescript.isPrivateIdentifier(node)) {\n\t\treturn evaluatePropertyName({node, ...rest});\n\t}\n\n\treturn options.throwError(new UnexpectedNodeError({node, environment: options.environment, typescript: options.typescript}));\n}\n","import type {ICreateNodeEvaluatorOptions} from \"./i-create-node-evaluator-options.js\";\nimport type {NodeEvaluator} from \"./node-evaluator.js\";\nimport {MaxOpsExceededError} from \"../../error/policy-error/max-ops-exceeded-error/max-ops-exceeded-error.js\";\nimport {evaluateStatement} from \"../evaluate-statement.js\";\nimport {evaluateExpression} from \"../evaluate-expression.js\";\nimport type {EvaluatorOptions, NextEvaluatorOptions} from \"../evaluator-options.js\";\nimport {evaluateDeclaration} from \"../evaluate-declaration.js\";\nimport {evaluateNodeWithArgument} from \"../evaluate-node-with-argument.js\";\nimport {evaluateNodeWithValue} from \"../evaluate-node-with-value.js\";\nimport {createStatementTraversalStack} from \"../../stack/traversal-stack/statement-traversal-stack.js\";\nimport type {TS} from \"../../../type/ts.js\";\nimport type {EvaluationError} from \"../../error/evaluation-error/evaluation-error.js\";\nimport { isEvaluationError} from \"../../error/evaluation-error/evaluation-error.js\";\nimport type { Literal } from \"../../literal/literal.js\";\n\n/**\n * Creates a Node Evaluator\n */\nexport function createNodeEvaluator(options: ICreateNodeEvaluatorOptions): NodeEvaluator {\n\tlet ops = 0;\n\n\tconst {policy, reporting} = options;\n\n\tconst prequalifyNextNode = (node: TS.Node, nextOptions: NextEvaluatorOptions): EvaluationError | void => {\n\t\tconst {\n\t\t\tenvironment = options.environment,\n\t\t\tstatementTraversalStack = options.statementTraversalStack,\n\t\t\tgetCurrentError = options.getCurrentError,\n\t\t\tthrowError = options.throwError\n\t\t} = nextOptions ?? {};\n\t\tconst currentError = getCurrentError();\n\t\tif (currentError != null) {\n\t\t\treturn currentError;\n\t\t}\n\n\t\t// Increment the amount of encountered ops\n\t\tops++;\n\n\t\t// Throw an error if the maximum amount of operations has been exceeded\n\t\tif (ops >= policy.maxOps) {\n\t\t\treturn throwError(new MaxOpsExceededError({ops, environment, node}));\n\t\t}\n\n\t\t// Update the statementTraversalStack with the node's kind\n\t\tstatementTraversalStack.push(node.kind);\n\t\tif (reporting.reportTraversal != null) {\n\t\t\treporting.reportTraversal({node});\n\t\t}\n\t\treturn undefined;\n\t};\n\n\tconst evaluate: NodeEvaluator = {\n\t\t\n\t\tstatement: (node, nextOptions): void => {\n\t\t\tconst combinedNextOptions = {...nextOptions, statementTraversalStack: createStatementTraversalStack()};\n\t\t\tconst prequalifyResult = prequalifyNextNode(node, combinedNextOptions);\n\t\t\tif (isEvaluationError(prequalifyResult)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn evaluateStatement(getEvaluatorOptions(node, combinedNextOptions));\n\t\t},\n\t\tdeclaration: (node, nextOptions): void => {\n\t\t\tconst prequalifyResult = prequalifyNextNode(node, nextOptions);\n\t\t\tif (isEvaluationError(prequalifyResult)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn evaluateDeclaration(getEvaluatorOptions(node, nextOptions));\n\t\t},\n\t\tnodeWithArgument: (node, arg, nextOptions): void => {\n\t\t\tconst prequalifyResult = prequalifyNextNode(node, nextOptions);\n\t\t\tif (isEvaluationError(prequalifyResult)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn evaluateNodeWithArgument(getEvaluatorOptions(node, nextOptions), arg);\n\t\t},\n\t\texpression: (node, nextOptions): Literal|EvaluationError => {\n\t\t\tconst prequalifyResult = prequalifyNextNode(node, nextOptions);\n\t\t\tif (isEvaluationError(prequalifyResult)) {\n\t\t\t\treturn prequalifyResult;\n\t\t\t}\n\t\t\treturn evaluateExpression(getEvaluatorOptions(node, nextOptions));\n\t\t},\n\t\tnodeWithValue: (node, nextOptions): Literal|EvaluationError => {\n\t\t\tconst prequalifyResult = prequalifyNextNode(node, nextOptions);\n\t\t\tif (isEvaluationError(prequalifyResult)) {\n\t\t\t\treturn prequalifyResult;\n\t\t\t}\n\t\t\treturn evaluateNodeWithValue(getEvaluatorOptions(node, nextOptions));\n\t\t}\n\t};\n\n\t/**\n\t * Gets an IEvaluatorOptions object ready for passing to one of the evaluation functions\n\t */\n\tfunction getEvaluatorOptions<T extends TS.Node>(node: T, nextOptions: NextEvaluatorOptions): EvaluatorOptions<T> {\n\t\treturn {\n\t\t\t...options,\n\t\t\t...nextOptions,\n\t\t\tevaluate,\n\t\t\tnode\n\t\t};\n\t}\n\n\treturn evaluate;\n}\n","export const enum LogLevelKind {\n\tSILENT = 0,\n\tINFO = 1,\n\tVERBOSE = 2,\n\tDEBUG = 3\n}\n","import type {TS} from \"../../../type/ts.js\";\n\n/**\n * Stringifies the given SyntaxKind\n */\nexport function stringifySyntaxKind(kind: TS.SyntaxKind, typescript: typeof TS): string {\n\tif (kind === typescript.SyntaxKind.NumericLiteral) return \"NumericLiteral\";\n\treturn typescript.SyntaxKind[kind];\n}\n","import {LogLevelKind} from \"./log-level.js\";\nimport {stringifySyntaxKind} from \"../util/syntax-kind/stringify-syntax-kind.js\";\nimport type {Literal} from \"../literal/literal.js\";\nimport { stringifyLiteral} from \"../literal/literal.js\";\nimport type {Stack} from \"../stack/stack.js\";\nimport type {StatementTraversalStack} from \"../stack/traversal-stack/statement-traversal-stack.js\";\nimport {inspect} from \"util\";\nimport type {TS} from \"../../type/ts.js\";\nimport type {PartialDeep} from \"helpertypes\";\nimport color from \"ansi-colors\";\n\nexport type LoggerColor = \"white\" | \"cyan\" | \"yellow\" | \"magenta\" | \"gray\" | \"red\";\n\nexport interface LoggerColorOptions {\n\tinfo: LoggerColor;\n\tverbose: LoggerColor;\n\tdebug: LoggerColor;\n}\n\nexport interface LoggerOptions {\n\tlogLevel: LogLevelKind;\n\tcolor: LoggerColorOptions;\n}\n\n/**\n * A simple logger for printing evaluation-related info\n */\nexport class Logger {\n\tprivate readonly options: LoggerOptions;\n\n\tconstructor(logLevel?: LogLevelKind);\n\tconstructor(options?: PartialDeep<LoggerOptions>);\n\tconstructor(optionsOrLogLevel?: LogLevelKind | PartialDeep<LoggerOptions>);\n\tconstructor(optionsOrLogLevel: LogLevelKind | PartialDeep<LoggerOptions> = {}) {\n\t\tconst {logLevel = LogLevelKind.SILENT, color: {info = \"white\", verbose = \"yellow\", debug = \"magenta\"} = {}} =\n\t\t\ttypeof optionsOrLogLevel === \"object\" ? optionsOrLogLevel : {logLevel: optionsOrLogLevel};\n\t\tthis.options = {\n\t\t\tlogLevel,\n\t\t\tcolor: {\n\t\t\t\tinfo,\n\t\t\t\tverbose,\n\t\t\t\tdebug\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Logs info output if the log level allows it\n\t */\n\tlogInfo(message: string): void {\n\t\tif (this.options.logLevel < LogLevelKind.INFO) return;\n\t\tconsole.log(this.formatWithColor(this.options.color.info, message));\n\t}\n\n\t/**\n\t * Logs verbose output if the log level allows it\n\t */\n\tlogVerbose(message: string): void {\n\t\tif (this.options.logLevel < LogLevelKind.VERBOSE) return;\n\t\tconsole.log(this.formatWithColor(this.options.color.verbose, message));\n\t}\n\n\t/**\n\t * Logs debug output if the log level allows it\n\t */\n\tlogDebug(message: string): void {\n\t\tif (this.options.logLevel < LogLevelKind.DEBUG) return;\n\t\tconsole.log(this.formatWithColor(this.options.color.debug, message));\n\t}\n\n\t/**\n\t * Logs that a 'continue' keyword appeared within a statement\n\t */\n\tlogContinue(node: TS.Node, typescript: typeof TS): void {\n\t\tif (this.options.logLevel < LogLevelKind.DEBUG) return;\n\t\tconsole.log(\n\t\t\t`${this.formatWithColor(this.options.color.debug, `continue`)} encountered within ${this.formatWithColor(\n\t\t\t\tthis.options.color.debug,\n\t\t\t\tstringifySyntaxKind(node.kind, typescript)\n\t\t\t)}`\n\t\t);\n\t}\n\n\t/**\n\t * Logs that a 'break' keyword appeared within a statement\n\t */\n\tlogBreak(node: TS.Node, typescript: typeof TS): void {\n\t\tif (this.options.logLevel < LogLevelKind.DEBUG) return;\n\t\tconsole.log(\n\t\t\t`${this.formatWithColor(this.options.color.debug, `break`)} encountered within ${this.formatWithColor(this.options.color.debug, stringifySyntaxKind(node.kind, typescript))}`\n\t\t);\n\t}\n\n\t/**\n\t * Logs that a 'return' keyword appeared within a statement\n\t */\n\tlogReturn(node: TS.Node, typescript: typeof TS): void {\n\t\tif (this.options.logLevel < LogLevelKind.DEBUG) return;\n\t\tconsole.log(\n\t\t\t`${this.formatWithColor(this.options.color.debug, `return`)} encountered within ${this.formatWithColor(this.options.color.debug, stringifySyntaxKind(node.kind, typescript))}`\n\t\t);\n\t}\n\n\t/**\n\t * Logs the given result\n\t */\n\tlogResult(result: Literal, intermediateContext?: string): void {\n\t\tif (this.options.logLevel < LogLevelKind.INFO) return;\n\t\tif (intermediateContext != null) {\n\t\t\tconsole.log(\n\t\t\t\tthis.formatWithColor(this.options.color.info, `(intermediate value from context '${intermediateContext}'):`),\n\t\t\t\tthis.formatWithColor(this.options.color.info, `[RESULT]:`),\n\t\t\t\tthis.compactValue(result)\n\t\t\t);\n\t\t} else {\n\t\t\tconsole.log(this.formatWithColor(this.options.color.info, `[RESULT]:`), result);\n\t\t}\n\t}\n\n\t/**\n\t * Logs the given evaluation\n\t */\n\tlogNode(node: TS.Node, typescript: typeof TS, context?: string): void {\n\t\tif (this.options.logLevel < LogLevelKind.DEBUG) return;\n\n\t\tlet headRaw = `[${stringifySyntaxKind(node.kind, typescript)}]`.padEnd(25);\n\t\tif (context != null) headRaw += this.formatWithColor(this.options.color.debug, `(${context})`);\n\t\tconst tailRaw = node.getText();\n\n\t\tconst head = this.formatWithColor(this.options.color.debug, headRaw);\n\t\tconst tail = this.formatWithColor(this.options.color.debug, tailRaw);\n\n\t\tconsole.log(head);\n\t\tconsole.log(tail);\n\t}\n\n\t/**\n\t * Logs the given binding\n\t */\n\tlogBinding(lValue: string, rValue: Literal, scope?: string): void {\n\t\tif (this.options.logLevel < LogLevelKind.VERBOSE) return;\n\t\tconsole.log(\n\t\t\t`${scope == null ? \"\" : this.formatWithColor(this.options.color.verbose, `(${scope}): `)}${this.formatWithColor(this.options.color.verbose, `${lValue} ->`)}`,\n\t\t\tthis.formatWithColor(this.options.color.verbose, this.compactValue(rValue))\n\t\t);\n\t}\n\n\t/**\n\t * Logs the heritage of a ClassDeclaration\n\t */\n\tlogHeritage(classDeclaration: CallableFunction): void {\n\t\tif (this.options.logLevel < LogLevelKind.DEBUG) return;\n\t\tconst parent = Object.getPrototypeOf(classDeclaration);\n\t\t// eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\t\tif (parent.toString().includes(\"[Class\")) {\n\t\t\tconsole.log(\n\t\t\t\t`${this.formatWithColor(this.options.color.debug, classDeclaration.toString())} ${this.formatWithColor(this.options.color.debug, `extends`)} ${this.formatWithColor(\n\t\t\t\t\tthis.options.color.debug,\n\t\t\t\t\tparent.toString()\n\t\t\t\t)}`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Logs the newest value has been pushed onto the Stack\n\t */\n\tlogStack(stack: Stack): void {\n\t\tif (this.options.logLevel < LogLevelKind.DEBUG) return;\n\t\tconsole.log(this.formatWithColor(this.options.color.debug, `Stack value: ${stringifyLiteral(this.compactValue(stack.lastItem))}`));\n\t}\n\n\t/**\n\t * Logs the entire Traversal Stack\n\t */\n\tlogStatementTraversalStack(stack: StatementTraversalStack, typescript: typeof TS): void {\n\t\tif (this.options.logLevel < LogLevelKind.DEBUG) return;\n\t\tconsole.log(this.formatWithColor(this.options.color.debug, `[${stack.map(kind => stringifySyntaxKind(kind, typescript)).join(\", \")}]`));\n\t}\n\n\t/**\n\t * Makes a value compact so it is easier on the eyes when printing it\n\t */\n\tprivate compactValue<T>(value: T): string {\n\t\treturn inspect(value, {depth: 0, colors: true, compact: true, maxArrayLength: 5});\n\t}\n\n\tprivate formatWithColor(loggerColor: LoggerColor, message: string): string {\n\t\treturn color[loggerColor](message);\n\t}\n}\n","import type {TS} from \"../../../type/ts.js\";\n\n/**\n * Returns true if the given Node is an Expression.\n * Uses an internal non-exposed Typescript helper to decide whether or not the Node is an Expression\n */\nexport function isExpression(node: TS.Node, typescript: typeof TS): node is TS.Expression {\n\treturn (typescript as unknown as {isExpressionNode(node: TS.Node): boolean}).isExpressionNode(node) || typescript.isIdentifier(node) || typescript.isPrivateIdentifier?.(node);\n}\n","import type {TS} from \"../../../type/ts.js\";\n\n/**\n * Returns true if the given Node is a Statement\n * Uses an internal non-exposed Typescript helper to decide whether or not the Node is an Expression\n */\nexport function isStatement(node: TS.Node, typescript: typeof TS): node is TS.Statement {\n\treturn (typescript as unknown as {isStatementButNotDeclaration(node: TS.Node): boolean}).isStatementButNotDeclaration(node);\n}\n","import type {Literal} from \"../literal/literal.js\";\n\nexport interface Stack {\n\treadonly length: number;\n\treadonly lastItem: StackEntry | undefined;\n\t[Symbol.iterator](): IterableIterator<StackEntry>;\n\tpush(...values: StackEntry[]): number;\n\tpop(): StackEntry | undefined;\n}\n\nexport type StackEntry = Literal;\n\n/**\n * Creates a Stack\n *\n * @return\n */\nexport function createStack(): Stack {\n\tconst stack: StackEntry[] = [];\n\n\treturn {\n\t\t/**\n\t\t * Gets an iterator for the Stack\n\t\t *\n\t\t * @return\n\t\t */\n\t\t[Symbol.iterator]() {\n\t\t\treturn stack[Symbol.iterator]();\n\t\t},\n\n\t\t/**\n\t\t * Gets the length of the Stack\n\t\t *\n\t\t * @return\n\t\t */\n\t\tget length() {\n\t\t\treturn stack.length;\n\t\t},\n\n\t\t/**\n\t\t * Gets the last item of the Stack\n\t\t *\n\t\t * @return\n\t\t */\n\t\tget lastItem() {\n\t\t\treturn stack[stack.length - 1];\n\t\t},\n\n\t\t/**\n\t\t * Pushes the given StackEntries on to the Stack\n\t\t *\n\t\t * @param values\n\t\t * @return\n\t\t */\n\t\tpush(...values: StackEntry[]) {\n\t\t\treturn stack.push(...values);\n\t\t},\n\n\t\t/**\n\t\t * Pops the last item from the stack\n\t\t *\n\t\t * @return\n\t\t */\n\t\tpop() {\n\t\t\treturn stack.pop();\n\t\t}\n\t};\n}\n","import type {ReportingOptionsSanitized} from \"../../reporting/i-reporting-options.js\";\nimport {EvaluationError} from \"../../error/evaluation-error/evaluation-error.js\";\nimport type {TS} from \"../../../type/ts.js\";\n\n/**\n * Reports an error\n */\nexport function reportError(reporting: ReportingOptionsSanitized, error: Error, node: TS.Node): void {\n\t// Report the error if a reporter is hooked up\n\tif (reporting.reportErrors != null && !reporting.reportedErrorSet.has(error)) {\n\t\treporting.reportedErrorSet.add(error);\n\t\treporting.reportErrors({\n\t\t\terror: error,\n\t\t\tnode: error instanceof EvaluationError ? error.node : node\n\t\t});\n\t}\n}\n","export type ReportedErrorSet = WeakSet<Error>;\n\n/**\n * Creates and returns a Set of Errors that has been seen and has been reported\n */\nexport function createReportedErrorSet(): ReportedErrorSet {\n\treturn new WeakSet<Error>();\n}\n","import * as TSModule from \"typescript\";\nimport type {EvaluateOptions} from \"./evaluate-options.js\";\nimport {createLexicalEnvironment} from \"./lexical-environment/lexical-environment.js\";\nimport type {EvaluateResult} from \"./evaluate-result.js\";\nimport {evaluateSimpleLiteral} from \"./evaluator/simple/evaluate-simple-literal.js\";\nimport {createNodeEvaluator} from \"./evaluator/node-evaluator/create-node-evaluator.js\";\nimport {LogLevelKind} from \"./logger/log-level.js\";\nimport {Logger} from \"./logger/logger.js\";\nimport {createStatementTraversalStack} from \"./stack/traversal-stack/statement-traversal-stack.js\";\nimport {isExpression} from \"./util/expression/is-expression.js\";\nimport type {Literal} from \"./literal/literal.js\";\nimport {isStatement} from \"./util/statement/is-statement.js\";\nimport type { Stack} from \"./stack/stack.js\";\nimport {createStack} from \"./stack/stack.js\";\nimport {isDeclaration} from \"./util/declaration/is-declaration.js\";\nimport {UnexpectedNodeError} from \"./error/unexpected-node-error/unexpected-node-error.js\";\nimport type {EvaluatePolicySanitized} from \"./policy/evaluate-policy.js\";\nimport {reportError} from \"./util/reporting/report-error.js\";\nimport {createReportedErrorSet} from \"./reporting/reported-error-set.js\";\nimport type {ReportingOptionsSanitized} from \"./reporting/i-reporting-options.js\";\nimport type {EvaluationError, ThrowError} from \"./error/evaluation-error/evaluation-error.js\";\nimport type { ICreateNodeEvaluatorOptions } from \"./evaluator/node-evaluator/i-create-node-evaluator-options.js\";\n/**\n * Will get a literal value for the given Expression, ExpressionStatement, or Declaration.\n */\nexport function evaluate({\n\ttypeChecker,\n\tnode,\n\tenvironment: {preset = \"NODE\", extra = {}} = {},\n\tmoduleOverrides = {},\n\ttypescript = TSModule,\n\tlogLevel = LogLevelKind.SILENT,\n\tpolicy: {\n\t\tdeterministic = false,\n\t\tnetwork = false,\n\t\tconsole = false,\n\t\tmaxOps = Infinity,\n\t\tmaxOpDuration = Infinity,\n\t\tio = {\n\t\t\tread: true,\n\t\t\twrite: false\n\t\t},\n\t\tprocess = {\n\t\t\texit: false,\n\t\t\tspawnChild: false\n\t\t}\n\t} = {},\n\treporting: reportingInput = {}\n}: EvaluateOptions): EvaluateResult {\n\t// Take the simple path first. This may be far more performant than building up an environment\n\tconst simpleLiteralResult = evaluateSimpleLiteral(node, typescript);\n\tif (simpleLiteralResult.success) return simpleLiteralResult;\n\n\t// Otherwise, build an environment and get to work\n\t// Sanitize the evaluation policy based on the input options\n\tconst policy: EvaluatePolicySanitized = {\n\t\tdeterministic,\n\t\tmaxOps,\n\t\tmaxOpDuration,\n\t\tnetwork,\n\t\tconsole,\n\t\tio: {\n\t\t\tread: typeof io === \"boolean\" ? io : io.read,\n\t\t\twrite: typeof io === \"boolean\" ? io : io.write\n\t\t},\n\t\tprocess: {\n\t\t\texit: typeof process === \"boolean\" ? process : process.exit,\n\t\t\tspawnChild: typeof process === \"boolean\" ? process : process.spawnChild\n\t\t}\n\t};\n\n\t// Sanitize the Reporting options based on the input options\n\tconst reporting: ReportingOptionsSanitized = {\n\t\t...reportingInput,\n\t\treportedErrorSet: createReportedErrorSet()\n\t};\n\n\t/**\n\t * The error that has been thrown most recently.\n\t * We can' just throw errors internally, as some tools may patch error handling\n\t * and treat them as uncaught exceptions, which breaks the behavior of evaluate,\n\t * which never throws and instead returns a record with a {success: false, reason: Error} value.\n\t */\n\tlet error: EvaluationError | undefined;\n\n\t// Prepare a logger\n\tconst logger = new Logger(logLevel);\n\n\tconst throwError: ThrowError = ex => {\n\t\t// Report the Error\n\t\treportError(reporting, ex, ex.node);\n\t\terror = ex;\n\t\treturn error;\n\t};\n\n\t// Prepare the initial environment\n\tconst environment = createLexicalEnvironment({\n\t\tinputEnvironment: {\n\t\t\tpreset,\n\t\t\textra\n\t\t},\n\t\tstartingNode: node,\n\t\tpolicy\n\t});\n\n\t// Prepare a Stack\n\tconst stack: Stack = createStack();\n\n\tconst statementTraversalStack = createStatementTraversalStack();\n\n\tconst nodeEvaluatorOptions: ICreateNodeEvaluatorOptions = {\n\t\tpolicy,\n\t\ttypeChecker,\n\t\ttypescript,\n\t\tlogger,\n\t\tstack,\n\t\tmoduleOverrides,\n\t\treporting,\n\t\tthrowError,\n\t\tenvironment,\n\t\tstatementTraversalStack,\n\t\tgetCurrentError: () => error\n\t};\n\n\t// Prepare a NodeEvaluator\n\tconst nodeEvaluator = createNodeEvaluator(nodeEvaluatorOptions);\n\n\ttry {\n\t\tlet value: Literal;\n\t\tif (isExpression(node, typescript)) {\n\t\t\tvalue = nodeEvaluator.expression(node, nodeEvaluatorOptions);\n\t\t} else if (isStatement(node, typescript)) {\n\t\t\tnodeEvaluator.statement(node, nodeEvaluatorOptions);\n\t\t\tvalue = stack.pop();\n\t\t} else if (isDeclaration(node, typescript)) {\n\t\t\tnodeEvaluator.declaration(node, nodeEvaluatorOptions);\n\t\t\tvalue = stack.pop();\n\t\t}\n\n\t\t// Otherwise, produce an UnexpectedNodeError\n\t\telse {\n\t\t\tthrowError(new UnexpectedNodeError({node, environment, typescript}));\n\t\t}\n\n\t\tif (error != null) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\treason: error\n\t\t\t};\n\t\t} else {\n\t\t\t// Log the value before returning\n\t\t\tlogger.logResult(value);\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tvalue\n\t\t\t};\n\t\t}\n\t} catch (reason) {\n\t\tthrowError(reason as EvaluationError);\n\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\treason: reason as EvaluationError\n\t\t};\n\t}\n}\n"],"names":["createRequire","LogLevelKind","inspect","TSModule"],"mappings":"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"}